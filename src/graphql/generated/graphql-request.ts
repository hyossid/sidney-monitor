import { GraphQLClient } from 'graphql-request';
import * as Dom from 'graphql-request/dist/types.dom';
import gql from 'graphql-tag';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  DateTime: any;
  Dimension: any;
  HexColor: any;
  JSON: any;
  Quality: any;
  bigint: any;
  bytea: any;
  float8: any;
  jsonb: any;
  numeric: any;
  smallint: any;
  timestamptz: any;
};

/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/analyticsTabs) */
export type AnalyticsTabs = Entry & {
  __typename?: 'AnalyticsTabs';
  contentfulMetadata: ContentfulMetadata;
  enabled?: Maybe<Scalars['Boolean']>;
  iframeLink?: Maybe<Scalars['String']>;
  linkedFrom?: Maybe<AnalyticsTabsLinkingCollections>;
  sort?: Maybe<Scalars['DateTime']>;
  sys: Sys;
  title?: Maybe<Scalars['String']>;
  urlSlug?: Maybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/analyticsTabs) */
export type AnalyticsTabsEnabledArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/analyticsTabs) */
export type AnalyticsTabsIframeLinkArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/analyticsTabs) */
export type AnalyticsTabsLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/analyticsTabs) */
export type AnalyticsTabsSortArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/analyticsTabs) */
export type AnalyticsTabsTitleArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/analyticsTabs) */
export type AnalyticsTabsUrlSlugArgs = {
  locale?: InputMaybe<Scalars['String']>;
};

export type AnalyticsTabsCollection = {
  __typename?: 'AnalyticsTabsCollection';
  items: Array<Maybe<AnalyticsTabs>>;
  limit: Scalars['Int'];
  skip: Scalars['Int'];
  total: Scalars['Int'];
};

export type AnalyticsTabsFilter = {
  AND?: InputMaybe<Array<InputMaybe<AnalyticsTabsFilter>>>;
  OR?: InputMaybe<Array<InputMaybe<AnalyticsTabsFilter>>>;
  contentfulMetadata?: InputMaybe<ContentfulMetadataFilter>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  enabled_exists?: InputMaybe<Scalars['Boolean']>;
  enabled_not?: InputMaybe<Scalars['Boolean']>;
  iframeLink?: InputMaybe<Scalars['String']>;
  iframeLink_contains?: InputMaybe<Scalars['String']>;
  iframeLink_exists?: InputMaybe<Scalars['Boolean']>;
  iframeLink_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  iframeLink_not?: InputMaybe<Scalars['String']>;
  iframeLink_not_contains?: InputMaybe<Scalars['String']>;
  iframeLink_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  sort?: InputMaybe<Scalars['DateTime']>;
  sort_exists?: InputMaybe<Scalars['Boolean']>;
  sort_gt?: InputMaybe<Scalars['DateTime']>;
  sort_gte?: InputMaybe<Scalars['DateTime']>;
  sort_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  sort_lt?: InputMaybe<Scalars['DateTime']>;
  sort_lte?: InputMaybe<Scalars['DateTime']>;
  sort_not?: InputMaybe<Scalars['DateTime']>;
  sort_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  sys?: InputMaybe<SysFilter>;
  title?: InputMaybe<Scalars['String']>;
  title_contains?: InputMaybe<Scalars['String']>;
  title_exists?: InputMaybe<Scalars['Boolean']>;
  title_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  title_not?: InputMaybe<Scalars['String']>;
  title_not_contains?: InputMaybe<Scalars['String']>;
  title_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  urlSlug?: InputMaybe<Scalars['String']>;
  urlSlug_contains?: InputMaybe<Scalars['String']>;
  urlSlug_exists?: InputMaybe<Scalars['Boolean']>;
  urlSlug_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  urlSlug_not?: InputMaybe<Scalars['String']>;
  urlSlug_not_contains?: InputMaybe<Scalars['String']>;
  urlSlug_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type AnalyticsTabsLinkingCollections = {
  __typename?: 'AnalyticsTabsLinkingCollections';
  entryCollection?: Maybe<EntryCollection>;
};


export type AnalyticsTabsLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
};

export enum AnalyticsTabsOrder {
  EnabledAsc = 'enabled_ASC',
  EnabledDesc = 'enabled_DESC',
  IframeLinkAsc = 'iframeLink_ASC',
  IframeLinkDesc = 'iframeLink_DESC',
  SortAsc = 'sort_ASC',
  SortDesc = 'sort_DESC',
  SysFirstPublishedAtAsc = 'sys_firstPublishedAt_ASC',
  SysFirstPublishedAtDesc = 'sys_firstPublishedAt_DESC',
  SysIdAsc = 'sys_id_ASC',
  SysIdDesc = 'sys_id_DESC',
  SysPublishedAtAsc = 'sys_publishedAt_ASC',
  SysPublishedAtDesc = 'sys_publishedAt_DESC',
  SysPublishedVersionAsc = 'sys_publishedVersion_ASC',
  SysPublishedVersionDesc = 'sys_publishedVersion_DESC',
  TitleAsc = 'title_ASC',
  TitleDesc = 'title_DESC',
  UrlSlugAsc = 'urlSlug_ASC',
  UrlSlugDesc = 'urlSlug_DESC'
}

/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/appConfig) */
export type AppConfig = Entry & {
  __typename?: 'AppConfig';
  allSwapCoinsCollection?: Maybe<AppConfigAllSwapCoinsCollection>;
  commonSwapCoinsCollection?: Maybe<AppConfigCommonSwapCoinsCollection>;
  contentfulMetadata: ContentfulMetadata;
  enableBlockIndicator?: Maybe<Scalars['Boolean']>;
  enableCoFarmFeature?: Maybe<Scalars['Boolean']>;
  enableFarmFeature?: Maybe<Scalars['Boolean']>;
  enableLaunchPadFeature?: Maybe<Scalars['Boolean']>;
  enableLendFeature?: Maybe<Scalars['Boolean']>;
  enableLotteryFeature?: Maybe<Scalars['Boolean']>;
  enableOrderBook?: Maybe<Scalars['Boolean']>;
  enablePoolFeature?: Maybe<Scalars['Boolean']>;
  enableStakeFeature?: Maybe<Scalars['Boolean']>;
  enableSwapFeature?: Maybe<Scalars['Boolean']>;
  enableWrapBridgeFeature?: Maybe<Scalars['Boolean']>;
  env?: Maybe<Scalars['String']>;
  farmingsCollection?: Maybe<AppConfigFarmingsCollection>;
  linkedFrom?: Maybe<AppConfigLinkingCollections>;
  poolsCollection?: Maybe<AppConfigPoolsCollection>;
  stakingBannerCollection?: Maybe<AppConfigStakingBannerCollection>;
  sys: Sys;
  v1StakingCycleLimitBlockHeight?: Maybe<Scalars['Int']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/appConfig) */
export type AppConfigAllSwapCoinsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/appConfig) */
export type AppConfigCommonSwapCoinsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/appConfig) */
export type AppConfigEnableBlockIndicatorArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/appConfig) */
export type AppConfigEnableCoFarmFeatureArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/appConfig) */
export type AppConfigEnableFarmFeatureArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/appConfig) */
export type AppConfigEnableLaunchPadFeatureArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/appConfig) */
export type AppConfigEnableLendFeatureArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/appConfig) */
export type AppConfigEnableLotteryFeatureArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/appConfig) */
export type AppConfigEnableOrderBookArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/appConfig) */
export type AppConfigEnablePoolFeatureArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/appConfig) */
export type AppConfigEnableStakeFeatureArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/appConfig) */
export type AppConfigEnableSwapFeatureArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/appConfig) */
export type AppConfigEnableWrapBridgeFeatureArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/appConfig) */
export type AppConfigEnvArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/appConfig) */
export type AppConfigFarmingsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/appConfig) */
export type AppConfigLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/appConfig) */
export type AppConfigPoolsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/appConfig) */
export type AppConfigStakingBannerCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/appConfig) */
export type AppConfigV1StakingCycleLimitBlockHeightArgs = {
  locale?: InputMaybe<Scalars['String']>;
};

export type AppConfigAllSwapCoinsCollection = {
  __typename?: 'AppConfigAllSwapCoinsCollection';
  items: Array<Maybe<Token>>;
  limit: Scalars['Int'];
  skip: Scalars['Int'];
  total: Scalars['Int'];
};

export type AppConfigCollection = {
  __typename?: 'AppConfigCollection';
  items: Array<Maybe<AppConfig>>;
  limit: Scalars['Int'];
  skip: Scalars['Int'];
  total: Scalars['Int'];
};

export type AppConfigCommonSwapCoinsCollection = {
  __typename?: 'AppConfigCommonSwapCoinsCollection';
  items: Array<Maybe<Token>>;
  limit: Scalars['Int'];
  skip: Scalars['Int'];
  total: Scalars['Int'];
};

export type AppConfigFarmingsCollection = {
  __typename?: 'AppConfigFarmingsCollection';
  items: Array<Maybe<Token>>;
  limit: Scalars['Int'];
  skip: Scalars['Int'];
  total: Scalars['Int'];
};

export type AppConfigFilter = {
  AND?: InputMaybe<Array<InputMaybe<AppConfigFilter>>>;
  OR?: InputMaybe<Array<InputMaybe<AppConfigFilter>>>;
  allSwapCoinsCollection_exists?: InputMaybe<Scalars['Boolean']>;
  commonSwapCoinsCollection_exists?: InputMaybe<Scalars['Boolean']>;
  contentfulMetadata?: InputMaybe<ContentfulMetadataFilter>;
  enableBlockIndicator?: InputMaybe<Scalars['Boolean']>;
  enableBlockIndicator_exists?: InputMaybe<Scalars['Boolean']>;
  enableBlockIndicator_not?: InputMaybe<Scalars['Boolean']>;
  enableCoFarmFeature?: InputMaybe<Scalars['Boolean']>;
  enableCoFarmFeature_exists?: InputMaybe<Scalars['Boolean']>;
  enableCoFarmFeature_not?: InputMaybe<Scalars['Boolean']>;
  enableFarmFeature?: InputMaybe<Scalars['Boolean']>;
  enableFarmFeature_exists?: InputMaybe<Scalars['Boolean']>;
  enableFarmFeature_not?: InputMaybe<Scalars['Boolean']>;
  enableLaunchPadFeature?: InputMaybe<Scalars['Boolean']>;
  enableLaunchPadFeature_exists?: InputMaybe<Scalars['Boolean']>;
  enableLaunchPadFeature_not?: InputMaybe<Scalars['Boolean']>;
  enableLendFeature?: InputMaybe<Scalars['Boolean']>;
  enableLendFeature_exists?: InputMaybe<Scalars['Boolean']>;
  enableLendFeature_not?: InputMaybe<Scalars['Boolean']>;
  enableLotteryFeature?: InputMaybe<Scalars['Boolean']>;
  enableLotteryFeature_exists?: InputMaybe<Scalars['Boolean']>;
  enableLotteryFeature_not?: InputMaybe<Scalars['Boolean']>;
  enableOrderBook?: InputMaybe<Scalars['Boolean']>;
  enableOrderBook_exists?: InputMaybe<Scalars['Boolean']>;
  enableOrderBook_not?: InputMaybe<Scalars['Boolean']>;
  enablePoolFeature?: InputMaybe<Scalars['Boolean']>;
  enablePoolFeature_exists?: InputMaybe<Scalars['Boolean']>;
  enablePoolFeature_not?: InputMaybe<Scalars['Boolean']>;
  enableStakeFeature?: InputMaybe<Scalars['Boolean']>;
  enableStakeFeature_exists?: InputMaybe<Scalars['Boolean']>;
  enableStakeFeature_not?: InputMaybe<Scalars['Boolean']>;
  enableSwapFeature?: InputMaybe<Scalars['Boolean']>;
  enableSwapFeature_exists?: InputMaybe<Scalars['Boolean']>;
  enableSwapFeature_not?: InputMaybe<Scalars['Boolean']>;
  enableWrapBridgeFeature?: InputMaybe<Scalars['Boolean']>;
  enableWrapBridgeFeature_exists?: InputMaybe<Scalars['Boolean']>;
  enableWrapBridgeFeature_not?: InputMaybe<Scalars['Boolean']>;
  env?: InputMaybe<Scalars['String']>;
  env_contains?: InputMaybe<Scalars['String']>;
  env_exists?: InputMaybe<Scalars['Boolean']>;
  env_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  env_not?: InputMaybe<Scalars['String']>;
  env_not_contains?: InputMaybe<Scalars['String']>;
  env_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  farmingsCollection_exists?: InputMaybe<Scalars['Boolean']>;
  poolsCollection_exists?: InputMaybe<Scalars['Boolean']>;
  stakingBannerCollection_exists?: InputMaybe<Scalars['Boolean']>;
  sys?: InputMaybe<SysFilter>;
  v1StakingCycleLimitBlockHeight?: InputMaybe<Scalars['Int']>;
  v1StakingCycleLimitBlockHeight_exists?: InputMaybe<Scalars['Boolean']>;
  v1StakingCycleLimitBlockHeight_gt?: InputMaybe<Scalars['Int']>;
  v1StakingCycleLimitBlockHeight_gte?: InputMaybe<Scalars['Int']>;
  v1StakingCycleLimitBlockHeight_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  v1StakingCycleLimitBlockHeight_lt?: InputMaybe<Scalars['Int']>;
  v1StakingCycleLimitBlockHeight_lte?: InputMaybe<Scalars['Int']>;
  v1StakingCycleLimitBlockHeight_not?: InputMaybe<Scalars['Int']>;
  v1StakingCycleLimitBlockHeight_not_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
};

export type AppConfigLinkingCollections = {
  __typename?: 'AppConfigLinkingCollections';
  entryCollection?: Maybe<EntryCollection>;
};


export type AppConfigLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
};

export enum AppConfigOrder {
  EnableBlockIndicatorAsc = 'enableBlockIndicator_ASC',
  EnableBlockIndicatorDesc = 'enableBlockIndicator_DESC',
  EnableCoFarmFeatureAsc = 'enableCoFarmFeature_ASC',
  EnableCoFarmFeatureDesc = 'enableCoFarmFeature_DESC',
  EnableFarmFeatureAsc = 'enableFarmFeature_ASC',
  EnableFarmFeatureDesc = 'enableFarmFeature_DESC',
  EnableLaunchPadFeatureAsc = 'enableLaunchPadFeature_ASC',
  EnableLaunchPadFeatureDesc = 'enableLaunchPadFeature_DESC',
  EnableLendFeatureAsc = 'enableLendFeature_ASC',
  EnableLendFeatureDesc = 'enableLendFeature_DESC',
  EnableLotteryFeatureAsc = 'enableLotteryFeature_ASC',
  EnableLotteryFeatureDesc = 'enableLotteryFeature_DESC',
  EnableOrderBookAsc = 'enableOrderBook_ASC',
  EnableOrderBookDesc = 'enableOrderBook_DESC',
  EnablePoolFeatureAsc = 'enablePoolFeature_ASC',
  EnablePoolFeatureDesc = 'enablePoolFeature_DESC',
  EnableStakeFeatureAsc = 'enableStakeFeature_ASC',
  EnableStakeFeatureDesc = 'enableStakeFeature_DESC',
  EnableSwapFeatureAsc = 'enableSwapFeature_ASC',
  EnableSwapFeatureDesc = 'enableSwapFeature_DESC',
  EnableWrapBridgeFeatureAsc = 'enableWrapBridgeFeature_ASC',
  EnableWrapBridgeFeatureDesc = 'enableWrapBridgeFeature_DESC',
  EnvAsc = 'env_ASC',
  EnvDesc = 'env_DESC',
  SysFirstPublishedAtAsc = 'sys_firstPublishedAt_ASC',
  SysFirstPublishedAtDesc = 'sys_firstPublishedAt_DESC',
  SysIdAsc = 'sys_id_ASC',
  SysIdDesc = 'sys_id_DESC',
  SysPublishedAtAsc = 'sys_publishedAt_ASC',
  SysPublishedAtDesc = 'sys_publishedAt_DESC',
  SysPublishedVersionAsc = 'sys_publishedVersion_ASC',
  SysPublishedVersionDesc = 'sys_publishedVersion_DESC',
  V1StakingCycleLimitBlockHeightAsc = 'v1StakingCycleLimitBlockHeight_ASC',
  V1StakingCycleLimitBlockHeightDesc = 'v1StakingCycleLimitBlockHeight_DESC'
}

export type AppConfigPoolsCollection = {
  __typename?: 'AppConfigPoolsCollection';
  items: Array<Maybe<Token>>;
  limit: Scalars['Int'];
  skip: Scalars['Int'];
  total: Scalars['Int'];
};

export type AppConfigStakingBannerCollection = {
  __typename?: 'AppConfigStakingBannerCollection';
  items: Array<Maybe<Banner>>;
  limit: Scalars['Int'];
  skip: Scalars['Int'];
  total: Scalars['Int'];
};

/** Represents a binary file in a space. An asset can be any file type. */
export type Asset = {
  __typename?: 'Asset';
  contentType?: Maybe<Scalars['String']>;
  contentfulMetadata: ContentfulMetadata;
  description?: Maybe<Scalars['String']>;
  fileName?: Maybe<Scalars['String']>;
  height?: Maybe<Scalars['Int']>;
  linkedFrom?: Maybe<AssetLinkingCollections>;
  size?: Maybe<Scalars['Int']>;
  sys: Sys;
  title?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  width?: Maybe<Scalars['Int']>;
};


/** Represents a binary file in a space. An asset can be any file type. */
export type AssetContentTypeArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** Represents a binary file in a space. An asset can be any file type. */
export type AssetDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** Represents a binary file in a space. An asset can be any file type. */
export type AssetFileNameArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** Represents a binary file in a space. An asset can be any file type. */
export type AssetHeightArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** Represents a binary file in a space. An asset can be any file type. */
export type AssetLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


/** Represents a binary file in a space. An asset can be any file type. */
export type AssetSizeArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** Represents a binary file in a space. An asset can be any file type. */
export type AssetTitleArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** Represents a binary file in a space. An asset can be any file type. */
export type AssetUrlArgs = {
  locale?: InputMaybe<Scalars['String']>;
  transform?: InputMaybe<ImageTransformOptions>;
};


/** Represents a binary file in a space. An asset can be any file type. */
export type AssetWidthArgs = {
  locale?: InputMaybe<Scalars['String']>;
};

export type AssetCollection = {
  __typename?: 'AssetCollection';
  items: Array<Maybe<Asset>>;
  limit: Scalars['Int'];
  skip: Scalars['Int'];
  total: Scalars['Int'];
};

export type AssetFilter = {
  AND?: InputMaybe<Array<InputMaybe<AssetFilter>>>;
  OR?: InputMaybe<Array<InputMaybe<AssetFilter>>>;
  contentType?: InputMaybe<Scalars['String']>;
  contentType_contains?: InputMaybe<Scalars['String']>;
  contentType_exists?: InputMaybe<Scalars['Boolean']>;
  contentType_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  contentType_not?: InputMaybe<Scalars['String']>;
  contentType_not_contains?: InputMaybe<Scalars['String']>;
  contentType_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  contentfulMetadata?: InputMaybe<ContentfulMetadataFilter>;
  description?: InputMaybe<Scalars['String']>;
  description_contains?: InputMaybe<Scalars['String']>;
  description_exists?: InputMaybe<Scalars['Boolean']>;
  description_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  description_not?: InputMaybe<Scalars['String']>;
  description_not_contains?: InputMaybe<Scalars['String']>;
  description_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fileName?: InputMaybe<Scalars['String']>;
  fileName_contains?: InputMaybe<Scalars['String']>;
  fileName_exists?: InputMaybe<Scalars['Boolean']>;
  fileName_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fileName_not?: InputMaybe<Scalars['String']>;
  fileName_not_contains?: InputMaybe<Scalars['String']>;
  fileName_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  height?: InputMaybe<Scalars['Int']>;
  height_exists?: InputMaybe<Scalars['Boolean']>;
  height_gt?: InputMaybe<Scalars['Int']>;
  height_gte?: InputMaybe<Scalars['Int']>;
  height_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  height_lt?: InputMaybe<Scalars['Int']>;
  height_lte?: InputMaybe<Scalars['Int']>;
  height_not?: InputMaybe<Scalars['Int']>;
  height_not_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  size?: InputMaybe<Scalars['Int']>;
  size_exists?: InputMaybe<Scalars['Boolean']>;
  size_gt?: InputMaybe<Scalars['Int']>;
  size_gte?: InputMaybe<Scalars['Int']>;
  size_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  size_lt?: InputMaybe<Scalars['Int']>;
  size_lte?: InputMaybe<Scalars['Int']>;
  size_not?: InputMaybe<Scalars['Int']>;
  size_not_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  sys?: InputMaybe<SysFilter>;
  title?: InputMaybe<Scalars['String']>;
  title_contains?: InputMaybe<Scalars['String']>;
  title_exists?: InputMaybe<Scalars['Boolean']>;
  title_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  title_not?: InputMaybe<Scalars['String']>;
  title_not_contains?: InputMaybe<Scalars['String']>;
  title_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  url?: InputMaybe<Scalars['String']>;
  url_contains?: InputMaybe<Scalars['String']>;
  url_exists?: InputMaybe<Scalars['Boolean']>;
  url_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  url_not?: InputMaybe<Scalars['String']>;
  url_not_contains?: InputMaybe<Scalars['String']>;
  url_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  width?: InputMaybe<Scalars['Int']>;
  width_exists?: InputMaybe<Scalars['Boolean']>;
  width_gt?: InputMaybe<Scalars['Int']>;
  width_gte?: InputMaybe<Scalars['Int']>;
  width_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  width_lt?: InputMaybe<Scalars['Int']>;
  width_lte?: InputMaybe<Scalars['Int']>;
  width_not?: InputMaybe<Scalars['Int']>;
  width_not_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
};

export type AssetLinkingCollections = {
  __typename?: 'AssetLinkingCollections';
  bannerCollection?: Maybe<BannerCollection>;
  entryCollection?: Maybe<EntryCollection>;
  idoCollection?: Maybe<IdoCollection>;
  tokenCollection?: Maybe<TokenCollection>;
};


export type AssetLinkingCollectionsBannerCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
};


export type AssetLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
};


export type AssetLinkingCollectionsIdoCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
};


export type AssetLinkingCollectionsTokenCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
};

export enum AssetOrder {
  ContentTypeAsc = 'contentType_ASC',
  ContentTypeDesc = 'contentType_DESC',
  FileNameAsc = 'fileName_ASC',
  FileNameDesc = 'fileName_DESC',
  HeightAsc = 'height_ASC',
  HeightDesc = 'height_DESC',
  SizeAsc = 'size_ASC',
  SizeDesc = 'size_DESC',
  SysFirstPublishedAtAsc = 'sys_firstPublishedAt_ASC',
  SysFirstPublishedAtDesc = 'sys_firstPublishedAt_DESC',
  SysIdAsc = 'sys_id_ASC',
  SysIdDesc = 'sys_id_DESC',
  SysPublishedAtAsc = 'sys_publishedAt_ASC',
  SysPublishedAtDesc = 'sys_publishedAt_DESC',
  SysPublishedVersionAsc = 'sys_publishedVersion_ASC',
  SysPublishedVersionDesc = 'sys_publishedVersion_DESC',
  UrlAsc = 'url_ASC',
  UrlDesc = 'url_DESC',
  WidthAsc = 'width_ASC',
  WidthDesc = 'width_DESC'
}

/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/banner) */
export type Banner = Entry & {
  __typename?: 'Banner';
  contentfulMetadata: ContentfulMetadata;
  image?: Maybe<Asset>;
  link?: Maybe<Scalars['String']>;
  linkedFrom?: Maybe<BannerLinkingCollections>;
  sys: Sys;
  title?: Maybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/banner) */
export type BannerImageArgs = {
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/banner) */
export type BannerLinkArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/banner) */
export type BannerLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/banner) */
export type BannerTitleArgs = {
  locale?: InputMaybe<Scalars['String']>;
};

export type BannerCollection = {
  __typename?: 'BannerCollection';
  items: Array<Maybe<Banner>>;
  limit: Scalars['Int'];
  skip: Scalars['Int'];
  total: Scalars['Int'];
};

export type BannerFilter = {
  AND?: InputMaybe<Array<InputMaybe<BannerFilter>>>;
  OR?: InputMaybe<Array<InputMaybe<BannerFilter>>>;
  contentfulMetadata?: InputMaybe<ContentfulMetadataFilter>;
  image_exists?: InputMaybe<Scalars['Boolean']>;
  link?: InputMaybe<Scalars['String']>;
  link_contains?: InputMaybe<Scalars['String']>;
  link_exists?: InputMaybe<Scalars['Boolean']>;
  link_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  link_not?: InputMaybe<Scalars['String']>;
  link_not_contains?: InputMaybe<Scalars['String']>;
  link_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  sys?: InputMaybe<SysFilter>;
  title?: InputMaybe<Scalars['String']>;
  title_contains?: InputMaybe<Scalars['String']>;
  title_exists?: InputMaybe<Scalars['Boolean']>;
  title_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  title_not?: InputMaybe<Scalars['String']>;
  title_not_contains?: InputMaybe<Scalars['String']>;
  title_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type BannerLinkingCollections = {
  __typename?: 'BannerLinkingCollections';
  appConfigCollection?: Maybe<AppConfigCollection>;
  entryCollection?: Maybe<EntryCollection>;
};


export type BannerLinkingCollectionsAppConfigCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
};


export type BannerLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
};

export enum BannerOrder {
  LinkAsc = 'link_ASC',
  LinkDesc = 'link_DESC',
  SysFirstPublishedAtAsc = 'sys_firstPublishedAt_ASC',
  SysFirstPublishedAtDesc = 'sys_firstPublishedAt_DESC',
  SysIdAsc = 'sys_id_ASC',
  SysIdDesc = 'sys_id_DESC',
  SysPublishedAtAsc = 'sys_publishedAt_ASC',
  SysPublishedAtDesc = 'sys_publishedAt_DESC',
  SysPublishedVersionAsc = 'sys_publishedVersion_ASC',
  SysPublishedVersionDesc = 'sys_publishedVersion_DESC',
  TitleAsc = 'title_ASC',
  TitleDesc = 'title_DESC'
}

/** Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'. */
export type BooleanComparisonExp = {
  _eq?: InputMaybe<Scalars['Boolean']>;
  _gt?: InputMaybe<Scalars['Boolean']>;
  _gte?: InputMaybe<Scalars['Boolean']>;
  _in?: InputMaybe<Array<Scalars['Boolean']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['Boolean']>;
  _lte?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Scalars['Boolean']>;
  _nin?: InputMaybe<Array<Scalars['Boolean']>>;
};

export type CrpSimulationInput = {
  end_date: Scalars['String'];
  start_date: Scalars['String'];
};

export type CrpSimulationOutput = {
  __typename?: 'CRPSimulationOutput';
  config: Scalars['jsonb'];
  data: Scalars['jsonb'];
};

export type ContentfulMetadata = {
  __typename?: 'ContentfulMetadata';
  tags: Array<Maybe<ContentfulTag>>;
};

export type ContentfulMetadataFilter = {
  tags?: InputMaybe<ContentfulMetadataTagsFilter>;
  tags_exists?: InputMaybe<Scalars['Boolean']>;
};

export type ContentfulMetadataTagsFilter = {
  id_contains_all?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  id_contains_none?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  id_contains_some?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

/**
 * Represents a tag entity for finding and organizing content easily.
 *     Find out more here: https://www.contentful.com/developers/docs/references/content-delivery-api/#/reference/content-tags
 */
export type ContentfulTag = {
  __typename?: 'ContentfulTag';
  id?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

export type Entry = {
  contentfulMetadata: ContentfulMetadata;
  sys: Sys;
};

export type EntryCollection = {
  __typename?: 'EntryCollection';
  items: Array<Maybe<Entry>>;
  limit: Scalars['Int'];
  skip: Scalars['Int'];
  total: Scalars['Int'];
};

export type EntryFilter = {
  AND?: InputMaybe<Array<InputMaybe<EntryFilter>>>;
  OR?: InputMaybe<Array<InputMaybe<EntryFilter>>>;
  contentfulMetadata?: InputMaybe<ContentfulMetadataFilter>;
  sys?: InputMaybe<SysFilter>;
};

export enum EntryOrder {
  SysFirstPublishedAtAsc = 'sys_firstPublishedAt_ASC',
  SysFirstPublishedAtDesc = 'sys_firstPublishedAt_DESC',
  SysIdAsc = 'sys_id_ASC',
  SysIdDesc = 'sys_id_DESC',
  SysPublishedAtAsc = 'sys_publishedAt_ASC',
  SysPublishedAtDesc = 'sys_publishedAt_DESC',
  SysPublishedVersionAsc = 'sys_publishedVersion_ASC',
  SysPublishedVersionDesc = 'sys_publishedVersion_DESC'
}

/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type Ido = Entry & {
  __typename?: 'Ido';
  aPowerRules?: Maybe<Scalars['JSON']>;
  content?: Maybe<Scalars['String']>;
  contentfulMetadata: ContentfulMetadata;
  discordLink?: Maybe<Scalars['String']>;
  environment?: Maybe<Array<Maybe<Scalars['String']>>>;
  estimateIdoAmount?: Maybe<Scalars['Int']>;
  estimateValidationEnd?: Maybe<Scalars['DateTime']>;
  estimateValidationStart?: Maybe<Scalars['DateTime']>;
  estimatedPriceTokenCount?: Maybe<Scalars['Float']>;
  featuredImage?: Maybe<Asset>;
  featuredOnHomePage?: Maybe<Scalars['Boolean']>;
  finishedAllTimeHigh?: Maybe<Scalars['Float']>;
  finishedDate?: Maybe<Scalars['DateTime']>;
  finishedFillRate?: Maybe<Scalars['Float']>;
  finishedParticipateWallets?: Maybe<Scalars['Int']>;
  galleryCollection?: Maybe<AssetCollection>;
  hotBadge?: Maybe<Scalars['Boolean']>;
  idoId?: Maybe<Scalars['Int']>;
  idoIdDev?: Maybe<Scalars['Int']>;
  idoToken?: Maybe<Token>;
  idoTokenPriceInPriceToken?: Maybe<Scalars['Float']>;
  linkedFrom?: Maybe<IdoLinkingCollections>;
  maxAllowTicket?: Maybe<Scalars['Int']>;
  mediumLink?: Maybe<Scalars['String']>;
  priceToken?: Maybe<Token>;
  sortedBy?: Maybe<Scalars['DateTime']>;
  subtitle?: Maybe<Scalars['String']>;
  sys: Sys;
  title?: Maybe<Scalars['String']>;
  tokenImage?: Maybe<Asset>;
  tosLink?: Maybe<Scalars['String']>;
  twitterLink?: Maybe<Scalars['String']>;
  urlSlug?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoAPowerRulesArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoContentArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoDiscordLinkArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoEnvironmentArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoEstimateIdoAmountArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoEstimateValidationEndArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoEstimateValidationStartArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoEstimatedPriceTokenCountArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoFeaturedImageArgs = {
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoFeaturedOnHomePageArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoFinishedAllTimeHighArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoFinishedDateArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoFinishedFillRateArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoFinishedParticipateWalletsArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoGalleryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoHotBadgeArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoIdoIdArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoIdoIdDevArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoIdoTokenArgs = {
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoIdoTokenPriceInPriceTokenArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoMaxAllowTicketArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoMediumLinkArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoPriceTokenArgs = {
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoSortedByArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoTitleArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoTokenImageArgs = {
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoTosLinkArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoTwitterLinkArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoUrlSlugArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/ido) */
export type IdoWebsiteArgs = {
  locale?: InputMaybe<Scalars['String']>;
};

export type IdoCollection = {
  __typename?: 'IdoCollection';
  items: Array<Maybe<Ido>>;
  limit: Scalars['Int'];
  skip: Scalars['Int'];
  total: Scalars['Int'];
};

export type IdoFilter = {
  AND?: InputMaybe<Array<InputMaybe<IdoFilter>>>;
  OR?: InputMaybe<Array<InputMaybe<IdoFilter>>>;
  aPowerRules_exists?: InputMaybe<Scalars['Boolean']>;
  content?: InputMaybe<Scalars['String']>;
  content_contains?: InputMaybe<Scalars['String']>;
  content_exists?: InputMaybe<Scalars['Boolean']>;
  content_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  content_not?: InputMaybe<Scalars['String']>;
  content_not_contains?: InputMaybe<Scalars['String']>;
  content_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  contentfulMetadata?: InputMaybe<ContentfulMetadataFilter>;
  discordLink?: InputMaybe<Scalars['String']>;
  discordLink_contains?: InputMaybe<Scalars['String']>;
  discordLink_exists?: InputMaybe<Scalars['Boolean']>;
  discordLink_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  discordLink_not?: InputMaybe<Scalars['String']>;
  discordLink_not_contains?: InputMaybe<Scalars['String']>;
  discordLink_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  environment_contains_all?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  environment_contains_none?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  environment_contains_some?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  environment_exists?: InputMaybe<Scalars['Boolean']>;
  estimateIdoAmount?: InputMaybe<Scalars['Int']>;
  estimateIdoAmount_exists?: InputMaybe<Scalars['Boolean']>;
  estimateIdoAmount_gt?: InputMaybe<Scalars['Int']>;
  estimateIdoAmount_gte?: InputMaybe<Scalars['Int']>;
  estimateIdoAmount_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  estimateIdoAmount_lt?: InputMaybe<Scalars['Int']>;
  estimateIdoAmount_lte?: InputMaybe<Scalars['Int']>;
  estimateIdoAmount_not?: InputMaybe<Scalars['Int']>;
  estimateIdoAmount_not_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  estimateValidationEnd?: InputMaybe<Scalars['DateTime']>;
  estimateValidationEnd_exists?: InputMaybe<Scalars['Boolean']>;
  estimateValidationEnd_gt?: InputMaybe<Scalars['DateTime']>;
  estimateValidationEnd_gte?: InputMaybe<Scalars['DateTime']>;
  estimateValidationEnd_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  estimateValidationEnd_lt?: InputMaybe<Scalars['DateTime']>;
  estimateValidationEnd_lte?: InputMaybe<Scalars['DateTime']>;
  estimateValidationEnd_not?: InputMaybe<Scalars['DateTime']>;
  estimateValidationEnd_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  estimateValidationStart?: InputMaybe<Scalars['DateTime']>;
  estimateValidationStart_exists?: InputMaybe<Scalars['Boolean']>;
  estimateValidationStart_gt?: InputMaybe<Scalars['DateTime']>;
  estimateValidationStart_gte?: InputMaybe<Scalars['DateTime']>;
  estimateValidationStart_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  estimateValidationStart_lt?: InputMaybe<Scalars['DateTime']>;
  estimateValidationStart_lte?: InputMaybe<Scalars['DateTime']>;
  estimateValidationStart_not?: InputMaybe<Scalars['DateTime']>;
  estimateValidationStart_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  estimatedPriceTokenCount?: InputMaybe<Scalars['Float']>;
  estimatedPriceTokenCount_exists?: InputMaybe<Scalars['Boolean']>;
  estimatedPriceTokenCount_gt?: InputMaybe<Scalars['Float']>;
  estimatedPriceTokenCount_gte?: InputMaybe<Scalars['Float']>;
  estimatedPriceTokenCount_in?: InputMaybe<Array<InputMaybe<Scalars['Float']>>>;
  estimatedPriceTokenCount_lt?: InputMaybe<Scalars['Float']>;
  estimatedPriceTokenCount_lte?: InputMaybe<Scalars['Float']>;
  estimatedPriceTokenCount_not?: InputMaybe<Scalars['Float']>;
  estimatedPriceTokenCount_not_in?: InputMaybe<Array<InputMaybe<Scalars['Float']>>>;
  featuredImage_exists?: InputMaybe<Scalars['Boolean']>;
  featuredOnHomePage?: InputMaybe<Scalars['Boolean']>;
  featuredOnHomePage_exists?: InputMaybe<Scalars['Boolean']>;
  featuredOnHomePage_not?: InputMaybe<Scalars['Boolean']>;
  finishedAllTimeHigh?: InputMaybe<Scalars['Float']>;
  finishedAllTimeHigh_exists?: InputMaybe<Scalars['Boolean']>;
  finishedAllTimeHigh_gt?: InputMaybe<Scalars['Float']>;
  finishedAllTimeHigh_gte?: InputMaybe<Scalars['Float']>;
  finishedAllTimeHigh_in?: InputMaybe<Array<InputMaybe<Scalars['Float']>>>;
  finishedAllTimeHigh_lt?: InputMaybe<Scalars['Float']>;
  finishedAllTimeHigh_lte?: InputMaybe<Scalars['Float']>;
  finishedAllTimeHigh_not?: InputMaybe<Scalars['Float']>;
  finishedAllTimeHigh_not_in?: InputMaybe<Array<InputMaybe<Scalars['Float']>>>;
  finishedDate?: InputMaybe<Scalars['DateTime']>;
  finishedDate_exists?: InputMaybe<Scalars['Boolean']>;
  finishedDate_gt?: InputMaybe<Scalars['DateTime']>;
  finishedDate_gte?: InputMaybe<Scalars['DateTime']>;
  finishedDate_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  finishedDate_lt?: InputMaybe<Scalars['DateTime']>;
  finishedDate_lte?: InputMaybe<Scalars['DateTime']>;
  finishedDate_not?: InputMaybe<Scalars['DateTime']>;
  finishedDate_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  finishedFillRate?: InputMaybe<Scalars['Float']>;
  finishedFillRate_exists?: InputMaybe<Scalars['Boolean']>;
  finishedFillRate_gt?: InputMaybe<Scalars['Float']>;
  finishedFillRate_gte?: InputMaybe<Scalars['Float']>;
  finishedFillRate_in?: InputMaybe<Array<InputMaybe<Scalars['Float']>>>;
  finishedFillRate_lt?: InputMaybe<Scalars['Float']>;
  finishedFillRate_lte?: InputMaybe<Scalars['Float']>;
  finishedFillRate_not?: InputMaybe<Scalars['Float']>;
  finishedFillRate_not_in?: InputMaybe<Array<InputMaybe<Scalars['Float']>>>;
  finishedParticipateWallets?: InputMaybe<Scalars['Int']>;
  finishedParticipateWallets_exists?: InputMaybe<Scalars['Boolean']>;
  finishedParticipateWallets_gt?: InputMaybe<Scalars['Int']>;
  finishedParticipateWallets_gte?: InputMaybe<Scalars['Int']>;
  finishedParticipateWallets_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  finishedParticipateWallets_lt?: InputMaybe<Scalars['Int']>;
  finishedParticipateWallets_lte?: InputMaybe<Scalars['Int']>;
  finishedParticipateWallets_not?: InputMaybe<Scalars['Int']>;
  finishedParticipateWallets_not_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  galleryCollection_exists?: InputMaybe<Scalars['Boolean']>;
  hotBadge?: InputMaybe<Scalars['Boolean']>;
  hotBadge_exists?: InputMaybe<Scalars['Boolean']>;
  hotBadge_not?: InputMaybe<Scalars['Boolean']>;
  idoId?: InputMaybe<Scalars['Int']>;
  idoIdDev?: InputMaybe<Scalars['Int']>;
  idoIdDev_exists?: InputMaybe<Scalars['Boolean']>;
  idoIdDev_gt?: InputMaybe<Scalars['Int']>;
  idoIdDev_gte?: InputMaybe<Scalars['Int']>;
  idoIdDev_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  idoIdDev_lt?: InputMaybe<Scalars['Int']>;
  idoIdDev_lte?: InputMaybe<Scalars['Int']>;
  idoIdDev_not?: InputMaybe<Scalars['Int']>;
  idoIdDev_not_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  idoId_exists?: InputMaybe<Scalars['Boolean']>;
  idoId_gt?: InputMaybe<Scalars['Int']>;
  idoId_gte?: InputMaybe<Scalars['Int']>;
  idoId_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  idoId_lt?: InputMaybe<Scalars['Int']>;
  idoId_lte?: InputMaybe<Scalars['Int']>;
  idoId_not?: InputMaybe<Scalars['Int']>;
  idoId_not_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  idoToken?: InputMaybe<CfTokenNestedFilter>;
  idoTokenPriceInPriceToken?: InputMaybe<Scalars['Float']>;
  idoTokenPriceInPriceToken_exists?: InputMaybe<Scalars['Boolean']>;
  idoTokenPriceInPriceToken_gt?: InputMaybe<Scalars['Float']>;
  idoTokenPriceInPriceToken_gte?: InputMaybe<Scalars['Float']>;
  idoTokenPriceInPriceToken_in?: InputMaybe<Array<InputMaybe<Scalars['Float']>>>;
  idoTokenPriceInPriceToken_lt?: InputMaybe<Scalars['Float']>;
  idoTokenPriceInPriceToken_lte?: InputMaybe<Scalars['Float']>;
  idoTokenPriceInPriceToken_not?: InputMaybe<Scalars['Float']>;
  idoTokenPriceInPriceToken_not_in?: InputMaybe<Array<InputMaybe<Scalars['Float']>>>;
  idoToken_exists?: InputMaybe<Scalars['Boolean']>;
  maxAllowTicket?: InputMaybe<Scalars['Int']>;
  maxAllowTicket_exists?: InputMaybe<Scalars['Boolean']>;
  maxAllowTicket_gt?: InputMaybe<Scalars['Int']>;
  maxAllowTicket_gte?: InputMaybe<Scalars['Int']>;
  maxAllowTicket_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  maxAllowTicket_lt?: InputMaybe<Scalars['Int']>;
  maxAllowTicket_lte?: InputMaybe<Scalars['Int']>;
  maxAllowTicket_not?: InputMaybe<Scalars['Int']>;
  maxAllowTicket_not_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  mediumLink?: InputMaybe<Scalars['String']>;
  mediumLink_contains?: InputMaybe<Scalars['String']>;
  mediumLink_exists?: InputMaybe<Scalars['Boolean']>;
  mediumLink_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  mediumLink_not?: InputMaybe<Scalars['String']>;
  mediumLink_not_contains?: InputMaybe<Scalars['String']>;
  mediumLink_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  priceToken?: InputMaybe<CfTokenNestedFilter>;
  priceToken_exists?: InputMaybe<Scalars['Boolean']>;
  sortedBy?: InputMaybe<Scalars['DateTime']>;
  sortedBy_exists?: InputMaybe<Scalars['Boolean']>;
  sortedBy_gt?: InputMaybe<Scalars['DateTime']>;
  sortedBy_gte?: InputMaybe<Scalars['DateTime']>;
  sortedBy_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  sortedBy_lt?: InputMaybe<Scalars['DateTime']>;
  sortedBy_lte?: InputMaybe<Scalars['DateTime']>;
  sortedBy_not?: InputMaybe<Scalars['DateTime']>;
  sortedBy_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  subtitle?: InputMaybe<Scalars['String']>;
  subtitle_contains?: InputMaybe<Scalars['String']>;
  subtitle_exists?: InputMaybe<Scalars['Boolean']>;
  subtitle_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  subtitle_not?: InputMaybe<Scalars['String']>;
  subtitle_not_contains?: InputMaybe<Scalars['String']>;
  subtitle_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  sys?: InputMaybe<SysFilter>;
  title?: InputMaybe<Scalars['String']>;
  title_contains?: InputMaybe<Scalars['String']>;
  title_exists?: InputMaybe<Scalars['Boolean']>;
  title_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  title_not?: InputMaybe<Scalars['String']>;
  title_not_contains?: InputMaybe<Scalars['String']>;
  title_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  tokenImage_exists?: InputMaybe<Scalars['Boolean']>;
  tosLink?: InputMaybe<Scalars['String']>;
  tosLink_contains?: InputMaybe<Scalars['String']>;
  tosLink_exists?: InputMaybe<Scalars['Boolean']>;
  tosLink_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  tosLink_not?: InputMaybe<Scalars['String']>;
  tosLink_not_contains?: InputMaybe<Scalars['String']>;
  tosLink_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  twitterLink?: InputMaybe<Scalars['String']>;
  twitterLink_contains?: InputMaybe<Scalars['String']>;
  twitterLink_exists?: InputMaybe<Scalars['Boolean']>;
  twitterLink_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  twitterLink_not?: InputMaybe<Scalars['String']>;
  twitterLink_not_contains?: InputMaybe<Scalars['String']>;
  twitterLink_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  urlSlug?: InputMaybe<Scalars['String']>;
  urlSlug_contains?: InputMaybe<Scalars['String']>;
  urlSlug_exists?: InputMaybe<Scalars['Boolean']>;
  urlSlug_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  urlSlug_not?: InputMaybe<Scalars['String']>;
  urlSlug_not_contains?: InputMaybe<Scalars['String']>;
  urlSlug_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  website?: InputMaybe<Scalars['String']>;
  website_contains?: InputMaybe<Scalars['String']>;
  website_exists?: InputMaybe<Scalars['Boolean']>;
  website_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  website_not?: InputMaybe<Scalars['String']>;
  website_not_contains?: InputMaybe<Scalars['String']>;
  website_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type IdoLinkingCollections = {
  __typename?: 'IdoLinkingCollections';
  entryCollection?: Maybe<EntryCollection>;
};


export type IdoLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
};

export enum IdoOrder {
  DiscordLinkAsc = 'discordLink_ASC',
  DiscordLinkDesc = 'discordLink_DESC',
  EstimateIdoAmountAsc = 'estimateIdoAmount_ASC',
  EstimateIdoAmountDesc = 'estimateIdoAmount_DESC',
  EstimateValidationEndAsc = 'estimateValidationEnd_ASC',
  EstimateValidationEndDesc = 'estimateValidationEnd_DESC',
  EstimateValidationStartAsc = 'estimateValidationStart_ASC',
  EstimateValidationStartDesc = 'estimateValidationStart_DESC',
  EstimatedPriceTokenCountAsc = 'estimatedPriceTokenCount_ASC',
  EstimatedPriceTokenCountDesc = 'estimatedPriceTokenCount_DESC',
  FeaturedOnHomePageAsc = 'featuredOnHomePage_ASC',
  FeaturedOnHomePageDesc = 'featuredOnHomePage_DESC',
  FinishedAllTimeHighAsc = 'finishedAllTimeHigh_ASC',
  FinishedAllTimeHighDesc = 'finishedAllTimeHigh_DESC',
  FinishedDateAsc = 'finishedDate_ASC',
  FinishedDateDesc = 'finishedDate_DESC',
  FinishedFillRateAsc = 'finishedFillRate_ASC',
  FinishedFillRateDesc = 'finishedFillRate_DESC',
  FinishedParticipateWalletsAsc = 'finishedParticipateWallets_ASC',
  FinishedParticipateWalletsDesc = 'finishedParticipateWallets_DESC',
  HotBadgeAsc = 'hotBadge_ASC',
  HotBadgeDesc = 'hotBadge_DESC',
  IdoIdDevAsc = 'idoIdDev_ASC',
  IdoIdDevDesc = 'idoIdDev_DESC',
  IdoIdAsc = 'idoId_ASC',
  IdoIdDesc = 'idoId_DESC',
  IdoTokenPriceInPriceTokenAsc = 'idoTokenPriceInPriceToken_ASC',
  IdoTokenPriceInPriceTokenDesc = 'idoTokenPriceInPriceToken_DESC',
  MaxAllowTicketAsc = 'maxAllowTicket_ASC',
  MaxAllowTicketDesc = 'maxAllowTicket_DESC',
  MediumLinkAsc = 'mediumLink_ASC',
  MediumLinkDesc = 'mediumLink_DESC',
  SortedByAsc = 'sortedBy_ASC',
  SortedByDesc = 'sortedBy_DESC',
  SubtitleAsc = 'subtitle_ASC',
  SubtitleDesc = 'subtitle_DESC',
  SysFirstPublishedAtAsc = 'sys_firstPublishedAt_ASC',
  SysFirstPublishedAtDesc = 'sys_firstPublishedAt_DESC',
  SysIdAsc = 'sys_id_ASC',
  SysIdDesc = 'sys_id_DESC',
  SysPublishedAtAsc = 'sys_publishedAt_ASC',
  SysPublishedAtDesc = 'sys_publishedAt_DESC',
  SysPublishedVersionAsc = 'sys_publishedVersion_ASC',
  SysPublishedVersionDesc = 'sys_publishedVersion_DESC',
  TitleAsc = 'title_ASC',
  TitleDesc = 'title_DESC',
  TosLinkAsc = 'tosLink_ASC',
  TosLinkDesc = 'tosLink_DESC',
  TwitterLinkAsc = 'twitterLink_ASC',
  TwitterLinkDesc = 'twitterLink_DESC',
  UrlSlugAsc = 'urlSlug_ASC',
  UrlSlugDesc = 'urlSlug_DESC',
  WebsiteAsc = 'website_ASC',
  WebsiteDesc = 'website_DESC'
}

export enum ImageFormat {
  Avif = 'AVIF',
  /** JPG image format. */
  Jpg = 'JPG',
  /**
   * Progressive JPG format stores multiple passes of an image in progressively higher detail.
   *         When a progressive image is loading, the viewer will first see a lower quality pixelated version which
   *         will gradually improve in detail, until the image is fully downloaded. This is to display an image as
   *         early as possible to make the layout look as designed.
   */
  JpgProgressive = 'JPG_PROGRESSIVE',
  /** PNG image format */
  Png = 'PNG',
  /**
   * 8-bit PNG images support up to 256 colors and weigh less than the standard 24-bit PNG equivalent.
   *         The 8-bit PNG format is mostly used for simple images, such as icons or logos.
   */
  Png8 = 'PNG8',
  /** WebP image format. */
  Webp = 'WEBP'
}

export enum ImageResizeFocus {
  /** Focus the resizing on the bottom. */
  Bottom = 'BOTTOM',
  /** Focus the resizing on the bottom left. */
  BottomLeft = 'BOTTOM_LEFT',
  /** Focus the resizing on the bottom right. */
  BottomRight = 'BOTTOM_RIGHT',
  /** Focus the resizing on the center. */
  Center = 'CENTER',
  /** Focus the resizing on the largest face. */
  Face = 'FACE',
  /** Focus the resizing on the area containing all the faces. */
  Faces = 'FACES',
  /** Focus the resizing on the left. */
  Left = 'LEFT',
  /** Focus the resizing on the right. */
  Right = 'RIGHT',
  /** Focus the resizing on the top. */
  Top = 'TOP',
  /** Focus the resizing on the top left. */
  TopLeft = 'TOP_LEFT',
  /** Focus the resizing on the top right. */
  TopRight = 'TOP_RIGHT'
}

export enum ImageResizeStrategy {
  /** Crops a part of the original image to fit into the specified dimensions. */
  Crop = 'CROP',
  /** Resizes the image to the specified dimensions, cropping the image if needed. */
  Fill = 'FILL',
  /** Resizes the image to fit into the specified dimensions. */
  Fit = 'FIT',
  /**
   * Resizes the image to the specified dimensions, padding the image if needed.
   *         Uses desired background color as padding color.
   */
  Pad = 'PAD',
  /** Resizes the image to the specified dimensions, changing the original aspect ratio if needed. */
  Scale = 'SCALE',
  /** Creates a thumbnail from the image. */
  Thumb = 'THUMB'
}

export type ImageTransformOptions = {
  /**
   * Desired background color, used with corner radius or `PAD` resize strategy.
   *         Defaults to transparent (for `PNG`, `PNG8` and `WEBP`) or white (for `JPG` and `JPG_PROGRESSIVE`).
   */
  backgroundColor?: InputMaybe<Scalars['HexColor']>;
  /**
   * Desired corner radius in pixels.
   *         Results in an image with rounded corners (pass `-1` for a full circle/ellipse).
   *         Defaults to `0`. Uses desired background color as padding color,
   *         unless the format is `JPG` or `JPG_PROGRESSIVE` and resize strategy is `PAD`, then defaults to white.
   */
  cornerRadius?: InputMaybe<Scalars['Int']>;
  /** Desired image format. Defaults to the original image format. */
  format?: InputMaybe<ImageFormat>;
  /** Desired height in pixels. Defaults to the original image height. */
  height?: InputMaybe<Scalars['Dimension']>;
  /**
   * Desired quality of the image in percents.
   *         Used for `PNG8`, `JPG`, `JPG_PROGRESSIVE` and `WEBP` formats.
   */
  quality?: InputMaybe<Scalars['Quality']>;
  /** Desired resize focus area. Defaults to `CENTER`. */
  resizeFocus?: InputMaybe<ImageResizeFocus>;
  /** Desired resize strategy. Defaults to `FIT`. */
  resizeStrategy?: InputMaybe<ImageResizeStrategy>;
  /** Desired width in pixels. Defaults to the original image width. */
  width?: InputMaybe<Scalars['Dimension']>;
};

/** Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'. */
export type IntComparisonExp = {
  _eq?: InputMaybe<Scalars['Int']>;
  _gt?: InputMaybe<Scalars['Int']>;
  _gte?: InputMaybe<Scalars['Int']>;
  _in?: InputMaybe<Array<Scalars['Int']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['Int']>;
  _lte?: InputMaybe<Scalars['Int']>;
  _neq?: InputMaybe<Scalars['Int']>;
  _nin?: InputMaybe<Array<Scalars['Int']>>;
};

/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/lockdrop) */
export type Lockdrop = Entry & {
  __typename?: 'Lockdrop';
  contentfulMetadata: ContentfulMetadata;
  description?: Maybe<Scalars['String']>;
  details?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['DateTime']>;
  linkedFrom?: Maybe<LockdropLinkingCollections>;
  name?: Maybe<Scalars['String']>;
  rewardTokensCollection?: Maybe<LockdropRewardTokensCollection>;
  startDate?: Maybe<Scalars['DateTime']>;
  sys: Sys;
  title?: Maybe<Scalars['String']>;
  uncoverEndDate?: Maybe<Scalars['Boolean']>;
  uncoverSnapshot1?: Maybe<Scalars['Boolean']>;
  uncoverSnapshot2?: Maybe<Scalars['Boolean']>;
  uncoverSnapshot3?: Maybe<Scalars['Boolean']>;
  urlSlug?: Maybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/lockdrop) */
export type LockdropDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/lockdrop) */
export type LockdropDetailsArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/lockdrop) */
export type LockdropEndDateArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/lockdrop) */
export type LockdropLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/lockdrop) */
export type LockdropNameArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/lockdrop) */
export type LockdropRewardTokensCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/lockdrop) */
export type LockdropStartDateArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/lockdrop) */
export type LockdropTitleArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/lockdrop) */
export type LockdropUncoverEndDateArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/lockdrop) */
export type LockdropUncoverSnapshot1Args = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/lockdrop) */
export type LockdropUncoverSnapshot2Args = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/lockdrop) */
export type LockdropUncoverSnapshot3Args = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/lockdrop) */
export type LockdropUrlSlugArgs = {
  locale?: InputMaybe<Scalars['String']>;
};

export type LockdropCollection = {
  __typename?: 'LockdropCollection';
  items: Array<Maybe<Lockdrop>>;
  limit: Scalars['Int'];
  skip: Scalars['Int'];
  total: Scalars['Int'];
};

export type LockdropFilter = {
  AND?: InputMaybe<Array<InputMaybe<LockdropFilter>>>;
  OR?: InputMaybe<Array<InputMaybe<LockdropFilter>>>;
  contentfulMetadata?: InputMaybe<ContentfulMetadataFilter>;
  description?: InputMaybe<Scalars['String']>;
  description_contains?: InputMaybe<Scalars['String']>;
  description_exists?: InputMaybe<Scalars['Boolean']>;
  description_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  description_not?: InputMaybe<Scalars['String']>;
  description_not_contains?: InputMaybe<Scalars['String']>;
  description_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  details?: InputMaybe<Scalars['String']>;
  details_contains?: InputMaybe<Scalars['String']>;
  details_exists?: InputMaybe<Scalars['Boolean']>;
  details_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  details_not?: InputMaybe<Scalars['String']>;
  details_not_contains?: InputMaybe<Scalars['String']>;
  details_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  endDate_exists?: InputMaybe<Scalars['Boolean']>;
  endDate_gt?: InputMaybe<Scalars['DateTime']>;
  endDate_gte?: InputMaybe<Scalars['DateTime']>;
  endDate_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  endDate_lt?: InputMaybe<Scalars['DateTime']>;
  endDate_lte?: InputMaybe<Scalars['DateTime']>;
  endDate_not?: InputMaybe<Scalars['DateTime']>;
  endDate_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_exists?: InputMaybe<Scalars['Boolean']>;
  name_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  rewardTokensCollection_exists?: InputMaybe<Scalars['Boolean']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  startDate_exists?: InputMaybe<Scalars['Boolean']>;
  startDate_gt?: InputMaybe<Scalars['DateTime']>;
  startDate_gte?: InputMaybe<Scalars['DateTime']>;
  startDate_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  startDate_lt?: InputMaybe<Scalars['DateTime']>;
  startDate_lte?: InputMaybe<Scalars['DateTime']>;
  startDate_not?: InputMaybe<Scalars['DateTime']>;
  startDate_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  sys?: InputMaybe<SysFilter>;
  title?: InputMaybe<Scalars['String']>;
  title_contains?: InputMaybe<Scalars['String']>;
  title_exists?: InputMaybe<Scalars['Boolean']>;
  title_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  title_not?: InputMaybe<Scalars['String']>;
  title_not_contains?: InputMaybe<Scalars['String']>;
  title_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  uncoverEndDate?: InputMaybe<Scalars['Boolean']>;
  uncoverEndDate_exists?: InputMaybe<Scalars['Boolean']>;
  uncoverEndDate_not?: InputMaybe<Scalars['Boolean']>;
  uncoverSnapshot1?: InputMaybe<Scalars['Boolean']>;
  uncoverSnapshot1_exists?: InputMaybe<Scalars['Boolean']>;
  uncoverSnapshot1_not?: InputMaybe<Scalars['Boolean']>;
  uncoverSnapshot2?: InputMaybe<Scalars['Boolean']>;
  uncoverSnapshot2_exists?: InputMaybe<Scalars['Boolean']>;
  uncoverSnapshot2_not?: InputMaybe<Scalars['Boolean']>;
  uncoverSnapshot3?: InputMaybe<Scalars['Boolean']>;
  uncoverSnapshot3_exists?: InputMaybe<Scalars['Boolean']>;
  uncoverSnapshot3_not?: InputMaybe<Scalars['Boolean']>;
  urlSlug?: InputMaybe<Scalars['String']>;
  urlSlug_contains?: InputMaybe<Scalars['String']>;
  urlSlug_exists?: InputMaybe<Scalars['Boolean']>;
  urlSlug_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  urlSlug_not?: InputMaybe<Scalars['String']>;
  urlSlug_not_contains?: InputMaybe<Scalars['String']>;
  urlSlug_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type LockdropLinkingCollections = {
  __typename?: 'LockdropLinkingCollections';
  entryCollection?: Maybe<EntryCollection>;
};


export type LockdropLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
};

export enum LockdropOrder {
  DescriptionAsc = 'description_ASC',
  DescriptionDesc = 'description_DESC',
  EndDateAsc = 'endDate_ASC',
  EndDateDesc = 'endDate_DESC',
  NameAsc = 'name_ASC',
  NameDesc = 'name_DESC',
  StartDateAsc = 'startDate_ASC',
  StartDateDesc = 'startDate_DESC',
  SysFirstPublishedAtAsc = 'sys_firstPublishedAt_ASC',
  SysFirstPublishedAtDesc = 'sys_firstPublishedAt_DESC',
  SysIdAsc = 'sys_id_ASC',
  SysIdDesc = 'sys_id_DESC',
  SysPublishedAtAsc = 'sys_publishedAt_ASC',
  SysPublishedAtDesc = 'sys_publishedAt_DESC',
  SysPublishedVersionAsc = 'sys_publishedVersion_ASC',
  SysPublishedVersionDesc = 'sys_publishedVersion_DESC',
  TitleAsc = 'title_ASC',
  TitleDesc = 'title_DESC',
  UncoverEndDateAsc = 'uncoverEndDate_ASC',
  UncoverEndDateDesc = 'uncoverEndDate_DESC',
  UncoverSnapshot1Asc = 'uncoverSnapshot1_ASC',
  UncoverSnapshot1Desc = 'uncoverSnapshot1_DESC',
  UncoverSnapshot2Asc = 'uncoverSnapshot2_ASC',
  UncoverSnapshot2Desc = 'uncoverSnapshot2_DESC',
  UncoverSnapshot3Asc = 'uncoverSnapshot3_ASC',
  UncoverSnapshot3Desc = 'uncoverSnapshot3_DESC',
  UrlSlugAsc = 'urlSlug_ASC',
  UrlSlugDesc = 'urlSlug_DESC'
}

export type LockdropRewardTokensCollection = {
  __typename?: 'LockdropRewardTokensCollection';
  items: Array<Maybe<Token>>;
  limit: Scalars['Int'];
  skip: Scalars['Int'];
  total: Scalars['Int'];
};

/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/longText) */
export type LongText = Entry & {
  __typename?: 'LongText';
  contentfulMetadata: ContentfulMetadata;
  linkedFrom?: Maybe<LongTextLinkingCollections>;
  markdown?: Maybe<Scalars['String']>;
  sys: Sys;
  title?: Maybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/longText) */
export type LongTextLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/longText) */
export type LongTextMarkdownArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/longText) */
export type LongTextTitleArgs = {
  locale?: InputMaybe<Scalars['String']>;
};

export type LongTextCollection = {
  __typename?: 'LongTextCollection';
  items: Array<Maybe<LongText>>;
  limit: Scalars['Int'];
  skip: Scalars['Int'];
  total: Scalars['Int'];
};

export type LongTextFilter = {
  AND?: InputMaybe<Array<InputMaybe<LongTextFilter>>>;
  OR?: InputMaybe<Array<InputMaybe<LongTextFilter>>>;
  contentfulMetadata?: InputMaybe<ContentfulMetadataFilter>;
  markdown?: InputMaybe<Scalars['String']>;
  markdown_contains?: InputMaybe<Scalars['String']>;
  markdown_exists?: InputMaybe<Scalars['Boolean']>;
  markdown_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  markdown_not?: InputMaybe<Scalars['String']>;
  markdown_not_contains?: InputMaybe<Scalars['String']>;
  markdown_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  sys?: InputMaybe<SysFilter>;
  title?: InputMaybe<Scalars['String']>;
  title_contains?: InputMaybe<Scalars['String']>;
  title_exists?: InputMaybe<Scalars['Boolean']>;
  title_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  title_not?: InputMaybe<Scalars['String']>;
  title_not_contains?: InputMaybe<Scalars['String']>;
  title_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type LongTextLinkingCollections = {
  __typename?: 'LongTextLinkingCollections';
  entryCollection?: Maybe<EntryCollection>;
};


export type LongTextLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
};

export enum LongTextOrder {
  SysFirstPublishedAtAsc = 'sys_firstPublishedAt_ASC',
  SysFirstPublishedAtDesc = 'sys_firstPublishedAt_DESC',
  SysIdAsc = 'sys_id_ASC',
  SysIdDesc = 'sys_id_DESC',
  SysPublishedAtAsc = 'sys_publishedAt_ASC',
  SysPublishedAtDesc = 'sys_publishedAt_DESC',
  SysPublishedVersionAsc = 'sys_publishedVersion_ASC',
  SysPublishedVersionDesc = 'sys_publishedVersion_DESC',
  TitleAsc = 'title_ASC',
  TitleDesc = 'title_DESC'
}

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type StringComparisonExp = {
  _eq?: InputMaybe<Scalars['String']>;
  _gt?: InputMaybe<Scalars['String']>;
  _gte?: InputMaybe<Scalars['String']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: InputMaybe<Scalars['String']>;
  _in?: InputMaybe<Array<Scalars['String']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: InputMaybe<Scalars['String']>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  /** does the column match the given pattern */
  _like?: InputMaybe<Scalars['String']>;
  _lt?: InputMaybe<Scalars['String']>;
  _lte?: InputMaybe<Scalars['String']>;
  _neq?: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: InputMaybe<Scalars['String']>;
  _nin?: InputMaybe<Array<Scalars['String']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given pattern */
  _nlike?: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: InputMaybe<Scalars['String']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: InputMaybe<Scalars['String']>;
  /** does the column match the given SQL regular expression */
  _similar?: InputMaybe<Scalars['String']>;
};

export type Sys = {
  __typename?: 'Sys';
  environmentId: Scalars['String'];
  firstPublishedAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['String'];
  publishedAt?: Maybe<Scalars['DateTime']>;
  publishedVersion?: Maybe<Scalars['Int']>;
  spaceId: Scalars['String'];
};

export type SysFilter = {
  firstPublishedAt?: InputMaybe<Scalars['DateTime']>;
  firstPublishedAt_exists?: InputMaybe<Scalars['Boolean']>;
  firstPublishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  firstPublishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  firstPublishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  firstPublishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  firstPublishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  firstPublishedAt_not?: InputMaybe<Scalars['DateTime']>;
  firstPublishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  id?: InputMaybe<Scalars['String']>;
  id_contains?: InputMaybe<Scalars['String']>;
  id_exists?: InputMaybe<Scalars['Boolean']>;
  id_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  id_not?: InputMaybe<Scalars['String']>;
  id_not_contains?: InputMaybe<Scalars['String']>;
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  publishedAt_exists?: InputMaybe<Scalars['Boolean']>;
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedVersion?: InputMaybe<Scalars['Float']>;
  publishedVersion_exists?: InputMaybe<Scalars['Boolean']>;
  publishedVersion_gt?: InputMaybe<Scalars['Float']>;
  publishedVersion_gte?: InputMaybe<Scalars['Float']>;
  publishedVersion_in?: InputMaybe<Array<InputMaybe<Scalars['Float']>>>;
  publishedVersion_lt?: InputMaybe<Scalars['Float']>;
  publishedVersion_lte?: InputMaybe<Scalars['Float']>;
  publishedVersion_not?: InputMaybe<Scalars['Float']>;
  publishedVersion_not_in?: InputMaybe<Array<InputMaybe<Scalars['Float']>>>;
};

/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/token) */
export type Token = Entry & {
  __typename?: 'Token';
  contentfulMetadata: ContentfulMetadata;
  description?: Maybe<Scalars['String']>;
  iconsCollection?: Maybe<AssetCollection>;
  id?: Maybe<Scalars['String']>;
  linkedFrom?: Maybe<TokenLinkingCollections>;
  name?: Maybe<Scalars['String']>;
  precision?: Maybe<Scalars['Int']>;
  scale?: Maybe<Scalars['Int']>;
  sys: Sys;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/token) */
export type TokenDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/token) */
export type TokenIconsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/token) */
export type TokenIdArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/token) */
export type TokenLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/token) */
export type TokenNameArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/token) */
export type TokenPrecisionArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/token) */
export type TokenScaleArgs = {
  locale?: InputMaybe<Scalars['String']>;
};

export type TokenCollection = {
  __typename?: 'TokenCollection';
  items: Array<Maybe<Token>>;
  limit: Scalars['Int'];
  skip: Scalars['Int'];
  total: Scalars['Int'];
};

export type TokenFilter = {
  AND?: InputMaybe<Array<InputMaybe<TokenFilter>>>;
  OR?: InputMaybe<Array<InputMaybe<TokenFilter>>>;
  contentfulMetadata?: InputMaybe<ContentfulMetadataFilter>;
  description?: InputMaybe<Scalars['String']>;
  description_contains?: InputMaybe<Scalars['String']>;
  description_exists?: InputMaybe<Scalars['Boolean']>;
  description_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  description_not?: InputMaybe<Scalars['String']>;
  description_not_contains?: InputMaybe<Scalars['String']>;
  description_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  iconsCollection_exists?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['String']>;
  id_contains?: InputMaybe<Scalars['String']>;
  id_exists?: InputMaybe<Scalars['Boolean']>;
  id_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  id_not?: InputMaybe<Scalars['String']>;
  id_not_contains?: InputMaybe<Scalars['String']>;
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_exists?: InputMaybe<Scalars['Boolean']>;
  name_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  precision?: InputMaybe<Scalars['Int']>;
  precision_exists?: InputMaybe<Scalars['Boolean']>;
  precision_gt?: InputMaybe<Scalars['Int']>;
  precision_gte?: InputMaybe<Scalars['Int']>;
  precision_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  precision_lt?: InputMaybe<Scalars['Int']>;
  precision_lte?: InputMaybe<Scalars['Int']>;
  precision_not?: InputMaybe<Scalars['Int']>;
  precision_not_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  scale?: InputMaybe<Scalars['Int']>;
  scale_exists?: InputMaybe<Scalars['Boolean']>;
  scale_gt?: InputMaybe<Scalars['Int']>;
  scale_gte?: InputMaybe<Scalars['Int']>;
  scale_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  scale_lt?: InputMaybe<Scalars['Int']>;
  scale_lte?: InputMaybe<Scalars['Int']>;
  scale_not?: InputMaybe<Scalars['Int']>;
  scale_not_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  sys?: InputMaybe<SysFilter>;
};

export type TokenLinkingCollections = {
  __typename?: 'TokenLinkingCollections';
  appConfigCollection?: Maybe<AppConfigCollection>;
  entryCollection?: Maybe<EntryCollection>;
  idoCollection?: Maybe<IdoCollection>;
  lockdropCollection?: Maybe<LockdropCollection>;
  tokenListItemCollection?: Maybe<TokenListItemCollection>;
};


export type TokenLinkingCollectionsAppConfigCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
};


export type TokenLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
};


export type TokenLinkingCollectionsIdoCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
};


export type TokenLinkingCollectionsLockdropCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
};


export type TokenLinkingCollectionsTokenListItemCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
};

/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/tokenListItem) */
export type TokenListItem = Entry & {
  __typename?: 'TokenListItem';
  contentfulMetadata: ContentfulMetadata;
  ddReportLink?: Maybe<Scalars['String']>;
  discordLink?: Maybe<Scalars['String']>;
  launchTime?: Maybe<Scalars['String']>;
  linkedFrom?: Maybe<TokenListItemLinkingCollections>;
  mediumLink?: Maybe<Scalars['String']>;
  sortedBy?: Maybe<Scalars['DateTime']>;
  status?: Maybe<Scalars['String']>;
  sys: Sys;
  telegramLink?: Maybe<Scalars['String']>;
  token?: Maybe<Token>;
  twitterLink?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  whitePaperLink?: Maybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/tokenListItem) */
export type TokenListItemDdReportLinkArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/tokenListItem) */
export type TokenListItemDiscordLinkArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/tokenListItem) */
export type TokenListItemLaunchTimeArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/tokenListItem) */
export type TokenListItemLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/tokenListItem) */
export type TokenListItemMediumLinkArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/tokenListItem) */
export type TokenListItemSortedByArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/tokenListItem) */
export type TokenListItemStatusArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/tokenListItem) */
export type TokenListItemTelegramLinkArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/tokenListItem) */
export type TokenListItemTokenArgs = {
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/tokenListItem) */
export type TokenListItemTwitterLinkArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/tokenListItem) */
export type TokenListItemWebsiteArgs = {
  locale?: InputMaybe<Scalars['String']>;
};


/** [See type definition](https://app.contentful.com/spaces/frwmwlognk87/content_types/tokenListItem) */
export type TokenListItemWhitePaperLinkArgs = {
  locale?: InputMaybe<Scalars['String']>;
};

export type TokenListItemCollection = {
  __typename?: 'TokenListItemCollection';
  items: Array<Maybe<TokenListItem>>;
  limit: Scalars['Int'];
  skip: Scalars['Int'];
  total: Scalars['Int'];
};

export type TokenListItemFilter = {
  AND?: InputMaybe<Array<InputMaybe<TokenListItemFilter>>>;
  OR?: InputMaybe<Array<InputMaybe<TokenListItemFilter>>>;
  contentfulMetadata?: InputMaybe<ContentfulMetadataFilter>;
  ddReportLink?: InputMaybe<Scalars['String']>;
  ddReportLink_contains?: InputMaybe<Scalars['String']>;
  ddReportLink_exists?: InputMaybe<Scalars['Boolean']>;
  ddReportLink_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  ddReportLink_not?: InputMaybe<Scalars['String']>;
  ddReportLink_not_contains?: InputMaybe<Scalars['String']>;
  ddReportLink_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  discordLink?: InputMaybe<Scalars['String']>;
  discordLink_contains?: InputMaybe<Scalars['String']>;
  discordLink_exists?: InputMaybe<Scalars['Boolean']>;
  discordLink_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  discordLink_not?: InputMaybe<Scalars['String']>;
  discordLink_not_contains?: InputMaybe<Scalars['String']>;
  discordLink_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  launchTime?: InputMaybe<Scalars['String']>;
  launchTime_contains?: InputMaybe<Scalars['String']>;
  launchTime_exists?: InputMaybe<Scalars['Boolean']>;
  launchTime_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  launchTime_not?: InputMaybe<Scalars['String']>;
  launchTime_not_contains?: InputMaybe<Scalars['String']>;
  launchTime_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  mediumLink?: InputMaybe<Scalars['String']>;
  mediumLink_contains?: InputMaybe<Scalars['String']>;
  mediumLink_exists?: InputMaybe<Scalars['Boolean']>;
  mediumLink_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  mediumLink_not?: InputMaybe<Scalars['String']>;
  mediumLink_not_contains?: InputMaybe<Scalars['String']>;
  mediumLink_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  sortedBy?: InputMaybe<Scalars['DateTime']>;
  sortedBy_exists?: InputMaybe<Scalars['Boolean']>;
  sortedBy_gt?: InputMaybe<Scalars['DateTime']>;
  sortedBy_gte?: InputMaybe<Scalars['DateTime']>;
  sortedBy_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  sortedBy_lt?: InputMaybe<Scalars['DateTime']>;
  sortedBy_lte?: InputMaybe<Scalars['DateTime']>;
  sortedBy_not?: InputMaybe<Scalars['DateTime']>;
  sortedBy_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  status?: InputMaybe<Scalars['String']>;
  status_contains?: InputMaybe<Scalars['String']>;
  status_exists?: InputMaybe<Scalars['Boolean']>;
  status_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  status_not?: InputMaybe<Scalars['String']>;
  status_not_contains?: InputMaybe<Scalars['String']>;
  status_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  sys?: InputMaybe<SysFilter>;
  telegramLink?: InputMaybe<Scalars['String']>;
  telegramLink_contains?: InputMaybe<Scalars['String']>;
  telegramLink_exists?: InputMaybe<Scalars['Boolean']>;
  telegramLink_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  telegramLink_not?: InputMaybe<Scalars['String']>;
  telegramLink_not_contains?: InputMaybe<Scalars['String']>;
  telegramLink_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  token?: InputMaybe<CfTokenNestedFilter>;
  token_exists?: InputMaybe<Scalars['Boolean']>;
  twitterLink?: InputMaybe<Scalars['String']>;
  twitterLink_contains?: InputMaybe<Scalars['String']>;
  twitterLink_exists?: InputMaybe<Scalars['Boolean']>;
  twitterLink_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  twitterLink_not?: InputMaybe<Scalars['String']>;
  twitterLink_not_contains?: InputMaybe<Scalars['String']>;
  twitterLink_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  website?: InputMaybe<Scalars['String']>;
  website_contains?: InputMaybe<Scalars['String']>;
  website_exists?: InputMaybe<Scalars['Boolean']>;
  website_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  website_not?: InputMaybe<Scalars['String']>;
  website_not_contains?: InputMaybe<Scalars['String']>;
  website_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  whitePaperLink?: InputMaybe<Scalars['String']>;
  whitePaperLink_contains?: InputMaybe<Scalars['String']>;
  whitePaperLink_exists?: InputMaybe<Scalars['Boolean']>;
  whitePaperLink_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  whitePaperLink_not?: InputMaybe<Scalars['String']>;
  whitePaperLink_not_contains?: InputMaybe<Scalars['String']>;
  whitePaperLink_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type TokenListItemLinkingCollections = {
  __typename?: 'TokenListItemLinkingCollections';
  entryCollection?: Maybe<EntryCollection>;
};


export type TokenListItemLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
};

export enum TokenListItemOrder {
  DdReportLinkAsc = 'ddReportLink_ASC',
  DdReportLinkDesc = 'ddReportLink_DESC',
  DiscordLinkAsc = 'discordLink_ASC',
  DiscordLinkDesc = 'discordLink_DESC',
  LaunchTimeAsc = 'launchTime_ASC',
  LaunchTimeDesc = 'launchTime_DESC',
  MediumLinkAsc = 'mediumLink_ASC',
  MediumLinkDesc = 'mediumLink_DESC',
  SortedByAsc = 'sortedBy_ASC',
  SortedByDesc = 'sortedBy_DESC',
  StatusAsc = 'status_ASC',
  StatusDesc = 'status_DESC',
  SysFirstPublishedAtAsc = 'sys_firstPublishedAt_ASC',
  SysFirstPublishedAtDesc = 'sys_firstPublishedAt_DESC',
  SysIdAsc = 'sys_id_ASC',
  SysIdDesc = 'sys_id_DESC',
  SysPublishedAtAsc = 'sys_publishedAt_ASC',
  SysPublishedAtDesc = 'sys_publishedAt_DESC',
  SysPublishedVersionAsc = 'sys_publishedVersion_ASC',
  SysPublishedVersionDesc = 'sys_publishedVersion_DESC',
  TelegramLinkAsc = 'telegramLink_ASC',
  TelegramLinkDesc = 'telegramLink_DESC',
  TwitterLinkAsc = 'twitterLink_ASC',
  TwitterLinkDesc = 'twitterLink_DESC',
  WebsiteAsc = 'website_ASC',
  WebsiteDesc = 'website_DESC',
  WhitePaperLinkAsc = 'whitePaperLink_ASC',
  WhitePaperLinkDesc = 'whitePaperLink_DESC'
}

export enum TokenOrder {
  DescriptionAsc = 'description_ASC',
  DescriptionDesc = 'description_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  NameAsc = 'name_ASC',
  NameDesc = 'name_DESC',
  PrecisionAsc = 'precision_ASC',
  PrecisionDesc = 'precision_DESC',
  ScaleAsc = 'scale_ASC',
  ScaleDesc = 'scale_DESC',
  SysFirstPublishedAtAsc = 'sys_firstPublishedAt_ASC',
  SysFirstPublishedAtDesc = 'sys_firstPublishedAt_DESC',
  SysIdAsc = 'sys_id_ASC',
  SysIdDesc = 'sys_id_DESC',
  SysPublishedAtAsc = 'sys_publishedAt_ASC',
  SysPublishedAtDesc = 'sys_publishedAt_DESC',
  SysPublishedVersionAsc = 'sys_publishedVersion_ASC',
  SysPublishedVersionDesc = 'sys_publishedVersion_DESC'
}

/** Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'. */
export type BigintComparisonExp = {
  _eq?: InputMaybe<Scalars['bigint']>;
  _gt?: InputMaybe<Scalars['bigint']>;
  _gte?: InputMaybe<Scalars['bigint']>;
  _in?: InputMaybe<Array<Scalars['bigint']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['bigint']>;
  _lte?: InputMaybe<Scalars['bigint']>;
  _neq?: InputMaybe<Scalars['bigint']>;
  _nin?: InputMaybe<Array<Scalars['bigint']>>;
};

/** columns and relationships of "blocks" */
export type Blocks = {
  __typename?: 'blocks';
  block_hash: Scalars['bytea'];
  block_height: Scalars['Int'];
  burn_block_hash: Scalars['bytea'];
  burn_block_height: Scalars['Int'];
  burn_block_time: Scalars['Int'];
  canonical: Scalars['Boolean'];
  execution_cost_read_count: Scalars['bigint'];
  execution_cost_read_length: Scalars['bigint'];
  execution_cost_runtime: Scalars['bigint'];
  execution_cost_write_count: Scalars['bigint'];
  execution_cost_write_length: Scalars['bigint'];
  index_block_hash: Scalars['bytea'];
  miner_txid: Scalars['bytea'];
  parent_block_hash: Scalars['bytea'];
  parent_index_block_hash: Scalars['bytea'];
  parent_microblock_hash: Scalars['bytea'];
  parent_microblock_sequence: Scalars['Int'];
};

/** aggregated selection of "blocks" */
export type BlocksAggregate = {
  __typename?: 'blocks_aggregate';
  aggregate?: Maybe<BlocksAggregateFields>;
  nodes: Array<Blocks>;
};

/** aggregate fields of "blocks" */
export type BlocksAggregateFields = {
  __typename?: 'blocks_aggregate_fields';
  avg?: Maybe<BlocksAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<BlocksMaxFields>;
  min?: Maybe<BlocksMinFields>;
  stddev?: Maybe<BlocksStddevFields>;
  stddev_pop?: Maybe<BlocksStddevPopFields>;
  stddev_samp?: Maybe<BlocksStddevSampFields>;
  sum?: Maybe<BlocksSumFields>;
  var_pop?: Maybe<BlocksVarPopFields>;
  var_samp?: Maybe<BlocksVarSampFields>;
  variance?: Maybe<BlocksVarianceFields>;
};


/** aggregate fields of "blocks" */
export type BlocksAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<BlocksSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type BlocksAvgFields = {
  __typename?: 'blocks_avg_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  execution_cost_read_count?: Maybe<Scalars['Float']>;
  execution_cost_read_length?: Maybe<Scalars['Float']>;
  execution_cost_runtime?: Maybe<Scalars['Float']>;
  execution_cost_write_count?: Maybe<Scalars['Float']>;
  execution_cost_write_length?: Maybe<Scalars['Float']>;
  parent_microblock_sequence?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "blocks". All fields are combined with a logical 'AND'. */
export type BlocksBoolExp = {
  _and?: InputMaybe<Array<BlocksBoolExp>>;
  _not?: InputMaybe<BlocksBoolExp>;
  _or?: InputMaybe<Array<BlocksBoolExp>>;
  block_hash?: InputMaybe<ByteaComparisonExp>;
  block_height?: InputMaybe<IntComparisonExp>;
  burn_block_hash?: InputMaybe<ByteaComparisonExp>;
  burn_block_height?: InputMaybe<IntComparisonExp>;
  burn_block_time?: InputMaybe<IntComparisonExp>;
  canonical?: InputMaybe<BooleanComparisonExp>;
  execution_cost_read_count?: InputMaybe<BigintComparisonExp>;
  execution_cost_read_length?: InputMaybe<BigintComparisonExp>;
  execution_cost_runtime?: InputMaybe<BigintComparisonExp>;
  execution_cost_write_count?: InputMaybe<BigintComparisonExp>;
  execution_cost_write_length?: InputMaybe<BigintComparisonExp>;
  index_block_hash?: InputMaybe<ByteaComparisonExp>;
  miner_txid?: InputMaybe<ByteaComparisonExp>;
  parent_block_hash?: InputMaybe<ByteaComparisonExp>;
  parent_index_block_hash?: InputMaybe<ByteaComparisonExp>;
  parent_microblock_hash?: InputMaybe<ByteaComparisonExp>;
  parent_microblock_sequence?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "blocks" */
export enum BlocksConstraint {
  /** unique or primary key constraint on columns "index_block_hash" */
  BlocksPkey = 'blocks_pkey'
}

/** input type for incrementing numeric columns in table "blocks" */
export type BlocksIncInput = {
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  execution_cost_read_count?: InputMaybe<Scalars['bigint']>;
  execution_cost_read_length?: InputMaybe<Scalars['bigint']>;
  execution_cost_runtime?: InputMaybe<Scalars['bigint']>;
  execution_cost_write_count?: InputMaybe<Scalars['bigint']>;
  execution_cost_write_length?: InputMaybe<Scalars['bigint']>;
  parent_microblock_sequence?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "blocks" */
export type BlocksInsertInput = {
  block_hash?: InputMaybe<Scalars['bytea']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_hash?: InputMaybe<Scalars['bytea']>;
  burn_block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  canonical?: InputMaybe<Scalars['Boolean']>;
  execution_cost_read_count?: InputMaybe<Scalars['bigint']>;
  execution_cost_read_length?: InputMaybe<Scalars['bigint']>;
  execution_cost_runtime?: InputMaybe<Scalars['bigint']>;
  execution_cost_write_count?: InputMaybe<Scalars['bigint']>;
  execution_cost_write_length?: InputMaybe<Scalars['bigint']>;
  index_block_hash?: InputMaybe<Scalars['bytea']>;
  miner_txid?: InputMaybe<Scalars['bytea']>;
  parent_block_hash?: InputMaybe<Scalars['bytea']>;
  parent_index_block_hash?: InputMaybe<Scalars['bytea']>;
  parent_microblock_hash?: InputMaybe<Scalars['bytea']>;
  parent_microblock_sequence?: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type BlocksMaxFields = {
  __typename?: 'blocks_max_fields';
  block_height?: Maybe<Scalars['Int']>;
  burn_block_height?: Maybe<Scalars['Int']>;
  burn_block_time?: Maybe<Scalars['Int']>;
  execution_cost_read_count?: Maybe<Scalars['bigint']>;
  execution_cost_read_length?: Maybe<Scalars['bigint']>;
  execution_cost_runtime?: Maybe<Scalars['bigint']>;
  execution_cost_write_count?: Maybe<Scalars['bigint']>;
  execution_cost_write_length?: Maybe<Scalars['bigint']>;
  parent_microblock_sequence?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type BlocksMinFields = {
  __typename?: 'blocks_min_fields';
  block_height?: Maybe<Scalars['Int']>;
  burn_block_height?: Maybe<Scalars['Int']>;
  burn_block_time?: Maybe<Scalars['Int']>;
  execution_cost_read_count?: Maybe<Scalars['bigint']>;
  execution_cost_read_length?: Maybe<Scalars['bigint']>;
  execution_cost_runtime?: Maybe<Scalars['bigint']>;
  execution_cost_write_count?: Maybe<Scalars['bigint']>;
  execution_cost_write_length?: Maybe<Scalars['bigint']>;
  parent_microblock_sequence?: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "blocks" */
export type BlocksMutationResponse = {
  __typename?: 'blocks_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Blocks>;
};

/** on_conflict condition type for table "blocks" */
export type BlocksOnConflict = {
  constraint: BlocksConstraint;
  update_columns?: Array<BlocksUpdateColumn>;
  where?: InputMaybe<BlocksBoolExp>;
};

/** Ordering options when selecting data from "blocks". */
export type BlocksOrderBy = {
  block_hash?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  burn_block_hash?: InputMaybe<OrderBy>;
  burn_block_height?: InputMaybe<OrderBy>;
  burn_block_time?: InputMaybe<OrderBy>;
  canonical?: InputMaybe<OrderBy>;
  execution_cost_read_count?: InputMaybe<OrderBy>;
  execution_cost_read_length?: InputMaybe<OrderBy>;
  execution_cost_runtime?: InputMaybe<OrderBy>;
  execution_cost_write_count?: InputMaybe<OrderBy>;
  execution_cost_write_length?: InputMaybe<OrderBy>;
  index_block_hash?: InputMaybe<OrderBy>;
  miner_txid?: InputMaybe<OrderBy>;
  parent_block_hash?: InputMaybe<OrderBy>;
  parent_index_block_hash?: InputMaybe<OrderBy>;
  parent_microblock_hash?: InputMaybe<OrderBy>;
  parent_microblock_sequence?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: blocks */
export type BlocksPkColumnsInput = {
  index_block_hash: Scalars['bytea'];
};

/** select columns of table "blocks" */
export enum BlocksSelectColumn {
  /** column name */
  BlockHash = 'block_hash',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockHash = 'burn_block_hash',
  /** column name */
  BurnBlockHeight = 'burn_block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  Canonical = 'canonical',
  /** column name */
  ExecutionCostReadCount = 'execution_cost_read_count',
  /** column name */
  ExecutionCostReadLength = 'execution_cost_read_length',
  /** column name */
  ExecutionCostRuntime = 'execution_cost_runtime',
  /** column name */
  ExecutionCostWriteCount = 'execution_cost_write_count',
  /** column name */
  ExecutionCostWriteLength = 'execution_cost_write_length',
  /** column name */
  IndexBlockHash = 'index_block_hash',
  /** column name */
  MinerTxid = 'miner_txid',
  /** column name */
  ParentBlockHash = 'parent_block_hash',
  /** column name */
  ParentIndexBlockHash = 'parent_index_block_hash',
  /** column name */
  ParentMicroblockHash = 'parent_microblock_hash',
  /** column name */
  ParentMicroblockSequence = 'parent_microblock_sequence'
}

/** input type for updating data in table "blocks" */
export type BlocksSetInput = {
  block_hash?: InputMaybe<Scalars['bytea']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_hash?: InputMaybe<Scalars['bytea']>;
  burn_block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  canonical?: InputMaybe<Scalars['Boolean']>;
  execution_cost_read_count?: InputMaybe<Scalars['bigint']>;
  execution_cost_read_length?: InputMaybe<Scalars['bigint']>;
  execution_cost_runtime?: InputMaybe<Scalars['bigint']>;
  execution_cost_write_count?: InputMaybe<Scalars['bigint']>;
  execution_cost_write_length?: InputMaybe<Scalars['bigint']>;
  index_block_hash?: InputMaybe<Scalars['bytea']>;
  miner_txid?: InputMaybe<Scalars['bytea']>;
  parent_block_hash?: InputMaybe<Scalars['bytea']>;
  parent_index_block_hash?: InputMaybe<Scalars['bytea']>;
  parent_microblock_hash?: InputMaybe<Scalars['bytea']>;
  parent_microblock_sequence?: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type BlocksStddevFields = {
  __typename?: 'blocks_stddev_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  execution_cost_read_count?: Maybe<Scalars['Float']>;
  execution_cost_read_length?: Maybe<Scalars['Float']>;
  execution_cost_runtime?: Maybe<Scalars['Float']>;
  execution_cost_write_count?: Maybe<Scalars['Float']>;
  execution_cost_write_length?: Maybe<Scalars['Float']>;
  parent_microblock_sequence?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type BlocksStddevPopFields = {
  __typename?: 'blocks_stddev_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  execution_cost_read_count?: Maybe<Scalars['Float']>;
  execution_cost_read_length?: Maybe<Scalars['Float']>;
  execution_cost_runtime?: Maybe<Scalars['Float']>;
  execution_cost_write_count?: Maybe<Scalars['Float']>;
  execution_cost_write_length?: Maybe<Scalars['Float']>;
  parent_microblock_sequence?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type BlocksStddevSampFields = {
  __typename?: 'blocks_stddev_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  execution_cost_read_count?: Maybe<Scalars['Float']>;
  execution_cost_read_length?: Maybe<Scalars['Float']>;
  execution_cost_runtime?: Maybe<Scalars['Float']>;
  execution_cost_write_count?: Maybe<Scalars['Float']>;
  execution_cost_write_length?: Maybe<Scalars['Float']>;
  parent_microblock_sequence?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "blocks" */
export type BlocksStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: BlocksStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type BlocksStreamCursorValueInput = {
  block_hash?: InputMaybe<Scalars['bytea']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_hash?: InputMaybe<Scalars['bytea']>;
  burn_block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  canonical?: InputMaybe<Scalars['Boolean']>;
  execution_cost_read_count?: InputMaybe<Scalars['bigint']>;
  execution_cost_read_length?: InputMaybe<Scalars['bigint']>;
  execution_cost_runtime?: InputMaybe<Scalars['bigint']>;
  execution_cost_write_count?: InputMaybe<Scalars['bigint']>;
  execution_cost_write_length?: InputMaybe<Scalars['bigint']>;
  index_block_hash?: InputMaybe<Scalars['bytea']>;
  miner_txid?: InputMaybe<Scalars['bytea']>;
  parent_block_hash?: InputMaybe<Scalars['bytea']>;
  parent_index_block_hash?: InputMaybe<Scalars['bytea']>;
  parent_microblock_hash?: InputMaybe<Scalars['bytea']>;
  parent_microblock_sequence?: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type BlocksSumFields = {
  __typename?: 'blocks_sum_fields';
  block_height?: Maybe<Scalars['Int']>;
  burn_block_height?: Maybe<Scalars['Int']>;
  burn_block_time?: Maybe<Scalars['Int']>;
  execution_cost_read_count?: Maybe<Scalars['bigint']>;
  execution_cost_read_length?: Maybe<Scalars['bigint']>;
  execution_cost_runtime?: Maybe<Scalars['bigint']>;
  execution_cost_write_count?: Maybe<Scalars['bigint']>;
  execution_cost_write_length?: Maybe<Scalars['bigint']>;
  parent_microblock_sequence?: Maybe<Scalars['Int']>;
};

/** update columns of table "blocks" */
export enum BlocksUpdateColumn {
  /** column name */
  BlockHash = 'block_hash',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockHash = 'burn_block_hash',
  /** column name */
  BurnBlockHeight = 'burn_block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  Canonical = 'canonical',
  /** column name */
  ExecutionCostReadCount = 'execution_cost_read_count',
  /** column name */
  ExecutionCostReadLength = 'execution_cost_read_length',
  /** column name */
  ExecutionCostRuntime = 'execution_cost_runtime',
  /** column name */
  ExecutionCostWriteCount = 'execution_cost_write_count',
  /** column name */
  ExecutionCostWriteLength = 'execution_cost_write_length',
  /** column name */
  IndexBlockHash = 'index_block_hash',
  /** column name */
  MinerTxid = 'miner_txid',
  /** column name */
  ParentBlockHash = 'parent_block_hash',
  /** column name */
  ParentIndexBlockHash = 'parent_index_block_hash',
  /** column name */
  ParentMicroblockHash = 'parent_microblock_hash',
  /** column name */
  ParentMicroblockSequence = 'parent_microblock_sequence'
}

export type BlocksUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<BlocksIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<BlocksSetInput>;
  where: BlocksBoolExp;
};

/** aggregate var_pop on columns */
export type BlocksVarPopFields = {
  __typename?: 'blocks_var_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  execution_cost_read_count?: Maybe<Scalars['Float']>;
  execution_cost_read_length?: Maybe<Scalars['Float']>;
  execution_cost_runtime?: Maybe<Scalars['Float']>;
  execution_cost_write_count?: Maybe<Scalars['Float']>;
  execution_cost_write_length?: Maybe<Scalars['Float']>;
  parent_microblock_sequence?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type BlocksVarSampFields = {
  __typename?: 'blocks_var_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  execution_cost_read_count?: Maybe<Scalars['Float']>;
  execution_cost_read_length?: Maybe<Scalars['Float']>;
  execution_cost_runtime?: Maybe<Scalars['Float']>;
  execution_cost_write_count?: Maybe<Scalars['Float']>;
  execution_cost_write_length?: Maybe<Scalars['Float']>;
  parent_microblock_sequence?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type BlocksVarianceFields = {
  __typename?: 'blocks_variance_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  execution_cost_read_count?: Maybe<Scalars['Float']>;
  execution_cost_read_length?: Maybe<Scalars['Float']>;
  execution_cost_runtime?: Maybe<Scalars['Float']>;
  execution_cost_write_count?: Maybe<Scalars['Float']>;
  execution_cost_write_length?: Maybe<Scalars['Float']>;
  parent_microblock_sequence?: Maybe<Scalars['Float']>;
};

/** Boolean expression to compare columns of type "bytea". All fields are combined with logical 'AND'. */
export type ByteaComparisonExp = {
  _eq?: InputMaybe<Scalars['bytea']>;
  _gt?: InputMaybe<Scalars['bytea']>;
  _gte?: InputMaybe<Scalars['bytea']>;
  _in?: InputMaybe<Array<Scalars['bytea']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['bytea']>;
  _lte?: InputMaybe<Scalars['bytea']>;
  _neq?: InputMaybe<Scalars['bytea']>;
  _nin?: InputMaybe<Array<Scalars['bytea']>>;
};

export type CfTokenNestedFilter = {
  AND?: InputMaybe<Array<InputMaybe<CfTokenNestedFilter>>>;
  OR?: InputMaybe<Array<InputMaybe<CfTokenNestedFilter>>>;
  contentfulMetadata?: InputMaybe<ContentfulMetadataFilter>;
  description?: InputMaybe<Scalars['String']>;
  description_contains?: InputMaybe<Scalars['String']>;
  description_exists?: InputMaybe<Scalars['Boolean']>;
  description_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  description_not?: InputMaybe<Scalars['String']>;
  description_not_contains?: InputMaybe<Scalars['String']>;
  description_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  iconsCollection_exists?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['String']>;
  id_contains?: InputMaybe<Scalars['String']>;
  id_exists?: InputMaybe<Scalars['Boolean']>;
  id_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  id_not?: InputMaybe<Scalars['String']>;
  id_not_contains?: InputMaybe<Scalars['String']>;
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_exists?: InputMaybe<Scalars['Boolean']>;
  name_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  precision?: InputMaybe<Scalars['Int']>;
  precision_exists?: InputMaybe<Scalars['Boolean']>;
  precision_gt?: InputMaybe<Scalars['Int']>;
  precision_gte?: InputMaybe<Scalars['Int']>;
  precision_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  precision_lt?: InputMaybe<Scalars['Int']>;
  precision_lte?: InputMaybe<Scalars['Int']>;
  precision_not?: InputMaybe<Scalars['Int']>;
  precision_not_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  scale?: InputMaybe<Scalars['Int']>;
  scale_exists?: InputMaybe<Scalars['Boolean']>;
  scale_gt?: InputMaybe<Scalars['Int']>;
  scale_gte?: InputMaybe<Scalars['Int']>;
  scale_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  scale_lt?: InputMaybe<Scalars['Int']>;
  scale_lte?: InputMaybe<Scalars['Int']>;
  scale_not?: InputMaybe<Scalars['Int']>;
  scale_not_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  sys?: InputMaybe<SysFilter>;
};

/** columns and relationships of "contract_logs" */
export type ContractLogs = {
  __typename?: 'contract_logs';
  block_height: Scalars['Int'];
  canonical: Scalars['Boolean'];
  contract_identifier: Scalars['String'];
  event_index: Scalars['Int'];
  id: Scalars['Int'];
  index_block_hash: Scalars['bytea'];
  microblock_canonical: Scalars['Boolean'];
  microblock_hash: Scalars['bytea'];
  microblock_sequence: Scalars['Int'];
  parent_index_block_hash: Scalars['bytea'];
  topic: Scalars['String'];
  tx_id: Scalars['bytea'];
  tx_index: Scalars['smallint'];
  value: Scalars['bytea'];
};

/** aggregated selection of "contract_logs" */
export type ContractLogsAggregate = {
  __typename?: 'contract_logs_aggregate';
  aggregate?: Maybe<ContractLogsAggregateFields>;
  nodes: Array<ContractLogs>;
};

/** aggregate fields of "contract_logs" */
export type ContractLogsAggregateFields = {
  __typename?: 'contract_logs_aggregate_fields';
  avg?: Maybe<ContractLogsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<ContractLogsMaxFields>;
  min?: Maybe<ContractLogsMinFields>;
  stddev?: Maybe<ContractLogsStddevFields>;
  stddev_pop?: Maybe<ContractLogsStddevPopFields>;
  stddev_samp?: Maybe<ContractLogsStddevSampFields>;
  sum?: Maybe<ContractLogsSumFields>;
  var_pop?: Maybe<ContractLogsVarPopFields>;
  var_samp?: Maybe<ContractLogsVarSampFields>;
  variance?: Maybe<ContractLogsVarianceFields>;
};


/** aggregate fields of "contract_logs" */
export type ContractLogsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ContractLogsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type ContractLogsAvgFields = {
  __typename?: 'contract_logs_avg_fields';
  block_height?: Maybe<Scalars['Float']>;
  event_index?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "contract_logs". All fields are combined with a logical 'AND'. */
export type ContractLogsBoolExp = {
  _and?: InputMaybe<Array<ContractLogsBoolExp>>;
  _not?: InputMaybe<ContractLogsBoolExp>;
  _or?: InputMaybe<Array<ContractLogsBoolExp>>;
  block_height?: InputMaybe<IntComparisonExp>;
  canonical?: InputMaybe<BooleanComparisonExp>;
  contract_identifier?: InputMaybe<StringComparisonExp>;
  event_index?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  index_block_hash?: InputMaybe<ByteaComparisonExp>;
  microblock_canonical?: InputMaybe<BooleanComparisonExp>;
  microblock_hash?: InputMaybe<ByteaComparisonExp>;
  microblock_sequence?: InputMaybe<IntComparisonExp>;
  parent_index_block_hash?: InputMaybe<ByteaComparisonExp>;
  topic?: InputMaybe<StringComparisonExp>;
  tx_id?: InputMaybe<ByteaComparisonExp>;
  tx_index?: InputMaybe<SmallintComparisonExp>;
  value?: InputMaybe<ByteaComparisonExp>;
};

/** unique or primary key constraints on table "contract_logs" */
export enum ContractLogsConstraint {
  /** unique or primary key constraint on columns "id" */
  ContractLogsPkey = 'contract_logs_pkey'
}

/** input type for incrementing numeric columns in table "contract_logs" */
export type ContractLogsIncInput = {
  block_height?: InputMaybe<Scalars['Int']>;
  event_index?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['Int']>;
  microblock_sequence?: InputMaybe<Scalars['Int']>;
  tx_index?: InputMaybe<Scalars['smallint']>;
};

/** input type for inserting data into table "contract_logs" */
export type ContractLogsInsertInput = {
  block_height?: InputMaybe<Scalars['Int']>;
  canonical?: InputMaybe<Scalars['Boolean']>;
  contract_identifier?: InputMaybe<Scalars['String']>;
  event_index?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['Int']>;
  index_block_hash?: InputMaybe<Scalars['bytea']>;
  microblock_canonical?: InputMaybe<Scalars['Boolean']>;
  microblock_hash?: InputMaybe<Scalars['bytea']>;
  microblock_sequence?: InputMaybe<Scalars['Int']>;
  parent_index_block_hash?: InputMaybe<Scalars['bytea']>;
  topic?: InputMaybe<Scalars['String']>;
  tx_id?: InputMaybe<Scalars['bytea']>;
  tx_index?: InputMaybe<Scalars['smallint']>;
  value?: InputMaybe<Scalars['bytea']>;
};

/** aggregate max on columns */
export type ContractLogsMaxFields = {
  __typename?: 'contract_logs_max_fields';
  block_height?: Maybe<Scalars['Int']>;
  contract_identifier?: Maybe<Scalars['String']>;
  event_index?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  microblock_sequence?: Maybe<Scalars['Int']>;
  topic?: Maybe<Scalars['String']>;
  tx_index?: Maybe<Scalars['smallint']>;
};

/** aggregate min on columns */
export type ContractLogsMinFields = {
  __typename?: 'contract_logs_min_fields';
  block_height?: Maybe<Scalars['Int']>;
  contract_identifier?: Maybe<Scalars['String']>;
  event_index?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  microblock_sequence?: Maybe<Scalars['Int']>;
  topic?: Maybe<Scalars['String']>;
  tx_index?: Maybe<Scalars['smallint']>;
};

/** response of any mutation on the table "contract_logs" */
export type ContractLogsMutationResponse = {
  __typename?: 'contract_logs_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<ContractLogs>;
};

/** on_conflict condition type for table "contract_logs" */
export type ContractLogsOnConflict = {
  constraint: ContractLogsConstraint;
  update_columns?: Array<ContractLogsUpdateColumn>;
  where?: InputMaybe<ContractLogsBoolExp>;
};

/** Ordering options when selecting data from "contract_logs". */
export type ContractLogsOrderBy = {
  block_height?: InputMaybe<OrderBy>;
  canonical?: InputMaybe<OrderBy>;
  contract_identifier?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  index_block_hash?: InputMaybe<OrderBy>;
  microblock_canonical?: InputMaybe<OrderBy>;
  microblock_hash?: InputMaybe<OrderBy>;
  microblock_sequence?: InputMaybe<OrderBy>;
  parent_index_block_hash?: InputMaybe<OrderBy>;
  topic?: InputMaybe<OrderBy>;
  tx_id?: InputMaybe<OrderBy>;
  tx_index?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: contract_logs */
export type ContractLogsPkColumnsInput = {
  id: Scalars['Int'];
};

/** select columns of table "contract_logs" */
export enum ContractLogsSelectColumn {
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  Canonical = 'canonical',
  /** column name */
  ContractIdentifier = 'contract_identifier',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  Id = 'id',
  /** column name */
  IndexBlockHash = 'index_block_hash',
  /** column name */
  MicroblockCanonical = 'microblock_canonical',
  /** column name */
  MicroblockHash = 'microblock_hash',
  /** column name */
  MicroblockSequence = 'microblock_sequence',
  /** column name */
  ParentIndexBlockHash = 'parent_index_block_hash',
  /** column name */
  Topic = 'topic',
  /** column name */
  TxId = 'tx_id',
  /** column name */
  TxIndex = 'tx_index',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "contract_logs" */
export type ContractLogsSetInput = {
  block_height?: InputMaybe<Scalars['Int']>;
  canonical?: InputMaybe<Scalars['Boolean']>;
  contract_identifier?: InputMaybe<Scalars['String']>;
  event_index?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['Int']>;
  index_block_hash?: InputMaybe<Scalars['bytea']>;
  microblock_canonical?: InputMaybe<Scalars['Boolean']>;
  microblock_hash?: InputMaybe<Scalars['bytea']>;
  microblock_sequence?: InputMaybe<Scalars['Int']>;
  parent_index_block_hash?: InputMaybe<Scalars['bytea']>;
  topic?: InputMaybe<Scalars['String']>;
  tx_id?: InputMaybe<Scalars['bytea']>;
  tx_index?: InputMaybe<Scalars['smallint']>;
  value?: InputMaybe<Scalars['bytea']>;
};

/** aggregate stddev on columns */
export type ContractLogsStddevFields = {
  __typename?: 'contract_logs_stddev_fields';
  block_height?: Maybe<Scalars['Float']>;
  event_index?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type ContractLogsStddevPopFields = {
  __typename?: 'contract_logs_stddev_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  event_index?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type ContractLogsStddevSampFields = {
  __typename?: 'contract_logs_stddev_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  event_index?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "contract_logs" */
export type ContractLogsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: ContractLogsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ContractLogsStreamCursorValueInput = {
  block_height?: InputMaybe<Scalars['Int']>;
  canonical?: InputMaybe<Scalars['Boolean']>;
  contract_identifier?: InputMaybe<Scalars['String']>;
  event_index?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['Int']>;
  index_block_hash?: InputMaybe<Scalars['bytea']>;
  microblock_canonical?: InputMaybe<Scalars['Boolean']>;
  microblock_hash?: InputMaybe<Scalars['bytea']>;
  microblock_sequence?: InputMaybe<Scalars['Int']>;
  parent_index_block_hash?: InputMaybe<Scalars['bytea']>;
  topic?: InputMaybe<Scalars['String']>;
  tx_id?: InputMaybe<Scalars['bytea']>;
  tx_index?: InputMaybe<Scalars['smallint']>;
  value?: InputMaybe<Scalars['bytea']>;
};

/** aggregate sum on columns */
export type ContractLogsSumFields = {
  __typename?: 'contract_logs_sum_fields';
  block_height?: Maybe<Scalars['Int']>;
  event_index?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  microblock_sequence?: Maybe<Scalars['Int']>;
  tx_index?: Maybe<Scalars['smallint']>;
};

/** update columns of table "contract_logs" */
export enum ContractLogsUpdateColumn {
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  Canonical = 'canonical',
  /** column name */
  ContractIdentifier = 'contract_identifier',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  Id = 'id',
  /** column name */
  IndexBlockHash = 'index_block_hash',
  /** column name */
  MicroblockCanonical = 'microblock_canonical',
  /** column name */
  MicroblockHash = 'microblock_hash',
  /** column name */
  MicroblockSequence = 'microblock_sequence',
  /** column name */
  ParentIndexBlockHash = 'parent_index_block_hash',
  /** column name */
  Topic = 'topic',
  /** column name */
  TxId = 'tx_id',
  /** column name */
  TxIndex = 'tx_index',
  /** column name */
  Value = 'value'
}

export type ContractLogsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ContractLogsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ContractLogsSetInput>;
  where: ContractLogsBoolExp;
};

/** aggregate var_pop on columns */
export type ContractLogsVarPopFields = {
  __typename?: 'contract_logs_var_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  event_index?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type ContractLogsVarSampFields = {
  __typename?: 'contract_logs_var_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  event_index?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type ContractLogsVarianceFields = {
  __typename?: 'contract_logs_variance_fields';
  block_height?: Maybe<Scalars['Float']>;
  event_index?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
};

/** ordering argument of a cursor */
export enum CursorOrdering {
  /** ascending ordering of the cursor */
  Asc = 'ASC',
  /** descending ordering of the cursor */
  Desc = 'DESC'
}

/** Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'. */
export type Float8ComparisonExp = {
  _eq?: InputMaybe<Scalars['float8']>;
  _gt?: InputMaybe<Scalars['float8']>;
  _gte?: InputMaybe<Scalars['float8']>;
  _in?: InputMaybe<Array<Scalars['float8']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['float8']>;
  _lte?: InputMaybe<Scalars['float8']>;
  _neq?: InputMaybe<Scalars['float8']>;
  _nin?: InputMaybe<Array<Scalars['float8']>>;
};

/** columns and relationships of "ft_events" */
export type FtEvents = {
  __typename?: 'ft_events';
  amount: Scalars['numeric'];
  asset_event_type_id: Scalars['smallint'];
  asset_identifier: Scalars['String'];
  block_height: Scalars['Int'];
  canonical: Scalars['Boolean'];
  event_index: Scalars['Int'];
  id: Scalars['Int'];
  index_block_hash: Scalars['bytea'];
  microblock_canonical: Scalars['Boolean'];
  microblock_hash: Scalars['bytea'];
  microblock_sequence: Scalars['Int'];
  parent_index_block_hash: Scalars['bytea'];
  recipient?: Maybe<Scalars['String']>;
  sender?: Maybe<Scalars['String']>;
  tx_id: Scalars['bytea'];
  tx_index: Scalars['smallint'];
};

/** aggregated selection of "ft_events" */
export type FtEventsAggregate = {
  __typename?: 'ft_events_aggregate';
  aggregate?: Maybe<FtEventsAggregateFields>;
  nodes: Array<FtEvents>;
};

/** aggregate fields of "ft_events" */
export type FtEventsAggregateFields = {
  __typename?: 'ft_events_aggregate_fields';
  avg?: Maybe<FtEventsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<FtEventsMaxFields>;
  min?: Maybe<FtEventsMinFields>;
  stddev?: Maybe<FtEventsStddevFields>;
  stddev_pop?: Maybe<FtEventsStddevPopFields>;
  stddev_samp?: Maybe<FtEventsStddevSampFields>;
  sum?: Maybe<FtEventsSumFields>;
  var_pop?: Maybe<FtEventsVarPopFields>;
  var_samp?: Maybe<FtEventsVarSampFields>;
  variance?: Maybe<FtEventsVarianceFields>;
};


/** aggregate fields of "ft_events" */
export type FtEventsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<FtEventsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type FtEventsAvgFields = {
  __typename?: 'ft_events_avg_fields';
  amount?: Maybe<Scalars['Float']>;
  asset_event_type_id?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  event_index?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "ft_events". All fields are combined with a logical 'AND'. */
export type FtEventsBoolExp = {
  _and?: InputMaybe<Array<FtEventsBoolExp>>;
  _not?: InputMaybe<FtEventsBoolExp>;
  _or?: InputMaybe<Array<FtEventsBoolExp>>;
  amount?: InputMaybe<NumericComparisonExp>;
  asset_event_type_id?: InputMaybe<SmallintComparisonExp>;
  asset_identifier?: InputMaybe<StringComparisonExp>;
  block_height?: InputMaybe<IntComparisonExp>;
  canonical?: InputMaybe<BooleanComparisonExp>;
  event_index?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  index_block_hash?: InputMaybe<ByteaComparisonExp>;
  microblock_canonical?: InputMaybe<BooleanComparisonExp>;
  microblock_hash?: InputMaybe<ByteaComparisonExp>;
  microblock_sequence?: InputMaybe<IntComparisonExp>;
  parent_index_block_hash?: InputMaybe<ByteaComparisonExp>;
  recipient?: InputMaybe<StringComparisonExp>;
  sender?: InputMaybe<StringComparisonExp>;
  tx_id?: InputMaybe<ByteaComparisonExp>;
  tx_index?: InputMaybe<SmallintComparisonExp>;
};

/** unique or primary key constraints on table "ft_events" */
export enum FtEventsConstraint {
  /** unique or primary key constraint on columns "id" */
  FtEventsPkey = 'ft_events_pkey'
}

/** input type for incrementing numeric columns in table "ft_events" */
export type FtEventsIncInput = {
  amount?: InputMaybe<Scalars['numeric']>;
  asset_event_type_id?: InputMaybe<Scalars['smallint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  event_index?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['Int']>;
  microblock_sequence?: InputMaybe<Scalars['Int']>;
  tx_index?: InputMaybe<Scalars['smallint']>;
};

/** input type for inserting data into table "ft_events" */
export type FtEventsInsertInput = {
  amount?: InputMaybe<Scalars['numeric']>;
  asset_event_type_id?: InputMaybe<Scalars['smallint']>;
  asset_identifier?: InputMaybe<Scalars['String']>;
  block_height?: InputMaybe<Scalars['Int']>;
  canonical?: InputMaybe<Scalars['Boolean']>;
  event_index?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['Int']>;
  index_block_hash?: InputMaybe<Scalars['bytea']>;
  microblock_canonical?: InputMaybe<Scalars['Boolean']>;
  microblock_hash?: InputMaybe<Scalars['bytea']>;
  microblock_sequence?: InputMaybe<Scalars['Int']>;
  parent_index_block_hash?: InputMaybe<Scalars['bytea']>;
  recipient?: InputMaybe<Scalars['String']>;
  sender?: InputMaybe<Scalars['String']>;
  tx_id?: InputMaybe<Scalars['bytea']>;
  tx_index?: InputMaybe<Scalars['smallint']>;
};

/** aggregate max on columns */
export type FtEventsMaxFields = {
  __typename?: 'ft_events_max_fields';
  amount?: Maybe<Scalars['numeric']>;
  asset_event_type_id?: Maybe<Scalars['smallint']>;
  asset_identifier?: Maybe<Scalars['String']>;
  block_height?: Maybe<Scalars['Int']>;
  event_index?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  microblock_sequence?: Maybe<Scalars['Int']>;
  recipient?: Maybe<Scalars['String']>;
  sender?: Maybe<Scalars['String']>;
  tx_index?: Maybe<Scalars['smallint']>;
};

/** aggregate min on columns */
export type FtEventsMinFields = {
  __typename?: 'ft_events_min_fields';
  amount?: Maybe<Scalars['numeric']>;
  asset_event_type_id?: Maybe<Scalars['smallint']>;
  asset_identifier?: Maybe<Scalars['String']>;
  block_height?: Maybe<Scalars['Int']>;
  event_index?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  microblock_sequence?: Maybe<Scalars['Int']>;
  recipient?: Maybe<Scalars['String']>;
  sender?: Maybe<Scalars['String']>;
  tx_index?: Maybe<Scalars['smallint']>;
};

/** response of any mutation on the table "ft_events" */
export type FtEventsMutationResponse = {
  __typename?: 'ft_events_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<FtEvents>;
};

/** on_conflict condition type for table "ft_events" */
export type FtEventsOnConflict = {
  constraint: FtEventsConstraint;
  update_columns?: Array<FtEventsUpdateColumn>;
  where?: InputMaybe<FtEventsBoolExp>;
};

/** Ordering options when selecting data from "ft_events". */
export type FtEventsOrderBy = {
  amount?: InputMaybe<OrderBy>;
  asset_event_type_id?: InputMaybe<OrderBy>;
  asset_identifier?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  canonical?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  index_block_hash?: InputMaybe<OrderBy>;
  microblock_canonical?: InputMaybe<OrderBy>;
  microblock_hash?: InputMaybe<OrderBy>;
  microblock_sequence?: InputMaybe<OrderBy>;
  parent_index_block_hash?: InputMaybe<OrderBy>;
  recipient?: InputMaybe<OrderBy>;
  sender?: InputMaybe<OrderBy>;
  tx_id?: InputMaybe<OrderBy>;
  tx_index?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: ft_events */
export type FtEventsPkColumnsInput = {
  id: Scalars['Int'];
};

/** select columns of table "ft_events" */
export enum FtEventsSelectColumn {
  /** column name */
  Amount = 'amount',
  /** column name */
  AssetEventTypeId = 'asset_event_type_id',
  /** column name */
  AssetIdentifier = 'asset_identifier',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  Canonical = 'canonical',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  Id = 'id',
  /** column name */
  IndexBlockHash = 'index_block_hash',
  /** column name */
  MicroblockCanonical = 'microblock_canonical',
  /** column name */
  MicroblockHash = 'microblock_hash',
  /** column name */
  MicroblockSequence = 'microblock_sequence',
  /** column name */
  ParentIndexBlockHash = 'parent_index_block_hash',
  /** column name */
  Recipient = 'recipient',
  /** column name */
  Sender = 'sender',
  /** column name */
  TxId = 'tx_id',
  /** column name */
  TxIndex = 'tx_index'
}

/** input type for updating data in table "ft_events" */
export type FtEventsSetInput = {
  amount?: InputMaybe<Scalars['numeric']>;
  asset_event_type_id?: InputMaybe<Scalars['smallint']>;
  asset_identifier?: InputMaybe<Scalars['String']>;
  block_height?: InputMaybe<Scalars['Int']>;
  canonical?: InputMaybe<Scalars['Boolean']>;
  event_index?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['Int']>;
  index_block_hash?: InputMaybe<Scalars['bytea']>;
  microblock_canonical?: InputMaybe<Scalars['Boolean']>;
  microblock_hash?: InputMaybe<Scalars['bytea']>;
  microblock_sequence?: InputMaybe<Scalars['Int']>;
  parent_index_block_hash?: InputMaybe<Scalars['bytea']>;
  recipient?: InputMaybe<Scalars['String']>;
  sender?: InputMaybe<Scalars['String']>;
  tx_id?: InputMaybe<Scalars['bytea']>;
  tx_index?: InputMaybe<Scalars['smallint']>;
};

/** aggregate stddev on columns */
export type FtEventsStddevFields = {
  __typename?: 'ft_events_stddev_fields';
  amount?: Maybe<Scalars['Float']>;
  asset_event_type_id?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  event_index?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type FtEventsStddevPopFields = {
  __typename?: 'ft_events_stddev_pop_fields';
  amount?: Maybe<Scalars['Float']>;
  asset_event_type_id?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  event_index?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type FtEventsStddevSampFields = {
  __typename?: 'ft_events_stddev_samp_fields';
  amount?: Maybe<Scalars['Float']>;
  asset_event_type_id?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  event_index?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "ft_events" */
export type FtEventsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: FtEventsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type FtEventsStreamCursorValueInput = {
  amount?: InputMaybe<Scalars['numeric']>;
  asset_event_type_id?: InputMaybe<Scalars['smallint']>;
  asset_identifier?: InputMaybe<Scalars['String']>;
  block_height?: InputMaybe<Scalars['Int']>;
  canonical?: InputMaybe<Scalars['Boolean']>;
  event_index?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['Int']>;
  index_block_hash?: InputMaybe<Scalars['bytea']>;
  microblock_canonical?: InputMaybe<Scalars['Boolean']>;
  microblock_hash?: InputMaybe<Scalars['bytea']>;
  microblock_sequence?: InputMaybe<Scalars['Int']>;
  parent_index_block_hash?: InputMaybe<Scalars['bytea']>;
  recipient?: InputMaybe<Scalars['String']>;
  sender?: InputMaybe<Scalars['String']>;
  tx_id?: InputMaybe<Scalars['bytea']>;
  tx_index?: InputMaybe<Scalars['smallint']>;
};

/** aggregate sum on columns */
export type FtEventsSumFields = {
  __typename?: 'ft_events_sum_fields';
  amount?: Maybe<Scalars['numeric']>;
  asset_event_type_id?: Maybe<Scalars['smallint']>;
  block_height?: Maybe<Scalars['Int']>;
  event_index?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  microblock_sequence?: Maybe<Scalars['Int']>;
  tx_index?: Maybe<Scalars['smallint']>;
};

/** update columns of table "ft_events" */
export enum FtEventsUpdateColumn {
  /** column name */
  Amount = 'amount',
  /** column name */
  AssetEventTypeId = 'asset_event_type_id',
  /** column name */
  AssetIdentifier = 'asset_identifier',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  Canonical = 'canonical',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  Id = 'id',
  /** column name */
  IndexBlockHash = 'index_block_hash',
  /** column name */
  MicroblockCanonical = 'microblock_canonical',
  /** column name */
  MicroblockHash = 'microblock_hash',
  /** column name */
  MicroblockSequence = 'microblock_sequence',
  /** column name */
  ParentIndexBlockHash = 'parent_index_block_hash',
  /** column name */
  Recipient = 'recipient',
  /** column name */
  Sender = 'sender',
  /** column name */
  TxId = 'tx_id',
  /** column name */
  TxIndex = 'tx_index'
}

export type FtEventsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<FtEventsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<FtEventsSetInput>;
  where: FtEventsBoolExp;
};

/** aggregate var_pop on columns */
export type FtEventsVarPopFields = {
  __typename?: 'ft_events_var_pop_fields';
  amount?: Maybe<Scalars['Float']>;
  asset_event_type_id?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  event_index?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type FtEventsVarSampFields = {
  __typename?: 'ft_events_var_samp_fields';
  amount?: Maybe<Scalars['Float']>;
  asset_event_type_id?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  event_index?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type FtEventsVarianceFields = {
  __typename?: 'ft_events_variance_fields';
  amount?: Maybe<Scalars['Float']>;
  asset_event_type_id?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  event_index?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
};

export type JsonbCastExp = {
  String?: InputMaybe<StringComparisonExp>;
};

/** Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'. */
export type JsonbComparisonExp = {
  _cast?: InputMaybe<JsonbCastExp>;
  /** is the column contained in the given json value */
  _contained_in?: InputMaybe<Scalars['jsonb']>;
  /** does the column contain the given json value at the top level */
  _contains?: InputMaybe<Scalars['jsonb']>;
  _eq?: InputMaybe<Scalars['jsonb']>;
  _gt?: InputMaybe<Scalars['jsonb']>;
  _gte?: InputMaybe<Scalars['jsonb']>;
  /** does the string exist as a top-level key in the column */
  _has_key?: InputMaybe<Scalars['String']>;
  /** do all of these strings exist as top-level keys in the column */
  _has_keys_all?: InputMaybe<Array<Scalars['String']>>;
  /** do any of these strings exist as top-level keys in the column */
  _has_keys_any?: InputMaybe<Array<Scalars['String']>>;
  _in?: InputMaybe<Array<Scalars['jsonb']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['jsonb']>;
  _lte?: InputMaybe<Scalars['jsonb']>;
  _neq?: InputMaybe<Scalars['jsonb']>;
  _nin?: InputMaybe<Array<Scalars['jsonb']>>;
};

/** Contract alex-reserve-pool per-block data */
export type LaplaceAlexReservePools = {
  __typename?: 'laplace_alex_reserve_pools';
  activation_block: Scalars['Int'];
  apower_multiplier: Scalars['bigint'];
  block_height: Scalars['Int'];
  coinbase_amount_1: Scalars['bigint'];
  coinbase_amount_2: Scalars['bigint'];
  coinbase_amount_3: Scalars['bigint'];
  coinbase_amount_4: Scalars['bigint'];
  coinbase_amount_5: Scalars['bigint'];
  current_cycle: Scalars['Int'];
  dual_yield_token_deployer_address?: Maybe<Scalars['String']>;
  dual_yield_token_multiplier?: Maybe<Scalars['bigint']>;
  dual_yield_token_name?: Maybe<Scalars['String']>;
  reserved_balance: Scalars['bigint'];
  reward_cycle_length: Scalars['Int'];
  /** array of 32 uint, starting from current cycle */
  staking_stats: Scalars['jsonb'];
  sync_at: Scalars['timestamptz'];
  token_deployer_address: Scalars['String'];
  token_halving_cycle: Scalars['Int'];
  token_name: Scalars['String'];
};


/** Contract alex-reserve-pool per-block data */
export type LaplaceAlexReservePoolsStakingStatsArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "laplace.alex_reserve_pools" */
export type LaplaceAlexReservePoolsAggregate = {
  __typename?: 'laplace_alex_reserve_pools_aggregate';
  aggregate?: Maybe<LaplaceAlexReservePoolsAggregateFields>;
  nodes: Array<LaplaceAlexReservePools>;
};

/** aggregate fields of "laplace.alex_reserve_pools" */
export type LaplaceAlexReservePoolsAggregateFields = {
  __typename?: 'laplace_alex_reserve_pools_aggregate_fields';
  avg?: Maybe<LaplaceAlexReservePoolsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceAlexReservePoolsMaxFields>;
  min?: Maybe<LaplaceAlexReservePoolsMinFields>;
  stddev?: Maybe<LaplaceAlexReservePoolsStddevFields>;
  stddev_pop?: Maybe<LaplaceAlexReservePoolsStddevPopFields>;
  stddev_samp?: Maybe<LaplaceAlexReservePoolsStddevSampFields>;
  sum?: Maybe<LaplaceAlexReservePoolsSumFields>;
  var_pop?: Maybe<LaplaceAlexReservePoolsVarPopFields>;
  var_samp?: Maybe<LaplaceAlexReservePoolsVarSampFields>;
  variance?: Maybe<LaplaceAlexReservePoolsVarianceFields>;
};


/** aggregate fields of "laplace.alex_reserve_pools" */
export type LaplaceAlexReservePoolsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceAlexReservePoolsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type LaplaceAlexReservePoolsAppendInput = {
  /** array of 32 uint, starting from current cycle */
  staking_stats?: InputMaybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type LaplaceAlexReservePoolsAvgFields = {
  __typename?: 'laplace_alex_reserve_pools_avg_fields';
  activation_block?: Maybe<Scalars['Float']>;
  apower_multiplier?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  coinbase_amount_1?: Maybe<Scalars['Float']>;
  coinbase_amount_2?: Maybe<Scalars['Float']>;
  coinbase_amount_3?: Maybe<Scalars['Float']>;
  coinbase_amount_4?: Maybe<Scalars['Float']>;
  coinbase_amount_5?: Maybe<Scalars['Float']>;
  current_cycle?: Maybe<Scalars['Float']>;
  dual_yield_token_multiplier?: Maybe<Scalars['Float']>;
  reserved_balance?: Maybe<Scalars['Float']>;
  reward_cycle_length?: Maybe<Scalars['Float']>;
  token_halving_cycle?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.alex_reserve_pools". All fields are combined with a logical 'AND'. */
export type LaplaceAlexReservePoolsBoolExp = {
  _and?: InputMaybe<Array<LaplaceAlexReservePoolsBoolExp>>;
  _not?: InputMaybe<LaplaceAlexReservePoolsBoolExp>;
  _or?: InputMaybe<Array<LaplaceAlexReservePoolsBoolExp>>;
  activation_block?: InputMaybe<IntComparisonExp>;
  apower_multiplier?: InputMaybe<BigintComparisonExp>;
  block_height?: InputMaybe<IntComparisonExp>;
  coinbase_amount_1?: InputMaybe<BigintComparisonExp>;
  coinbase_amount_2?: InputMaybe<BigintComparisonExp>;
  coinbase_amount_3?: InputMaybe<BigintComparisonExp>;
  coinbase_amount_4?: InputMaybe<BigintComparisonExp>;
  coinbase_amount_5?: InputMaybe<BigintComparisonExp>;
  current_cycle?: InputMaybe<IntComparisonExp>;
  dual_yield_token_deployer_address?: InputMaybe<StringComparisonExp>;
  dual_yield_token_multiplier?: InputMaybe<BigintComparisonExp>;
  dual_yield_token_name?: InputMaybe<StringComparisonExp>;
  reserved_balance?: InputMaybe<BigintComparisonExp>;
  reward_cycle_length?: InputMaybe<IntComparisonExp>;
  staking_stats?: InputMaybe<JsonbComparisonExp>;
  sync_at?: InputMaybe<TimestamptzComparisonExp>;
  token_deployer_address?: InputMaybe<StringComparisonExp>;
  token_halving_cycle?: InputMaybe<IntComparisonExp>;
  token_name?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "laplace.alex_reserve_pools" */
export enum LaplaceAlexReservePoolsConstraint {
  /** unique or primary key constraint on columns "block_height", "token_name", "token_deployer_address" */
  AlexReservePoolsPkey = 'alex_reserve_pools_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type LaplaceAlexReservePoolsDeleteAtPathInput = {
  /** array of 32 uint, starting from current cycle */
  staking_stats?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type LaplaceAlexReservePoolsDeleteElemInput = {
  /** array of 32 uint, starting from current cycle */
  staking_stats?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type LaplaceAlexReservePoolsDeleteKeyInput = {
  /** array of 32 uint, starting from current cycle */
  staking_stats?: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "laplace.alex_reserve_pools" */
export type LaplaceAlexReservePoolsIncInput = {
  activation_block?: InputMaybe<Scalars['Int']>;
  apower_multiplier?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  coinbase_amount_1?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_2?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_3?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_4?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_5?: InputMaybe<Scalars['bigint']>;
  current_cycle?: InputMaybe<Scalars['Int']>;
  dual_yield_token_multiplier?: InputMaybe<Scalars['bigint']>;
  reserved_balance?: InputMaybe<Scalars['bigint']>;
  reward_cycle_length?: InputMaybe<Scalars['Int']>;
  token_halving_cycle?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "laplace.alex_reserve_pools" */
export type LaplaceAlexReservePoolsInsertInput = {
  activation_block?: InputMaybe<Scalars['Int']>;
  apower_multiplier?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  coinbase_amount_1?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_2?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_3?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_4?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_5?: InputMaybe<Scalars['bigint']>;
  current_cycle?: InputMaybe<Scalars['Int']>;
  dual_yield_token_deployer_address?: InputMaybe<Scalars['String']>;
  dual_yield_token_multiplier?: InputMaybe<Scalars['bigint']>;
  dual_yield_token_name?: InputMaybe<Scalars['String']>;
  reserved_balance?: InputMaybe<Scalars['bigint']>;
  reward_cycle_length?: InputMaybe<Scalars['Int']>;
  /** array of 32 uint, starting from current cycle */
  staking_stats?: InputMaybe<Scalars['jsonb']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_deployer_address?: InputMaybe<Scalars['String']>;
  token_halving_cycle?: InputMaybe<Scalars['Int']>;
  token_name?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type LaplaceAlexReservePoolsMaxFields = {
  __typename?: 'laplace_alex_reserve_pools_max_fields';
  activation_block?: Maybe<Scalars['Int']>;
  apower_multiplier?: Maybe<Scalars['bigint']>;
  block_height?: Maybe<Scalars['Int']>;
  coinbase_amount_1?: Maybe<Scalars['bigint']>;
  coinbase_amount_2?: Maybe<Scalars['bigint']>;
  coinbase_amount_3?: Maybe<Scalars['bigint']>;
  coinbase_amount_4?: Maybe<Scalars['bigint']>;
  coinbase_amount_5?: Maybe<Scalars['bigint']>;
  current_cycle?: Maybe<Scalars['Int']>;
  dual_yield_token_deployer_address?: Maybe<Scalars['String']>;
  dual_yield_token_multiplier?: Maybe<Scalars['bigint']>;
  dual_yield_token_name?: Maybe<Scalars['String']>;
  reserved_balance?: Maybe<Scalars['bigint']>;
  reward_cycle_length?: Maybe<Scalars['Int']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_deployer_address?: Maybe<Scalars['String']>;
  token_halving_cycle?: Maybe<Scalars['Int']>;
  token_name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LaplaceAlexReservePoolsMinFields = {
  __typename?: 'laplace_alex_reserve_pools_min_fields';
  activation_block?: Maybe<Scalars['Int']>;
  apower_multiplier?: Maybe<Scalars['bigint']>;
  block_height?: Maybe<Scalars['Int']>;
  coinbase_amount_1?: Maybe<Scalars['bigint']>;
  coinbase_amount_2?: Maybe<Scalars['bigint']>;
  coinbase_amount_3?: Maybe<Scalars['bigint']>;
  coinbase_amount_4?: Maybe<Scalars['bigint']>;
  coinbase_amount_5?: Maybe<Scalars['bigint']>;
  current_cycle?: Maybe<Scalars['Int']>;
  dual_yield_token_deployer_address?: Maybe<Scalars['String']>;
  dual_yield_token_multiplier?: Maybe<Scalars['bigint']>;
  dual_yield_token_name?: Maybe<Scalars['String']>;
  reserved_balance?: Maybe<Scalars['bigint']>;
  reward_cycle_length?: Maybe<Scalars['Int']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_deployer_address?: Maybe<Scalars['String']>;
  token_halving_cycle?: Maybe<Scalars['Int']>;
  token_name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "laplace.alex_reserve_pools" */
export type LaplaceAlexReservePoolsMutationResponse = {
  __typename?: 'laplace_alex_reserve_pools_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceAlexReservePools>;
};

/** on_conflict condition type for table "laplace.alex_reserve_pools" */
export type LaplaceAlexReservePoolsOnConflict = {
  constraint: LaplaceAlexReservePoolsConstraint;
  update_columns?: Array<LaplaceAlexReservePoolsUpdateColumn>;
  where?: InputMaybe<LaplaceAlexReservePoolsBoolExp>;
};

/** Ordering options when selecting data from "laplace.alex_reserve_pools". */
export type LaplaceAlexReservePoolsOrderBy = {
  activation_block?: InputMaybe<OrderBy>;
  apower_multiplier?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  coinbase_amount_1?: InputMaybe<OrderBy>;
  coinbase_amount_2?: InputMaybe<OrderBy>;
  coinbase_amount_3?: InputMaybe<OrderBy>;
  coinbase_amount_4?: InputMaybe<OrderBy>;
  coinbase_amount_5?: InputMaybe<OrderBy>;
  current_cycle?: InputMaybe<OrderBy>;
  dual_yield_token_deployer_address?: InputMaybe<OrderBy>;
  dual_yield_token_multiplier?: InputMaybe<OrderBy>;
  dual_yield_token_name?: InputMaybe<OrderBy>;
  reserved_balance?: InputMaybe<OrderBy>;
  reward_cycle_length?: InputMaybe<OrderBy>;
  staking_stats?: InputMaybe<OrderBy>;
  sync_at?: InputMaybe<OrderBy>;
  token_deployer_address?: InputMaybe<OrderBy>;
  token_halving_cycle?: InputMaybe<OrderBy>;
  token_name?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.alex_reserve_pools */
export type LaplaceAlexReservePoolsPkColumnsInput = {
  block_height: Scalars['Int'];
  token_deployer_address: Scalars['String'];
  token_name: Scalars['String'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type LaplaceAlexReservePoolsPrependInput = {
  /** array of 32 uint, starting from current cycle */
  staking_stats?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "laplace.alex_reserve_pools" */
export enum LaplaceAlexReservePoolsSelectColumn {
  /** column name */
  ActivationBlock = 'activation_block',
  /** column name */
  ApowerMultiplier = 'apower_multiplier',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  CoinbaseAmount_1 = 'coinbase_amount_1',
  /** column name */
  CoinbaseAmount_2 = 'coinbase_amount_2',
  /** column name */
  CoinbaseAmount_3 = 'coinbase_amount_3',
  /** column name */
  CoinbaseAmount_4 = 'coinbase_amount_4',
  /** column name */
  CoinbaseAmount_5 = 'coinbase_amount_5',
  /** column name */
  CurrentCycle = 'current_cycle',
  /** column name */
  DualYieldTokenDeployerAddress = 'dual_yield_token_deployer_address',
  /** column name */
  DualYieldTokenMultiplier = 'dual_yield_token_multiplier',
  /** column name */
  DualYieldTokenName = 'dual_yield_token_name',
  /** column name */
  ReservedBalance = 'reserved_balance',
  /** column name */
  RewardCycleLength = 'reward_cycle_length',
  /** column name */
  StakingStats = 'staking_stats',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenDeployerAddress = 'token_deployer_address',
  /** column name */
  TokenHalvingCycle = 'token_halving_cycle',
  /** column name */
  TokenName = 'token_name'
}

/** input type for updating data in table "laplace.alex_reserve_pools" */
export type LaplaceAlexReservePoolsSetInput = {
  activation_block?: InputMaybe<Scalars['Int']>;
  apower_multiplier?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  coinbase_amount_1?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_2?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_3?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_4?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_5?: InputMaybe<Scalars['bigint']>;
  current_cycle?: InputMaybe<Scalars['Int']>;
  dual_yield_token_deployer_address?: InputMaybe<Scalars['String']>;
  dual_yield_token_multiplier?: InputMaybe<Scalars['bigint']>;
  dual_yield_token_name?: InputMaybe<Scalars['String']>;
  reserved_balance?: InputMaybe<Scalars['bigint']>;
  reward_cycle_length?: InputMaybe<Scalars['Int']>;
  /** array of 32 uint, starting from current cycle */
  staking_stats?: InputMaybe<Scalars['jsonb']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_deployer_address?: InputMaybe<Scalars['String']>;
  token_halving_cycle?: InputMaybe<Scalars['Int']>;
  token_name?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type LaplaceAlexReservePoolsStddevFields = {
  __typename?: 'laplace_alex_reserve_pools_stddev_fields';
  activation_block?: Maybe<Scalars['Float']>;
  apower_multiplier?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  coinbase_amount_1?: Maybe<Scalars['Float']>;
  coinbase_amount_2?: Maybe<Scalars['Float']>;
  coinbase_amount_3?: Maybe<Scalars['Float']>;
  coinbase_amount_4?: Maybe<Scalars['Float']>;
  coinbase_amount_5?: Maybe<Scalars['Float']>;
  current_cycle?: Maybe<Scalars['Float']>;
  dual_yield_token_multiplier?: Maybe<Scalars['Float']>;
  reserved_balance?: Maybe<Scalars['Float']>;
  reward_cycle_length?: Maybe<Scalars['Float']>;
  token_halving_cycle?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceAlexReservePoolsStddevPopFields = {
  __typename?: 'laplace_alex_reserve_pools_stddev_pop_fields';
  activation_block?: Maybe<Scalars['Float']>;
  apower_multiplier?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  coinbase_amount_1?: Maybe<Scalars['Float']>;
  coinbase_amount_2?: Maybe<Scalars['Float']>;
  coinbase_amount_3?: Maybe<Scalars['Float']>;
  coinbase_amount_4?: Maybe<Scalars['Float']>;
  coinbase_amount_5?: Maybe<Scalars['Float']>;
  current_cycle?: Maybe<Scalars['Float']>;
  dual_yield_token_multiplier?: Maybe<Scalars['Float']>;
  reserved_balance?: Maybe<Scalars['Float']>;
  reward_cycle_length?: Maybe<Scalars['Float']>;
  token_halving_cycle?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceAlexReservePoolsStddevSampFields = {
  __typename?: 'laplace_alex_reserve_pools_stddev_samp_fields';
  activation_block?: Maybe<Scalars['Float']>;
  apower_multiplier?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  coinbase_amount_1?: Maybe<Scalars['Float']>;
  coinbase_amount_2?: Maybe<Scalars['Float']>;
  coinbase_amount_3?: Maybe<Scalars['Float']>;
  coinbase_amount_4?: Maybe<Scalars['Float']>;
  coinbase_amount_5?: Maybe<Scalars['Float']>;
  current_cycle?: Maybe<Scalars['Float']>;
  dual_yield_token_multiplier?: Maybe<Scalars['Float']>;
  reserved_balance?: Maybe<Scalars['Float']>;
  reward_cycle_length?: Maybe<Scalars['Float']>;
  token_halving_cycle?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_alex_reserve_pools" */
export type LaplaceAlexReservePoolsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceAlexReservePoolsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceAlexReservePoolsStreamCursorValueInput = {
  activation_block?: InputMaybe<Scalars['Int']>;
  apower_multiplier?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  coinbase_amount_1?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_2?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_3?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_4?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_5?: InputMaybe<Scalars['bigint']>;
  current_cycle?: InputMaybe<Scalars['Int']>;
  dual_yield_token_deployer_address?: InputMaybe<Scalars['String']>;
  dual_yield_token_multiplier?: InputMaybe<Scalars['bigint']>;
  dual_yield_token_name?: InputMaybe<Scalars['String']>;
  reserved_balance?: InputMaybe<Scalars['bigint']>;
  reward_cycle_length?: InputMaybe<Scalars['Int']>;
  /** array of 32 uint, starting from current cycle */
  staking_stats?: InputMaybe<Scalars['jsonb']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_deployer_address?: InputMaybe<Scalars['String']>;
  token_halving_cycle?: InputMaybe<Scalars['Int']>;
  token_name?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type LaplaceAlexReservePoolsSumFields = {
  __typename?: 'laplace_alex_reserve_pools_sum_fields';
  activation_block?: Maybe<Scalars['Int']>;
  apower_multiplier?: Maybe<Scalars['bigint']>;
  block_height?: Maybe<Scalars['Int']>;
  coinbase_amount_1?: Maybe<Scalars['bigint']>;
  coinbase_amount_2?: Maybe<Scalars['bigint']>;
  coinbase_amount_3?: Maybe<Scalars['bigint']>;
  coinbase_amount_4?: Maybe<Scalars['bigint']>;
  coinbase_amount_5?: Maybe<Scalars['bigint']>;
  current_cycle?: Maybe<Scalars['Int']>;
  dual_yield_token_multiplier?: Maybe<Scalars['bigint']>;
  reserved_balance?: Maybe<Scalars['bigint']>;
  reward_cycle_length?: Maybe<Scalars['Int']>;
  token_halving_cycle?: Maybe<Scalars['Int']>;
};

/** update columns of table "laplace.alex_reserve_pools" */
export enum LaplaceAlexReservePoolsUpdateColumn {
  /** column name */
  ActivationBlock = 'activation_block',
  /** column name */
  ApowerMultiplier = 'apower_multiplier',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  CoinbaseAmount_1 = 'coinbase_amount_1',
  /** column name */
  CoinbaseAmount_2 = 'coinbase_amount_2',
  /** column name */
  CoinbaseAmount_3 = 'coinbase_amount_3',
  /** column name */
  CoinbaseAmount_4 = 'coinbase_amount_4',
  /** column name */
  CoinbaseAmount_5 = 'coinbase_amount_5',
  /** column name */
  CurrentCycle = 'current_cycle',
  /** column name */
  DualYieldTokenDeployerAddress = 'dual_yield_token_deployer_address',
  /** column name */
  DualYieldTokenMultiplier = 'dual_yield_token_multiplier',
  /** column name */
  DualYieldTokenName = 'dual_yield_token_name',
  /** column name */
  ReservedBalance = 'reserved_balance',
  /** column name */
  RewardCycleLength = 'reward_cycle_length',
  /** column name */
  StakingStats = 'staking_stats',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenDeployerAddress = 'token_deployer_address',
  /** column name */
  TokenHalvingCycle = 'token_halving_cycle',
  /** column name */
  TokenName = 'token_name'
}

export type LaplaceAlexReservePoolsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<LaplaceAlexReservePoolsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<LaplaceAlexReservePoolsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<LaplaceAlexReservePoolsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<LaplaceAlexReservePoolsDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceAlexReservePoolsIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<LaplaceAlexReservePoolsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceAlexReservePoolsSetInput>;
  where: LaplaceAlexReservePoolsBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceAlexReservePoolsVarPopFields = {
  __typename?: 'laplace_alex_reserve_pools_var_pop_fields';
  activation_block?: Maybe<Scalars['Float']>;
  apower_multiplier?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  coinbase_amount_1?: Maybe<Scalars['Float']>;
  coinbase_amount_2?: Maybe<Scalars['Float']>;
  coinbase_amount_3?: Maybe<Scalars['Float']>;
  coinbase_amount_4?: Maybe<Scalars['Float']>;
  coinbase_amount_5?: Maybe<Scalars['Float']>;
  current_cycle?: Maybe<Scalars['Float']>;
  dual_yield_token_multiplier?: Maybe<Scalars['Float']>;
  reserved_balance?: Maybe<Scalars['Float']>;
  reward_cycle_length?: Maybe<Scalars['Float']>;
  token_halving_cycle?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceAlexReservePoolsVarSampFields = {
  __typename?: 'laplace_alex_reserve_pools_var_samp_fields';
  activation_block?: Maybe<Scalars['Float']>;
  apower_multiplier?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  coinbase_amount_1?: Maybe<Scalars['Float']>;
  coinbase_amount_2?: Maybe<Scalars['Float']>;
  coinbase_amount_3?: Maybe<Scalars['Float']>;
  coinbase_amount_4?: Maybe<Scalars['Float']>;
  coinbase_amount_5?: Maybe<Scalars['Float']>;
  current_cycle?: Maybe<Scalars['Float']>;
  dual_yield_token_multiplier?: Maybe<Scalars['Float']>;
  reserved_balance?: Maybe<Scalars['Float']>;
  reward_cycle_length?: Maybe<Scalars['Float']>;
  token_halving_cycle?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceAlexReservePoolsVarianceFields = {
  __typename?: 'laplace_alex_reserve_pools_variance_fields';
  activation_block?: Maybe<Scalars['Float']>;
  apower_multiplier?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  coinbase_amount_1?: Maybe<Scalars['Float']>;
  coinbase_amount_2?: Maybe<Scalars['Float']>;
  coinbase_amount_3?: Maybe<Scalars['Float']>;
  coinbase_amount_4?: Maybe<Scalars['Float']>;
  coinbase_amount_5?: Maybe<Scalars['Float']>;
  current_cycle?: Maybe<Scalars['Float']>;
  dual_yield_token_multiplier?: Maybe<Scalars['Float']>;
  reserved_balance?: Maybe<Scalars['Float']>;
  reward_cycle_length?: Maybe<Scalars['Float']>;
  token_halving_cycle?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "laplace.alex_usd_pricing" */
export type LaplaceAlexUsdPricing = {
  __typename?: 'laplace_alex_usd_pricing';
  avg_price_usd?: Maybe<Scalars['float8']>;
  token?: Maybe<Scalars['String']>;
};

/** aggregated selection of "laplace.alex_usd_pricing" */
export type LaplaceAlexUsdPricingAggregate = {
  __typename?: 'laplace_alex_usd_pricing_aggregate';
  aggregate?: Maybe<LaplaceAlexUsdPricingAggregateFields>;
  nodes: Array<LaplaceAlexUsdPricing>;
};

/** aggregate fields of "laplace.alex_usd_pricing" */
export type LaplaceAlexUsdPricingAggregateFields = {
  __typename?: 'laplace_alex_usd_pricing_aggregate_fields';
  avg?: Maybe<LaplaceAlexUsdPricingAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceAlexUsdPricingMaxFields>;
  min?: Maybe<LaplaceAlexUsdPricingMinFields>;
  stddev?: Maybe<LaplaceAlexUsdPricingStddevFields>;
  stddev_pop?: Maybe<LaplaceAlexUsdPricingStddevPopFields>;
  stddev_samp?: Maybe<LaplaceAlexUsdPricingStddevSampFields>;
  sum?: Maybe<LaplaceAlexUsdPricingSumFields>;
  var_pop?: Maybe<LaplaceAlexUsdPricingVarPopFields>;
  var_samp?: Maybe<LaplaceAlexUsdPricingVarSampFields>;
  variance?: Maybe<LaplaceAlexUsdPricingVarianceFields>;
};


/** aggregate fields of "laplace.alex_usd_pricing" */
export type LaplaceAlexUsdPricingAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceAlexUsdPricingSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LaplaceAlexUsdPricingAvgFields = {
  __typename?: 'laplace_alex_usd_pricing_avg_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.alex_usd_pricing". All fields are combined with a logical 'AND'. */
export type LaplaceAlexUsdPricingBoolExp = {
  _and?: InputMaybe<Array<LaplaceAlexUsdPricingBoolExp>>;
  _not?: InputMaybe<LaplaceAlexUsdPricingBoolExp>;
  _or?: InputMaybe<Array<LaplaceAlexUsdPricingBoolExp>>;
  avg_price_usd?: InputMaybe<Float8ComparisonExp>;
  token?: InputMaybe<StringComparisonExp>;
};

/** aggregate max on columns */
export type LaplaceAlexUsdPricingMaxFields = {
  __typename?: 'laplace_alex_usd_pricing_max_fields';
  avg_price_usd?: Maybe<Scalars['float8']>;
  token?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LaplaceAlexUsdPricingMinFields = {
  __typename?: 'laplace_alex_usd_pricing_min_fields';
  avg_price_usd?: Maybe<Scalars['float8']>;
  token?: Maybe<Scalars['String']>;
};

/** Ordering options when selecting data from "laplace.alex_usd_pricing". */
export type LaplaceAlexUsdPricingOrderBy = {
  avg_price_usd?: InputMaybe<OrderBy>;
  token?: InputMaybe<OrderBy>;
};

/** select columns of table "laplace.alex_usd_pricing" */
export enum LaplaceAlexUsdPricingSelectColumn {
  /** column name */
  AvgPriceUsd = 'avg_price_usd',
  /** column name */
  Token = 'token'
}

/** aggregate stddev on columns */
export type LaplaceAlexUsdPricingStddevFields = {
  __typename?: 'laplace_alex_usd_pricing_stddev_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceAlexUsdPricingStddevPopFields = {
  __typename?: 'laplace_alex_usd_pricing_stddev_pop_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceAlexUsdPricingStddevSampFields = {
  __typename?: 'laplace_alex_usd_pricing_stddev_samp_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_alex_usd_pricing" */
export type LaplaceAlexUsdPricingStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceAlexUsdPricingStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceAlexUsdPricingStreamCursorValueInput = {
  avg_price_usd?: InputMaybe<Scalars['float8']>;
  token?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type LaplaceAlexUsdPricingSumFields = {
  __typename?: 'laplace_alex_usd_pricing_sum_fields';
  avg_price_usd?: Maybe<Scalars['float8']>;
};

/** aggregate var_pop on columns */
export type LaplaceAlexUsdPricingVarPopFields = {
  __typename?: 'laplace_alex_usd_pricing_var_pop_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceAlexUsdPricingVarSampFields = {
  __typename?: 'laplace_alex_usd_pricing_var_samp_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceAlexUsdPricingVarianceFields = {
  __typename?: 'laplace_alex_usd_pricing_variance_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** ALEX borrow and deposit daily stats for chart */
export type LaplaceBorrowDepositDailyStats = {
  __typename?: 'laplace_borrow_deposit_daily_stats';
  apr_borrow_avg: Scalars['numeric'];
  apr_deposit_avg: Scalars['numeric'];
  avg_active_crp_pool_value: Scalars['numeric'];
  block_height: Scalars['numeric'];
  burn_block_time: Scalars['numeric'];
  day: Scalars['numeric'];
  latest_active_crp_pool_value: Scalars['numeric'];
  latest_total_borrow: Scalars['numeric'];
  latest_total_deposit: Scalars['numeric'];
  max_active_crp_pool_value: Scalars['numeric'];
  max_total_borrow: Scalars['numeric'];
  max_total_deposit: Scalars['numeric'];
  pool_token: Scalars['String'];
  pool_weight_x: Scalars['numeric'];
  pool_weight_y: Scalars['numeric'];
  sync_at: Scalars['timestamptz'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
  yield_token: Scalars['String'];
};

/** aggregated selection of "laplace.borrow_deposit_daily_stats" */
export type LaplaceBorrowDepositDailyStatsAggregate = {
  __typename?: 'laplace_borrow_deposit_daily_stats_aggregate';
  aggregate?: Maybe<LaplaceBorrowDepositDailyStatsAggregateFields>;
  nodes: Array<LaplaceBorrowDepositDailyStats>;
};

/** aggregate fields of "laplace.borrow_deposit_daily_stats" */
export type LaplaceBorrowDepositDailyStatsAggregateFields = {
  __typename?: 'laplace_borrow_deposit_daily_stats_aggregate_fields';
  avg?: Maybe<LaplaceBorrowDepositDailyStatsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceBorrowDepositDailyStatsMaxFields>;
  min?: Maybe<LaplaceBorrowDepositDailyStatsMinFields>;
  stddev?: Maybe<LaplaceBorrowDepositDailyStatsStddevFields>;
  stddev_pop?: Maybe<LaplaceBorrowDepositDailyStatsStddevPopFields>;
  stddev_samp?: Maybe<LaplaceBorrowDepositDailyStatsStddevSampFields>;
  sum?: Maybe<LaplaceBorrowDepositDailyStatsSumFields>;
  var_pop?: Maybe<LaplaceBorrowDepositDailyStatsVarPopFields>;
  var_samp?: Maybe<LaplaceBorrowDepositDailyStatsVarSampFields>;
  variance?: Maybe<LaplaceBorrowDepositDailyStatsVarianceFields>;
};


/** aggregate fields of "laplace.borrow_deposit_daily_stats" */
export type LaplaceBorrowDepositDailyStatsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceBorrowDepositDailyStatsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LaplaceBorrowDepositDailyStatsAvgFields = {
  __typename?: 'laplace_borrow_deposit_daily_stats_avg_fields';
  apr_borrow_avg?: Maybe<Scalars['Float']>;
  apr_deposit_avg?: Maybe<Scalars['Float']>;
  avg_active_crp_pool_value?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  day?: Maybe<Scalars['Float']>;
  latest_active_crp_pool_value?: Maybe<Scalars['Float']>;
  latest_total_borrow?: Maybe<Scalars['Float']>;
  latest_total_deposit?: Maybe<Scalars['Float']>;
  max_active_crp_pool_value?: Maybe<Scalars['Float']>;
  max_total_borrow?: Maybe<Scalars['Float']>;
  max_total_deposit?: Maybe<Scalars['Float']>;
  pool_weight_x?: Maybe<Scalars['Float']>;
  pool_weight_y?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.borrow_deposit_daily_stats". All fields are combined with a logical 'AND'. */
export type LaplaceBorrowDepositDailyStatsBoolExp = {
  _and?: InputMaybe<Array<LaplaceBorrowDepositDailyStatsBoolExp>>;
  _not?: InputMaybe<LaplaceBorrowDepositDailyStatsBoolExp>;
  _or?: InputMaybe<Array<LaplaceBorrowDepositDailyStatsBoolExp>>;
  apr_borrow_avg?: InputMaybe<NumericComparisonExp>;
  apr_deposit_avg?: InputMaybe<NumericComparisonExp>;
  avg_active_crp_pool_value?: InputMaybe<NumericComparisonExp>;
  block_height?: InputMaybe<NumericComparisonExp>;
  burn_block_time?: InputMaybe<NumericComparisonExp>;
  day?: InputMaybe<NumericComparisonExp>;
  latest_active_crp_pool_value?: InputMaybe<NumericComparisonExp>;
  latest_total_borrow?: InputMaybe<NumericComparisonExp>;
  latest_total_deposit?: InputMaybe<NumericComparisonExp>;
  max_active_crp_pool_value?: InputMaybe<NumericComparisonExp>;
  max_total_borrow?: InputMaybe<NumericComparisonExp>;
  max_total_deposit?: InputMaybe<NumericComparisonExp>;
  pool_token?: InputMaybe<StringComparisonExp>;
  pool_weight_x?: InputMaybe<NumericComparisonExp>;
  pool_weight_y?: InputMaybe<NumericComparisonExp>;
  sync_at?: InputMaybe<TimestamptzComparisonExp>;
  token_x?: InputMaybe<StringComparisonExp>;
  token_y?: InputMaybe<StringComparisonExp>;
  yield_token?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "laplace.borrow_deposit_daily_stats" */
export enum LaplaceBorrowDepositDailyStatsConstraint {
  /** unique or primary key constraint on columns "day", "token_y", "token_x" */
  BorrowDepositDailyStatsPkey = 'borrow_deposit_daily_stats_pkey'
}

/** input type for incrementing numeric columns in table "laplace.borrow_deposit_daily_stats" */
export type LaplaceBorrowDepositDailyStatsIncInput = {
  apr_borrow_avg?: InputMaybe<Scalars['numeric']>;
  apr_deposit_avg?: InputMaybe<Scalars['numeric']>;
  avg_active_crp_pool_value?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  day?: InputMaybe<Scalars['numeric']>;
  latest_active_crp_pool_value?: InputMaybe<Scalars['numeric']>;
  latest_total_borrow?: InputMaybe<Scalars['numeric']>;
  latest_total_deposit?: InputMaybe<Scalars['numeric']>;
  max_active_crp_pool_value?: InputMaybe<Scalars['numeric']>;
  max_total_borrow?: InputMaybe<Scalars['numeric']>;
  max_total_deposit?: InputMaybe<Scalars['numeric']>;
  pool_weight_x?: InputMaybe<Scalars['numeric']>;
  pool_weight_y?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "laplace.borrow_deposit_daily_stats" */
export type LaplaceBorrowDepositDailyStatsInsertInput = {
  apr_borrow_avg?: InputMaybe<Scalars['numeric']>;
  apr_deposit_avg?: InputMaybe<Scalars['numeric']>;
  avg_active_crp_pool_value?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  day?: InputMaybe<Scalars['numeric']>;
  latest_active_crp_pool_value?: InputMaybe<Scalars['numeric']>;
  latest_total_borrow?: InputMaybe<Scalars['numeric']>;
  latest_total_deposit?: InputMaybe<Scalars['numeric']>;
  max_active_crp_pool_value?: InputMaybe<Scalars['numeric']>;
  max_total_borrow?: InputMaybe<Scalars['numeric']>;
  max_total_deposit?: InputMaybe<Scalars['numeric']>;
  pool_token?: InputMaybe<Scalars['String']>;
  pool_weight_x?: InputMaybe<Scalars['numeric']>;
  pool_weight_y?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  yield_token?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type LaplaceBorrowDepositDailyStatsMaxFields = {
  __typename?: 'laplace_borrow_deposit_daily_stats_max_fields';
  apr_borrow_avg?: Maybe<Scalars['numeric']>;
  apr_deposit_avg?: Maybe<Scalars['numeric']>;
  avg_active_crp_pool_value?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  day?: Maybe<Scalars['numeric']>;
  latest_active_crp_pool_value?: Maybe<Scalars['numeric']>;
  latest_total_borrow?: Maybe<Scalars['numeric']>;
  latest_total_deposit?: Maybe<Scalars['numeric']>;
  max_active_crp_pool_value?: Maybe<Scalars['numeric']>;
  max_total_borrow?: Maybe<Scalars['numeric']>;
  max_total_deposit?: Maybe<Scalars['numeric']>;
  pool_token?: Maybe<Scalars['String']>;
  pool_weight_x?: Maybe<Scalars['numeric']>;
  pool_weight_y?: Maybe<Scalars['numeric']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_x?: Maybe<Scalars['String']>;
  token_y?: Maybe<Scalars['String']>;
  yield_token?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LaplaceBorrowDepositDailyStatsMinFields = {
  __typename?: 'laplace_borrow_deposit_daily_stats_min_fields';
  apr_borrow_avg?: Maybe<Scalars['numeric']>;
  apr_deposit_avg?: Maybe<Scalars['numeric']>;
  avg_active_crp_pool_value?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  day?: Maybe<Scalars['numeric']>;
  latest_active_crp_pool_value?: Maybe<Scalars['numeric']>;
  latest_total_borrow?: Maybe<Scalars['numeric']>;
  latest_total_deposit?: Maybe<Scalars['numeric']>;
  max_active_crp_pool_value?: Maybe<Scalars['numeric']>;
  max_total_borrow?: Maybe<Scalars['numeric']>;
  max_total_deposit?: Maybe<Scalars['numeric']>;
  pool_token?: Maybe<Scalars['String']>;
  pool_weight_x?: Maybe<Scalars['numeric']>;
  pool_weight_y?: Maybe<Scalars['numeric']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_x?: Maybe<Scalars['String']>;
  token_y?: Maybe<Scalars['String']>;
  yield_token?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "laplace.borrow_deposit_daily_stats" */
export type LaplaceBorrowDepositDailyStatsMutationResponse = {
  __typename?: 'laplace_borrow_deposit_daily_stats_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceBorrowDepositDailyStats>;
};

/** on_conflict condition type for table "laplace.borrow_deposit_daily_stats" */
export type LaplaceBorrowDepositDailyStatsOnConflict = {
  constraint: LaplaceBorrowDepositDailyStatsConstraint;
  update_columns?: Array<LaplaceBorrowDepositDailyStatsUpdateColumn>;
  where?: InputMaybe<LaplaceBorrowDepositDailyStatsBoolExp>;
};

/** Ordering options when selecting data from "laplace.borrow_deposit_daily_stats". */
export type LaplaceBorrowDepositDailyStatsOrderBy = {
  apr_borrow_avg?: InputMaybe<OrderBy>;
  apr_deposit_avg?: InputMaybe<OrderBy>;
  avg_active_crp_pool_value?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  burn_block_time?: InputMaybe<OrderBy>;
  day?: InputMaybe<OrderBy>;
  latest_active_crp_pool_value?: InputMaybe<OrderBy>;
  latest_total_borrow?: InputMaybe<OrderBy>;
  latest_total_deposit?: InputMaybe<OrderBy>;
  max_active_crp_pool_value?: InputMaybe<OrderBy>;
  max_total_borrow?: InputMaybe<OrderBy>;
  max_total_deposit?: InputMaybe<OrderBy>;
  pool_token?: InputMaybe<OrderBy>;
  pool_weight_x?: InputMaybe<OrderBy>;
  pool_weight_y?: InputMaybe<OrderBy>;
  sync_at?: InputMaybe<OrderBy>;
  token_x?: InputMaybe<OrderBy>;
  token_y?: InputMaybe<OrderBy>;
  yield_token?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.borrow_deposit_daily_stats */
export type LaplaceBorrowDepositDailyStatsPkColumnsInput = {
  day: Scalars['numeric'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};

/** select columns of table "laplace.borrow_deposit_daily_stats" */
export enum LaplaceBorrowDepositDailyStatsSelectColumn {
  /** column name */
  AprBorrowAvg = 'apr_borrow_avg',
  /** column name */
  AprDepositAvg = 'apr_deposit_avg',
  /** column name */
  AvgActiveCrpPoolValue = 'avg_active_crp_pool_value',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  Day = 'day',
  /** column name */
  LatestActiveCrpPoolValue = 'latest_active_crp_pool_value',
  /** column name */
  LatestTotalBorrow = 'latest_total_borrow',
  /** column name */
  LatestTotalDeposit = 'latest_total_deposit',
  /** column name */
  MaxActiveCrpPoolValue = 'max_active_crp_pool_value',
  /** column name */
  MaxTotalBorrow = 'max_total_borrow',
  /** column name */
  MaxTotalDeposit = 'max_total_deposit',
  /** column name */
  PoolToken = 'pool_token',
  /** column name */
  PoolWeightX = 'pool_weight_x',
  /** column name */
  PoolWeightY = 'pool_weight_y',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenX = 'token_x',
  /** column name */
  TokenY = 'token_y',
  /** column name */
  YieldToken = 'yield_token'
}

/** input type for updating data in table "laplace.borrow_deposit_daily_stats" */
export type LaplaceBorrowDepositDailyStatsSetInput = {
  apr_borrow_avg?: InputMaybe<Scalars['numeric']>;
  apr_deposit_avg?: InputMaybe<Scalars['numeric']>;
  avg_active_crp_pool_value?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  day?: InputMaybe<Scalars['numeric']>;
  latest_active_crp_pool_value?: InputMaybe<Scalars['numeric']>;
  latest_total_borrow?: InputMaybe<Scalars['numeric']>;
  latest_total_deposit?: InputMaybe<Scalars['numeric']>;
  max_active_crp_pool_value?: InputMaybe<Scalars['numeric']>;
  max_total_borrow?: InputMaybe<Scalars['numeric']>;
  max_total_deposit?: InputMaybe<Scalars['numeric']>;
  pool_token?: InputMaybe<Scalars['String']>;
  pool_weight_x?: InputMaybe<Scalars['numeric']>;
  pool_weight_y?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  yield_token?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type LaplaceBorrowDepositDailyStatsStddevFields = {
  __typename?: 'laplace_borrow_deposit_daily_stats_stddev_fields';
  apr_borrow_avg?: Maybe<Scalars['Float']>;
  apr_deposit_avg?: Maybe<Scalars['Float']>;
  avg_active_crp_pool_value?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  day?: Maybe<Scalars['Float']>;
  latest_active_crp_pool_value?: Maybe<Scalars['Float']>;
  latest_total_borrow?: Maybe<Scalars['Float']>;
  latest_total_deposit?: Maybe<Scalars['Float']>;
  max_active_crp_pool_value?: Maybe<Scalars['Float']>;
  max_total_borrow?: Maybe<Scalars['Float']>;
  max_total_deposit?: Maybe<Scalars['Float']>;
  pool_weight_x?: Maybe<Scalars['Float']>;
  pool_weight_y?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceBorrowDepositDailyStatsStddevPopFields = {
  __typename?: 'laplace_borrow_deposit_daily_stats_stddev_pop_fields';
  apr_borrow_avg?: Maybe<Scalars['Float']>;
  apr_deposit_avg?: Maybe<Scalars['Float']>;
  avg_active_crp_pool_value?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  day?: Maybe<Scalars['Float']>;
  latest_active_crp_pool_value?: Maybe<Scalars['Float']>;
  latest_total_borrow?: Maybe<Scalars['Float']>;
  latest_total_deposit?: Maybe<Scalars['Float']>;
  max_active_crp_pool_value?: Maybe<Scalars['Float']>;
  max_total_borrow?: Maybe<Scalars['Float']>;
  max_total_deposit?: Maybe<Scalars['Float']>;
  pool_weight_x?: Maybe<Scalars['Float']>;
  pool_weight_y?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceBorrowDepositDailyStatsStddevSampFields = {
  __typename?: 'laplace_borrow_deposit_daily_stats_stddev_samp_fields';
  apr_borrow_avg?: Maybe<Scalars['Float']>;
  apr_deposit_avg?: Maybe<Scalars['Float']>;
  avg_active_crp_pool_value?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  day?: Maybe<Scalars['Float']>;
  latest_active_crp_pool_value?: Maybe<Scalars['Float']>;
  latest_total_borrow?: Maybe<Scalars['Float']>;
  latest_total_deposit?: Maybe<Scalars['Float']>;
  max_active_crp_pool_value?: Maybe<Scalars['Float']>;
  max_total_borrow?: Maybe<Scalars['Float']>;
  max_total_deposit?: Maybe<Scalars['Float']>;
  pool_weight_x?: Maybe<Scalars['Float']>;
  pool_weight_y?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_borrow_deposit_daily_stats" */
export type LaplaceBorrowDepositDailyStatsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceBorrowDepositDailyStatsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceBorrowDepositDailyStatsStreamCursorValueInput = {
  apr_borrow_avg?: InputMaybe<Scalars['numeric']>;
  apr_deposit_avg?: InputMaybe<Scalars['numeric']>;
  avg_active_crp_pool_value?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  day?: InputMaybe<Scalars['numeric']>;
  latest_active_crp_pool_value?: InputMaybe<Scalars['numeric']>;
  latest_total_borrow?: InputMaybe<Scalars['numeric']>;
  latest_total_deposit?: InputMaybe<Scalars['numeric']>;
  max_active_crp_pool_value?: InputMaybe<Scalars['numeric']>;
  max_total_borrow?: InputMaybe<Scalars['numeric']>;
  max_total_deposit?: InputMaybe<Scalars['numeric']>;
  pool_token?: InputMaybe<Scalars['String']>;
  pool_weight_x?: InputMaybe<Scalars['numeric']>;
  pool_weight_y?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  yield_token?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type LaplaceBorrowDepositDailyStatsSumFields = {
  __typename?: 'laplace_borrow_deposit_daily_stats_sum_fields';
  apr_borrow_avg?: Maybe<Scalars['numeric']>;
  apr_deposit_avg?: Maybe<Scalars['numeric']>;
  avg_active_crp_pool_value?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  day?: Maybe<Scalars['numeric']>;
  latest_active_crp_pool_value?: Maybe<Scalars['numeric']>;
  latest_total_borrow?: Maybe<Scalars['numeric']>;
  latest_total_deposit?: Maybe<Scalars['numeric']>;
  max_active_crp_pool_value?: Maybe<Scalars['numeric']>;
  max_total_borrow?: Maybe<Scalars['numeric']>;
  max_total_deposit?: Maybe<Scalars['numeric']>;
  pool_weight_x?: Maybe<Scalars['numeric']>;
  pool_weight_y?: Maybe<Scalars['numeric']>;
};

/** update columns of table "laplace.borrow_deposit_daily_stats" */
export enum LaplaceBorrowDepositDailyStatsUpdateColumn {
  /** column name */
  AprBorrowAvg = 'apr_borrow_avg',
  /** column name */
  AprDepositAvg = 'apr_deposit_avg',
  /** column name */
  AvgActiveCrpPoolValue = 'avg_active_crp_pool_value',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  Day = 'day',
  /** column name */
  LatestActiveCrpPoolValue = 'latest_active_crp_pool_value',
  /** column name */
  LatestTotalBorrow = 'latest_total_borrow',
  /** column name */
  LatestTotalDeposit = 'latest_total_deposit',
  /** column name */
  MaxActiveCrpPoolValue = 'max_active_crp_pool_value',
  /** column name */
  MaxTotalBorrow = 'max_total_borrow',
  /** column name */
  MaxTotalDeposit = 'max_total_deposit',
  /** column name */
  PoolToken = 'pool_token',
  /** column name */
  PoolWeightX = 'pool_weight_x',
  /** column name */
  PoolWeightY = 'pool_weight_y',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenX = 'token_x',
  /** column name */
  TokenY = 'token_y',
  /** column name */
  YieldToken = 'yield_token'
}

export type LaplaceBorrowDepositDailyStatsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceBorrowDepositDailyStatsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceBorrowDepositDailyStatsSetInput>;
  where: LaplaceBorrowDepositDailyStatsBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceBorrowDepositDailyStatsVarPopFields = {
  __typename?: 'laplace_borrow_deposit_daily_stats_var_pop_fields';
  apr_borrow_avg?: Maybe<Scalars['Float']>;
  apr_deposit_avg?: Maybe<Scalars['Float']>;
  avg_active_crp_pool_value?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  day?: Maybe<Scalars['Float']>;
  latest_active_crp_pool_value?: Maybe<Scalars['Float']>;
  latest_total_borrow?: Maybe<Scalars['Float']>;
  latest_total_deposit?: Maybe<Scalars['Float']>;
  max_active_crp_pool_value?: Maybe<Scalars['Float']>;
  max_total_borrow?: Maybe<Scalars['Float']>;
  max_total_deposit?: Maybe<Scalars['Float']>;
  pool_weight_x?: Maybe<Scalars['Float']>;
  pool_weight_y?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceBorrowDepositDailyStatsVarSampFields = {
  __typename?: 'laplace_borrow_deposit_daily_stats_var_samp_fields';
  apr_borrow_avg?: Maybe<Scalars['Float']>;
  apr_deposit_avg?: Maybe<Scalars['Float']>;
  avg_active_crp_pool_value?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  day?: Maybe<Scalars['Float']>;
  latest_active_crp_pool_value?: Maybe<Scalars['Float']>;
  latest_total_borrow?: Maybe<Scalars['Float']>;
  latest_total_deposit?: Maybe<Scalars['Float']>;
  max_active_crp_pool_value?: Maybe<Scalars['Float']>;
  max_total_borrow?: Maybe<Scalars['Float']>;
  max_total_deposit?: Maybe<Scalars['Float']>;
  pool_weight_x?: Maybe<Scalars['Float']>;
  pool_weight_y?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceBorrowDepositDailyStatsVarianceFields = {
  __typename?: 'laplace_borrow_deposit_daily_stats_variance_fields';
  apr_borrow_avg?: Maybe<Scalars['Float']>;
  apr_deposit_avg?: Maybe<Scalars['Float']>;
  avg_active_crp_pool_value?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  day?: Maybe<Scalars['Float']>;
  latest_active_crp_pool_value?: Maybe<Scalars['Float']>;
  latest_total_borrow?: Maybe<Scalars['Float']>;
  latest_total_deposit?: Maybe<Scalars['Float']>;
  max_active_crp_pool_value?: Maybe<Scalars['Float']>;
  max_total_borrow?: Maybe<Scalars['Float']>;
  max_total_deposit?: Maybe<Scalars['Float']>;
  pool_weight_x?: Maybe<Scalars['Float']>;
  pool_weight_y?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "laplace.borrow_deposit_hourly_stats" */
export type LaplaceBorrowDepositHourlyStats = {
  __typename?: 'laplace_borrow_deposit_hourly_stats';
  block_height: Scalars['numeric'];
  burn_block_time: Scalars['numeric'];
  collateral_per_share: Scalars['numeric'];
  est_collateral_price: Scalars['numeric'];
  expiry: Scalars['numeric'];
  hour: Scalars['numeric'];
  sync_at: Scalars['timestamptz'];
  token_per_share: Scalars['numeric'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
  value_per_share: Scalars['numeric'];
};

/** aggregated selection of "laplace.borrow_deposit_hourly_stats" */
export type LaplaceBorrowDepositHourlyStatsAggregate = {
  __typename?: 'laplace_borrow_deposit_hourly_stats_aggregate';
  aggregate?: Maybe<LaplaceBorrowDepositHourlyStatsAggregateFields>;
  nodes: Array<LaplaceBorrowDepositHourlyStats>;
};

/** aggregate fields of "laplace.borrow_deposit_hourly_stats" */
export type LaplaceBorrowDepositHourlyStatsAggregateFields = {
  __typename?: 'laplace_borrow_deposit_hourly_stats_aggregate_fields';
  avg?: Maybe<LaplaceBorrowDepositHourlyStatsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceBorrowDepositHourlyStatsMaxFields>;
  min?: Maybe<LaplaceBorrowDepositHourlyStatsMinFields>;
  stddev?: Maybe<LaplaceBorrowDepositHourlyStatsStddevFields>;
  stddev_pop?: Maybe<LaplaceBorrowDepositHourlyStatsStddevPopFields>;
  stddev_samp?: Maybe<LaplaceBorrowDepositHourlyStatsStddevSampFields>;
  sum?: Maybe<LaplaceBorrowDepositHourlyStatsSumFields>;
  var_pop?: Maybe<LaplaceBorrowDepositHourlyStatsVarPopFields>;
  var_samp?: Maybe<LaplaceBorrowDepositHourlyStatsVarSampFields>;
  variance?: Maybe<LaplaceBorrowDepositHourlyStatsVarianceFields>;
};


/** aggregate fields of "laplace.borrow_deposit_hourly_stats" */
export type LaplaceBorrowDepositHourlyStatsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceBorrowDepositHourlyStatsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LaplaceBorrowDepositHourlyStatsAvgFields = {
  __typename?: 'laplace_borrow_deposit_hourly_stats_avg_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  collateral_per_share?: Maybe<Scalars['Float']>;
  est_collateral_price?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  hour?: Maybe<Scalars['Float']>;
  token_per_share?: Maybe<Scalars['Float']>;
  value_per_share?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.borrow_deposit_hourly_stats". All fields are combined with a logical 'AND'. */
export type LaplaceBorrowDepositHourlyStatsBoolExp = {
  _and?: InputMaybe<Array<LaplaceBorrowDepositHourlyStatsBoolExp>>;
  _not?: InputMaybe<LaplaceBorrowDepositHourlyStatsBoolExp>;
  _or?: InputMaybe<Array<LaplaceBorrowDepositHourlyStatsBoolExp>>;
  block_height?: InputMaybe<NumericComparisonExp>;
  burn_block_time?: InputMaybe<NumericComparisonExp>;
  collateral_per_share?: InputMaybe<NumericComparisonExp>;
  est_collateral_price?: InputMaybe<NumericComparisonExp>;
  expiry?: InputMaybe<NumericComparisonExp>;
  hour?: InputMaybe<NumericComparisonExp>;
  sync_at?: InputMaybe<TimestamptzComparisonExp>;
  token_per_share?: InputMaybe<NumericComparisonExp>;
  token_x?: InputMaybe<StringComparisonExp>;
  token_y?: InputMaybe<StringComparisonExp>;
  value_per_share?: InputMaybe<NumericComparisonExp>;
};

/** unique or primary key constraints on table "laplace.borrow_deposit_hourly_stats" */
export enum LaplaceBorrowDepositHourlyStatsConstraint {
  /** unique or primary key constraint on columns "token_y", "expiry", "hour", "token_x" */
  BorrowDepositHourlyStatsPkey = 'borrow_deposit_hourly_stats_pkey'
}

/** input type for incrementing numeric columns in table "laplace.borrow_deposit_hourly_stats" */
export type LaplaceBorrowDepositHourlyStatsIncInput = {
  block_height?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  collateral_per_share?: InputMaybe<Scalars['numeric']>;
  est_collateral_price?: InputMaybe<Scalars['numeric']>;
  expiry?: InputMaybe<Scalars['numeric']>;
  hour?: InputMaybe<Scalars['numeric']>;
  token_per_share?: InputMaybe<Scalars['numeric']>;
  value_per_share?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "laplace.borrow_deposit_hourly_stats" */
export type LaplaceBorrowDepositHourlyStatsInsertInput = {
  block_height?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  collateral_per_share?: InputMaybe<Scalars['numeric']>;
  est_collateral_price?: InputMaybe<Scalars['numeric']>;
  expiry?: InputMaybe<Scalars['numeric']>;
  hour?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_per_share?: InputMaybe<Scalars['numeric']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  value_per_share?: InputMaybe<Scalars['numeric']>;
};

/** aggregate max on columns */
export type LaplaceBorrowDepositHourlyStatsMaxFields = {
  __typename?: 'laplace_borrow_deposit_hourly_stats_max_fields';
  block_height?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  collateral_per_share?: Maybe<Scalars['numeric']>;
  est_collateral_price?: Maybe<Scalars['numeric']>;
  expiry?: Maybe<Scalars['numeric']>;
  hour?: Maybe<Scalars['numeric']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_per_share?: Maybe<Scalars['numeric']>;
  token_x?: Maybe<Scalars['String']>;
  token_y?: Maybe<Scalars['String']>;
  value_per_share?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type LaplaceBorrowDepositHourlyStatsMinFields = {
  __typename?: 'laplace_borrow_deposit_hourly_stats_min_fields';
  block_height?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  collateral_per_share?: Maybe<Scalars['numeric']>;
  est_collateral_price?: Maybe<Scalars['numeric']>;
  expiry?: Maybe<Scalars['numeric']>;
  hour?: Maybe<Scalars['numeric']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_per_share?: Maybe<Scalars['numeric']>;
  token_x?: Maybe<Scalars['String']>;
  token_y?: Maybe<Scalars['String']>;
  value_per_share?: Maybe<Scalars['numeric']>;
};

/** response of any mutation on the table "laplace.borrow_deposit_hourly_stats" */
export type LaplaceBorrowDepositHourlyStatsMutationResponse = {
  __typename?: 'laplace_borrow_deposit_hourly_stats_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceBorrowDepositHourlyStats>;
};

/** on_conflict condition type for table "laplace.borrow_deposit_hourly_stats" */
export type LaplaceBorrowDepositHourlyStatsOnConflict = {
  constraint: LaplaceBorrowDepositHourlyStatsConstraint;
  update_columns?: Array<LaplaceBorrowDepositHourlyStatsUpdateColumn>;
  where?: InputMaybe<LaplaceBorrowDepositHourlyStatsBoolExp>;
};

/** Ordering options when selecting data from "laplace.borrow_deposit_hourly_stats". */
export type LaplaceBorrowDepositHourlyStatsOrderBy = {
  block_height?: InputMaybe<OrderBy>;
  burn_block_time?: InputMaybe<OrderBy>;
  collateral_per_share?: InputMaybe<OrderBy>;
  est_collateral_price?: InputMaybe<OrderBy>;
  expiry?: InputMaybe<OrderBy>;
  hour?: InputMaybe<OrderBy>;
  sync_at?: InputMaybe<OrderBy>;
  token_per_share?: InputMaybe<OrderBy>;
  token_x?: InputMaybe<OrderBy>;
  token_y?: InputMaybe<OrderBy>;
  value_per_share?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.borrow_deposit_hourly_stats */
export type LaplaceBorrowDepositHourlyStatsPkColumnsInput = {
  expiry: Scalars['numeric'];
  hour: Scalars['numeric'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};

/** select columns of table "laplace.borrow_deposit_hourly_stats" */
export enum LaplaceBorrowDepositHourlyStatsSelectColumn {
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  CollateralPerShare = 'collateral_per_share',
  /** column name */
  EstCollateralPrice = 'est_collateral_price',
  /** column name */
  Expiry = 'expiry',
  /** column name */
  Hour = 'hour',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenPerShare = 'token_per_share',
  /** column name */
  TokenX = 'token_x',
  /** column name */
  TokenY = 'token_y',
  /** column name */
  ValuePerShare = 'value_per_share'
}

/** input type for updating data in table "laplace.borrow_deposit_hourly_stats" */
export type LaplaceBorrowDepositHourlyStatsSetInput = {
  block_height?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  collateral_per_share?: InputMaybe<Scalars['numeric']>;
  est_collateral_price?: InputMaybe<Scalars['numeric']>;
  expiry?: InputMaybe<Scalars['numeric']>;
  hour?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_per_share?: InputMaybe<Scalars['numeric']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  value_per_share?: InputMaybe<Scalars['numeric']>;
};

/** aggregate stddev on columns */
export type LaplaceBorrowDepositHourlyStatsStddevFields = {
  __typename?: 'laplace_borrow_deposit_hourly_stats_stddev_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  collateral_per_share?: Maybe<Scalars['Float']>;
  est_collateral_price?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  hour?: Maybe<Scalars['Float']>;
  token_per_share?: Maybe<Scalars['Float']>;
  value_per_share?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceBorrowDepositHourlyStatsStddevPopFields = {
  __typename?: 'laplace_borrow_deposit_hourly_stats_stddev_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  collateral_per_share?: Maybe<Scalars['Float']>;
  est_collateral_price?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  hour?: Maybe<Scalars['Float']>;
  token_per_share?: Maybe<Scalars['Float']>;
  value_per_share?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceBorrowDepositHourlyStatsStddevSampFields = {
  __typename?: 'laplace_borrow_deposit_hourly_stats_stddev_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  collateral_per_share?: Maybe<Scalars['Float']>;
  est_collateral_price?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  hour?: Maybe<Scalars['Float']>;
  token_per_share?: Maybe<Scalars['Float']>;
  value_per_share?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_borrow_deposit_hourly_stats" */
export type LaplaceBorrowDepositHourlyStatsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceBorrowDepositHourlyStatsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceBorrowDepositHourlyStatsStreamCursorValueInput = {
  block_height?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  collateral_per_share?: InputMaybe<Scalars['numeric']>;
  est_collateral_price?: InputMaybe<Scalars['numeric']>;
  expiry?: InputMaybe<Scalars['numeric']>;
  hour?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_per_share?: InputMaybe<Scalars['numeric']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  value_per_share?: InputMaybe<Scalars['numeric']>;
};

/** aggregate sum on columns */
export type LaplaceBorrowDepositHourlyStatsSumFields = {
  __typename?: 'laplace_borrow_deposit_hourly_stats_sum_fields';
  block_height?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  collateral_per_share?: Maybe<Scalars['numeric']>;
  est_collateral_price?: Maybe<Scalars['numeric']>;
  expiry?: Maybe<Scalars['numeric']>;
  hour?: Maybe<Scalars['numeric']>;
  token_per_share?: Maybe<Scalars['numeric']>;
  value_per_share?: Maybe<Scalars['numeric']>;
};

/** update columns of table "laplace.borrow_deposit_hourly_stats" */
export enum LaplaceBorrowDepositHourlyStatsUpdateColumn {
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  CollateralPerShare = 'collateral_per_share',
  /** column name */
  EstCollateralPrice = 'est_collateral_price',
  /** column name */
  Expiry = 'expiry',
  /** column name */
  Hour = 'hour',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenPerShare = 'token_per_share',
  /** column name */
  TokenX = 'token_x',
  /** column name */
  TokenY = 'token_y',
  /** column name */
  ValuePerShare = 'value_per_share'
}

export type LaplaceBorrowDepositHourlyStatsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceBorrowDepositHourlyStatsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceBorrowDepositHourlyStatsSetInput>;
  where: LaplaceBorrowDepositHourlyStatsBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceBorrowDepositHourlyStatsVarPopFields = {
  __typename?: 'laplace_borrow_deposit_hourly_stats_var_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  collateral_per_share?: Maybe<Scalars['Float']>;
  est_collateral_price?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  hour?: Maybe<Scalars['Float']>;
  token_per_share?: Maybe<Scalars['Float']>;
  value_per_share?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceBorrowDepositHourlyStatsVarSampFields = {
  __typename?: 'laplace_borrow_deposit_hourly_stats_var_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  collateral_per_share?: Maybe<Scalars['Float']>;
  est_collateral_price?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  hour?: Maybe<Scalars['Float']>;
  token_per_share?: Maybe<Scalars['Float']>;
  value_per_share?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceBorrowDepositHourlyStatsVarianceFields = {
  __typename?: 'laplace_borrow_deposit_hourly_stats_variance_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  collateral_per_share?: Maybe<Scalars['Float']>;
  est_collateral_price?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  hour?: Maybe<Scalars['Float']>;
  token_per_share?: Maybe<Scalars['Float']>;
  value_per_share?: Maybe<Scalars['Float']>;
};

/** ALEX historical price data per block */
export type LaplaceBorrowDepositStats = {
  __typename?: 'laplace_borrow_deposit_stats';
  active_crp_collateral?: Maybe<Scalars['numeric']>;
  active_crp_pool_value?: Maybe<Scalars['numeric']>;
  active_crp_token?: Maybe<Scalars['numeric']>;
  block_height: Scalars['numeric'];
  borrow_apr?: Maybe<Scalars['numeric']>;
  burn_block_time: Scalars['numeric'];
  current_expiry: Scalars['numeric'];
  deposit_apr?: Maybe<Scalars['numeric']>;
  est_fwp_collateral_price?: Maybe<Scalars['numeric']>;
  ltv: Scalars['numeric'];
  pool_token: Scalars['String'];
  sync_at: Scalars['timestamptz'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
  total_borrow: Scalars['numeric'];
  total_deposit: Scalars['numeric'];
  total_virtual: Scalars['numeric'];
  total_yield_supply: Scalars['numeric'];
  total_yield_token: Scalars['numeric'];
  yield_token: Scalars['String'];
};

/** aggregated selection of "laplace.borrow_deposit_stats" */
export type LaplaceBorrowDepositStatsAggregate = {
  __typename?: 'laplace_borrow_deposit_stats_aggregate';
  aggregate?: Maybe<LaplaceBorrowDepositStatsAggregateFields>;
  nodes: Array<LaplaceBorrowDepositStats>;
};

/** aggregate fields of "laplace.borrow_deposit_stats" */
export type LaplaceBorrowDepositStatsAggregateFields = {
  __typename?: 'laplace_borrow_deposit_stats_aggregate_fields';
  avg?: Maybe<LaplaceBorrowDepositStatsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceBorrowDepositStatsMaxFields>;
  min?: Maybe<LaplaceBorrowDepositStatsMinFields>;
  stddev?: Maybe<LaplaceBorrowDepositStatsStddevFields>;
  stddev_pop?: Maybe<LaplaceBorrowDepositStatsStddevPopFields>;
  stddev_samp?: Maybe<LaplaceBorrowDepositStatsStddevSampFields>;
  sum?: Maybe<LaplaceBorrowDepositStatsSumFields>;
  var_pop?: Maybe<LaplaceBorrowDepositStatsVarPopFields>;
  var_samp?: Maybe<LaplaceBorrowDepositStatsVarSampFields>;
  variance?: Maybe<LaplaceBorrowDepositStatsVarianceFields>;
};


/** aggregate fields of "laplace.borrow_deposit_stats" */
export type LaplaceBorrowDepositStatsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceBorrowDepositStatsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LaplaceBorrowDepositStatsAvgFields = {
  __typename?: 'laplace_borrow_deposit_stats_avg_fields';
  active_crp_collateral?: Maybe<Scalars['Float']>;
  active_crp_pool_value?: Maybe<Scalars['Float']>;
  active_crp_token?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  borrow_apr?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  current_expiry?: Maybe<Scalars['Float']>;
  deposit_apr?: Maybe<Scalars['Float']>;
  est_fwp_collateral_price?: Maybe<Scalars['Float']>;
  ltv?: Maybe<Scalars['Float']>;
  total_borrow?: Maybe<Scalars['Float']>;
  total_deposit?: Maybe<Scalars['Float']>;
  total_virtual?: Maybe<Scalars['Float']>;
  total_yield_supply?: Maybe<Scalars['Float']>;
  total_yield_token?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.borrow_deposit_stats". All fields are combined with a logical 'AND'. */
export type LaplaceBorrowDepositStatsBoolExp = {
  _and?: InputMaybe<Array<LaplaceBorrowDepositStatsBoolExp>>;
  _not?: InputMaybe<LaplaceBorrowDepositStatsBoolExp>;
  _or?: InputMaybe<Array<LaplaceBorrowDepositStatsBoolExp>>;
  active_crp_collateral?: InputMaybe<NumericComparisonExp>;
  active_crp_pool_value?: InputMaybe<NumericComparisonExp>;
  active_crp_token?: InputMaybe<NumericComparisonExp>;
  block_height?: InputMaybe<NumericComparisonExp>;
  borrow_apr?: InputMaybe<NumericComparisonExp>;
  burn_block_time?: InputMaybe<NumericComparisonExp>;
  current_expiry?: InputMaybe<NumericComparisonExp>;
  deposit_apr?: InputMaybe<NumericComparisonExp>;
  est_fwp_collateral_price?: InputMaybe<NumericComparisonExp>;
  ltv?: InputMaybe<NumericComparisonExp>;
  pool_token?: InputMaybe<StringComparisonExp>;
  sync_at?: InputMaybe<TimestamptzComparisonExp>;
  token_x?: InputMaybe<StringComparisonExp>;
  token_y?: InputMaybe<StringComparisonExp>;
  total_borrow?: InputMaybe<NumericComparisonExp>;
  total_deposit?: InputMaybe<NumericComparisonExp>;
  total_virtual?: InputMaybe<NumericComparisonExp>;
  total_yield_supply?: InputMaybe<NumericComparisonExp>;
  total_yield_token?: InputMaybe<NumericComparisonExp>;
  yield_token?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "laplace.borrow_deposit_stats" */
export enum LaplaceBorrowDepositStatsConstraint {
  /** unique or primary key constraint on columns "block_height", "token_y", "token_x" */
  BorrowDepositStatsPkey = 'borrow_deposit_stats_pkey'
}

/** input type for incrementing numeric columns in table "laplace.borrow_deposit_stats" */
export type LaplaceBorrowDepositStatsIncInput = {
  active_crp_collateral?: InputMaybe<Scalars['numeric']>;
  active_crp_pool_value?: InputMaybe<Scalars['numeric']>;
  active_crp_token?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  borrow_apr?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  current_expiry?: InputMaybe<Scalars['numeric']>;
  deposit_apr?: InputMaybe<Scalars['numeric']>;
  est_fwp_collateral_price?: InputMaybe<Scalars['numeric']>;
  ltv?: InputMaybe<Scalars['numeric']>;
  total_borrow?: InputMaybe<Scalars['numeric']>;
  total_deposit?: InputMaybe<Scalars['numeric']>;
  total_virtual?: InputMaybe<Scalars['numeric']>;
  total_yield_supply?: InputMaybe<Scalars['numeric']>;
  total_yield_token?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "laplace.borrow_deposit_stats" */
export type LaplaceBorrowDepositStatsInsertInput = {
  active_crp_collateral?: InputMaybe<Scalars['numeric']>;
  active_crp_pool_value?: InputMaybe<Scalars['numeric']>;
  active_crp_token?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  borrow_apr?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  current_expiry?: InputMaybe<Scalars['numeric']>;
  deposit_apr?: InputMaybe<Scalars['numeric']>;
  est_fwp_collateral_price?: InputMaybe<Scalars['numeric']>;
  ltv?: InputMaybe<Scalars['numeric']>;
  pool_token?: InputMaybe<Scalars['String']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  total_borrow?: InputMaybe<Scalars['numeric']>;
  total_deposit?: InputMaybe<Scalars['numeric']>;
  total_virtual?: InputMaybe<Scalars['numeric']>;
  total_yield_supply?: InputMaybe<Scalars['numeric']>;
  total_yield_token?: InputMaybe<Scalars['numeric']>;
  yield_token?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type LaplaceBorrowDepositStatsMaxFields = {
  __typename?: 'laplace_borrow_deposit_stats_max_fields';
  active_crp_collateral?: Maybe<Scalars['numeric']>;
  active_crp_pool_value?: Maybe<Scalars['numeric']>;
  active_crp_token?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['numeric']>;
  borrow_apr?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  current_expiry?: Maybe<Scalars['numeric']>;
  deposit_apr?: Maybe<Scalars['numeric']>;
  est_fwp_collateral_price?: Maybe<Scalars['numeric']>;
  ltv?: Maybe<Scalars['numeric']>;
  pool_token?: Maybe<Scalars['String']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_x?: Maybe<Scalars['String']>;
  token_y?: Maybe<Scalars['String']>;
  total_borrow?: Maybe<Scalars['numeric']>;
  total_deposit?: Maybe<Scalars['numeric']>;
  total_virtual?: Maybe<Scalars['numeric']>;
  total_yield_supply?: Maybe<Scalars['numeric']>;
  total_yield_token?: Maybe<Scalars['numeric']>;
  yield_token?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LaplaceBorrowDepositStatsMinFields = {
  __typename?: 'laplace_borrow_deposit_stats_min_fields';
  active_crp_collateral?: Maybe<Scalars['numeric']>;
  active_crp_pool_value?: Maybe<Scalars['numeric']>;
  active_crp_token?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['numeric']>;
  borrow_apr?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  current_expiry?: Maybe<Scalars['numeric']>;
  deposit_apr?: Maybe<Scalars['numeric']>;
  est_fwp_collateral_price?: Maybe<Scalars['numeric']>;
  ltv?: Maybe<Scalars['numeric']>;
  pool_token?: Maybe<Scalars['String']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_x?: Maybe<Scalars['String']>;
  token_y?: Maybe<Scalars['String']>;
  total_borrow?: Maybe<Scalars['numeric']>;
  total_deposit?: Maybe<Scalars['numeric']>;
  total_virtual?: Maybe<Scalars['numeric']>;
  total_yield_supply?: Maybe<Scalars['numeric']>;
  total_yield_token?: Maybe<Scalars['numeric']>;
  yield_token?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "laplace.borrow_deposit_stats" */
export type LaplaceBorrowDepositStatsMutationResponse = {
  __typename?: 'laplace_borrow_deposit_stats_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceBorrowDepositStats>;
};

/** on_conflict condition type for table "laplace.borrow_deposit_stats" */
export type LaplaceBorrowDepositStatsOnConflict = {
  constraint: LaplaceBorrowDepositStatsConstraint;
  update_columns?: Array<LaplaceBorrowDepositStatsUpdateColumn>;
  where?: InputMaybe<LaplaceBorrowDepositStatsBoolExp>;
};

/** Ordering options when selecting data from "laplace.borrow_deposit_stats". */
export type LaplaceBorrowDepositStatsOrderBy = {
  active_crp_collateral?: InputMaybe<OrderBy>;
  active_crp_pool_value?: InputMaybe<OrderBy>;
  active_crp_token?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  borrow_apr?: InputMaybe<OrderBy>;
  burn_block_time?: InputMaybe<OrderBy>;
  current_expiry?: InputMaybe<OrderBy>;
  deposit_apr?: InputMaybe<OrderBy>;
  est_fwp_collateral_price?: InputMaybe<OrderBy>;
  ltv?: InputMaybe<OrderBy>;
  pool_token?: InputMaybe<OrderBy>;
  sync_at?: InputMaybe<OrderBy>;
  token_x?: InputMaybe<OrderBy>;
  token_y?: InputMaybe<OrderBy>;
  total_borrow?: InputMaybe<OrderBy>;
  total_deposit?: InputMaybe<OrderBy>;
  total_virtual?: InputMaybe<OrderBy>;
  total_yield_supply?: InputMaybe<OrderBy>;
  total_yield_token?: InputMaybe<OrderBy>;
  yield_token?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.borrow_deposit_stats */
export type LaplaceBorrowDepositStatsPkColumnsInput = {
  block_height: Scalars['numeric'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};

/** select columns of table "laplace.borrow_deposit_stats" */
export enum LaplaceBorrowDepositStatsSelectColumn {
  /** column name */
  ActiveCrpCollateral = 'active_crp_collateral',
  /** column name */
  ActiveCrpPoolValue = 'active_crp_pool_value',
  /** column name */
  ActiveCrpToken = 'active_crp_token',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BorrowApr = 'borrow_apr',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  CurrentExpiry = 'current_expiry',
  /** column name */
  DepositApr = 'deposit_apr',
  /** column name */
  EstFwpCollateralPrice = 'est_fwp_collateral_price',
  /** column name */
  Ltv = 'ltv',
  /** column name */
  PoolToken = 'pool_token',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenX = 'token_x',
  /** column name */
  TokenY = 'token_y',
  /** column name */
  TotalBorrow = 'total_borrow',
  /** column name */
  TotalDeposit = 'total_deposit',
  /** column name */
  TotalVirtual = 'total_virtual',
  /** column name */
  TotalYieldSupply = 'total_yield_supply',
  /** column name */
  TotalYieldToken = 'total_yield_token',
  /** column name */
  YieldToken = 'yield_token'
}

/** input type for updating data in table "laplace.borrow_deposit_stats" */
export type LaplaceBorrowDepositStatsSetInput = {
  active_crp_collateral?: InputMaybe<Scalars['numeric']>;
  active_crp_pool_value?: InputMaybe<Scalars['numeric']>;
  active_crp_token?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  borrow_apr?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  current_expiry?: InputMaybe<Scalars['numeric']>;
  deposit_apr?: InputMaybe<Scalars['numeric']>;
  est_fwp_collateral_price?: InputMaybe<Scalars['numeric']>;
  ltv?: InputMaybe<Scalars['numeric']>;
  pool_token?: InputMaybe<Scalars['String']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  total_borrow?: InputMaybe<Scalars['numeric']>;
  total_deposit?: InputMaybe<Scalars['numeric']>;
  total_virtual?: InputMaybe<Scalars['numeric']>;
  total_yield_supply?: InputMaybe<Scalars['numeric']>;
  total_yield_token?: InputMaybe<Scalars['numeric']>;
  yield_token?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type LaplaceBorrowDepositStatsStddevFields = {
  __typename?: 'laplace_borrow_deposit_stats_stddev_fields';
  active_crp_collateral?: Maybe<Scalars['Float']>;
  active_crp_pool_value?: Maybe<Scalars['Float']>;
  active_crp_token?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  borrow_apr?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  current_expiry?: Maybe<Scalars['Float']>;
  deposit_apr?: Maybe<Scalars['Float']>;
  est_fwp_collateral_price?: Maybe<Scalars['Float']>;
  ltv?: Maybe<Scalars['Float']>;
  total_borrow?: Maybe<Scalars['Float']>;
  total_deposit?: Maybe<Scalars['Float']>;
  total_virtual?: Maybe<Scalars['Float']>;
  total_yield_supply?: Maybe<Scalars['Float']>;
  total_yield_token?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceBorrowDepositStatsStddevPopFields = {
  __typename?: 'laplace_borrow_deposit_stats_stddev_pop_fields';
  active_crp_collateral?: Maybe<Scalars['Float']>;
  active_crp_pool_value?: Maybe<Scalars['Float']>;
  active_crp_token?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  borrow_apr?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  current_expiry?: Maybe<Scalars['Float']>;
  deposit_apr?: Maybe<Scalars['Float']>;
  est_fwp_collateral_price?: Maybe<Scalars['Float']>;
  ltv?: Maybe<Scalars['Float']>;
  total_borrow?: Maybe<Scalars['Float']>;
  total_deposit?: Maybe<Scalars['Float']>;
  total_virtual?: Maybe<Scalars['Float']>;
  total_yield_supply?: Maybe<Scalars['Float']>;
  total_yield_token?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceBorrowDepositStatsStddevSampFields = {
  __typename?: 'laplace_borrow_deposit_stats_stddev_samp_fields';
  active_crp_collateral?: Maybe<Scalars['Float']>;
  active_crp_pool_value?: Maybe<Scalars['Float']>;
  active_crp_token?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  borrow_apr?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  current_expiry?: Maybe<Scalars['Float']>;
  deposit_apr?: Maybe<Scalars['Float']>;
  est_fwp_collateral_price?: Maybe<Scalars['Float']>;
  ltv?: Maybe<Scalars['Float']>;
  total_borrow?: Maybe<Scalars['Float']>;
  total_deposit?: Maybe<Scalars['Float']>;
  total_virtual?: Maybe<Scalars['Float']>;
  total_yield_supply?: Maybe<Scalars['Float']>;
  total_yield_token?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_borrow_deposit_stats" */
export type LaplaceBorrowDepositStatsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceBorrowDepositStatsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceBorrowDepositStatsStreamCursorValueInput = {
  active_crp_collateral?: InputMaybe<Scalars['numeric']>;
  active_crp_pool_value?: InputMaybe<Scalars['numeric']>;
  active_crp_token?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  borrow_apr?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  current_expiry?: InputMaybe<Scalars['numeric']>;
  deposit_apr?: InputMaybe<Scalars['numeric']>;
  est_fwp_collateral_price?: InputMaybe<Scalars['numeric']>;
  ltv?: InputMaybe<Scalars['numeric']>;
  pool_token?: InputMaybe<Scalars['String']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  total_borrow?: InputMaybe<Scalars['numeric']>;
  total_deposit?: InputMaybe<Scalars['numeric']>;
  total_virtual?: InputMaybe<Scalars['numeric']>;
  total_yield_supply?: InputMaybe<Scalars['numeric']>;
  total_yield_token?: InputMaybe<Scalars['numeric']>;
  yield_token?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type LaplaceBorrowDepositStatsSumFields = {
  __typename?: 'laplace_borrow_deposit_stats_sum_fields';
  active_crp_collateral?: Maybe<Scalars['numeric']>;
  active_crp_pool_value?: Maybe<Scalars['numeric']>;
  active_crp_token?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['numeric']>;
  borrow_apr?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  current_expiry?: Maybe<Scalars['numeric']>;
  deposit_apr?: Maybe<Scalars['numeric']>;
  est_fwp_collateral_price?: Maybe<Scalars['numeric']>;
  ltv?: Maybe<Scalars['numeric']>;
  total_borrow?: Maybe<Scalars['numeric']>;
  total_deposit?: Maybe<Scalars['numeric']>;
  total_virtual?: Maybe<Scalars['numeric']>;
  total_yield_supply?: Maybe<Scalars['numeric']>;
  total_yield_token?: Maybe<Scalars['numeric']>;
};

/** update columns of table "laplace.borrow_deposit_stats" */
export enum LaplaceBorrowDepositStatsUpdateColumn {
  /** column name */
  ActiveCrpCollateral = 'active_crp_collateral',
  /** column name */
  ActiveCrpPoolValue = 'active_crp_pool_value',
  /** column name */
  ActiveCrpToken = 'active_crp_token',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BorrowApr = 'borrow_apr',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  CurrentExpiry = 'current_expiry',
  /** column name */
  DepositApr = 'deposit_apr',
  /** column name */
  EstFwpCollateralPrice = 'est_fwp_collateral_price',
  /** column name */
  Ltv = 'ltv',
  /** column name */
  PoolToken = 'pool_token',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenX = 'token_x',
  /** column name */
  TokenY = 'token_y',
  /** column name */
  TotalBorrow = 'total_borrow',
  /** column name */
  TotalDeposit = 'total_deposit',
  /** column name */
  TotalVirtual = 'total_virtual',
  /** column name */
  TotalYieldSupply = 'total_yield_supply',
  /** column name */
  TotalYieldToken = 'total_yield_token',
  /** column name */
  YieldToken = 'yield_token'
}

export type LaplaceBorrowDepositStatsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceBorrowDepositStatsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceBorrowDepositStatsSetInput>;
  where: LaplaceBorrowDepositStatsBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceBorrowDepositStatsVarPopFields = {
  __typename?: 'laplace_borrow_deposit_stats_var_pop_fields';
  active_crp_collateral?: Maybe<Scalars['Float']>;
  active_crp_pool_value?: Maybe<Scalars['Float']>;
  active_crp_token?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  borrow_apr?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  current_expiry?: Maybe<Scalars['Float']>;
  deposit_apr?: Maybe<Scalars['Float']>;
  est_fwp_collateral_price?: Maybe<Scalars['Float']>;
  ltv?: Maybe<Scalars['Float']>;
  total_borrow?: Maybe<Scalars['Float']>;
  total_deposit?: Maybe<Scalars['Float']>;
  total_virtual?: Maybe<Scalars['Float']>;
  total_yield_supply?: Maybe<Scalars['Float']>;
  total_yield_token?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceBorrowDepositStatsVarSampFields = {
  __typename?: 'laplace_borrow_deposit_stats_var_samp_fields';
  active_crp_collateral?: Maybe<Scalars['Float']>;
  active_crp_pool_value?: Maybe<Scalars['Float']>;
  active_crp_token?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  borrow_apr?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  current_expiry?: Maybe<Scalars['Float']>;
  deposit_apr?: Maybe<Scalars['Float']>;
  est_fwp_collateral_price?: Maybe<Scalars['Float']>;
  ltv?: Maybe<Scalars['Float']>;
  total_borrow?: Maybe<Scalars['Float']>;
  total_deposit?: Maybe<Scalars['Float']>;
  total_virtual?: Maybe<Scalars['Float']>;
  total_yield_supply?: Maybe<Scalars['Float']>;
  total_yield_token?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceBorrowDepositStatsVarianceFields = {
  __typename?: 'laplace_borrow_deposit_stats_variance_fields';
  active_crp_collateral?: Maybe<Scalars['Float']>;
  active_crp_pool_value?: Maybe<Scalars['Float']>;
  active_crp_token?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  borrow_apr?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  current_expiry?: Maybe<Scalars['Float']>;
  deposit_apr?: Maybe<Scalars['Float']>;
  est_fwp_collateral_price?: Maybe<Scalars['Float']>;
  ltv?: Maybe<Scalars['Float']>;
  total_borrow?: Maybe<Scalars['Float']>;
  total_deposit?: Maybe<Scalars['Float']>;
  total_virtual?: Maybe<Scalars['Float']>;
  total_yield_supply?: Maybe<Scalars['Float']>;
  total_yield_token?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "laplace.coin_gecko" */
export type LaplaceCoinGecko = {
  __typename?: 'laplace_coin_gecko';
  avg_price_usd: Scalars['float8'];
  ccy: Scalars['jsonb'];
  coin_gecko_id: Scalars['String'];
  market_cap: Scalars['jsonb'];
  prices_market: Scalars['jsonb'];
  timestamp: Scalars['timestamptz'];
  token: Scalars['String'];
};


/** columns and relationships of "laplace.coin_gecko" */
export type LaplaceCoinGeckoCcyArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "laplace.coin_gecko" */
export type LaplaceCoinGeckoMarketCapArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "laplace.coin_gecko" */
export type LaplaceCoinGeckoPricesMarketArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "laplace.coin_gecko" */
export type LaplaceCoinGeckoAggregate = {
  __typename?: 'laplace_coin_gecko_aggregate';
  aggregate?: Maybe<LaplaceCoinGeckoAggregateFields>;
  nodes: Array<LaplaceCoinGecko>;
};

/** aggregate fields of "laplace.coin_gecko" */
export type LaplaceCoinGeckoAggregateFields = {
  __typename?: 'laplace_coin_gecko_aggregate_fields';
  avg?: Maybe<LaplaceCoinGeckoAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceCoinGeckoMaxFields>;
  min?: Maybe<LaplaceCoinGeckoMinFields>;
  stddev?: Maybe<LaplaceCoinGeckoStddevFields>;
  stddev_pop?: Maybe<LaplaceCoinGeckoStddevPopFields>;
  stddev_samp?: Maybe<LaplaceCoinGeckoStddevSampFields>;
  sum?: Maybe<LaplaceCoinGeckoSumFields>;
  var_pop?: Maybe<LaplaceCoinGeckoVarPopFields>;
  var_samp?: Maybe<LaplaceCoinGeckoVarSampFields>;
  variance?: Maybe<LaplaceCoinGeckoVarianceFields>;
};


/** aggregate fields of "laplace.coin_gecko" */
export type LaplaceCoinGeckoAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceCoinGeckoSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type LaplaceCoinGeckoAppendInput = {
  ccy?: InputMaybe<Scalars['jsonb']>;
  market_cap?: InputMaybe<Scalars['jsonb']>;
  prices_market?: InputMaybe<Scalars['jsonb']>;
};

/** ALEX Coingecko price time series data */
export type LaplaceCoinGeckoArchive = {
  __typename?: 'laplace_coin_gecko_archive';
  avg_price_usd: Scalars['float8'];
  ccy: Scalars['jsonb'];
  coin_gecko_id: Scalars['String'];
  market_cap: Scalars['jsonb'];
  prices_market: Scalars['jsonb'];
  timestamp: Scalars['timestamptz'];
  token: Scalars['String'];
};


/** ALEX Coingecko price time series data */
export type LaplaceCoinGeckoArchiveCcyArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** ALEX Coingecko price time series data */
export type LaplaceCoinGeckoArchiveMarketCapArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** ALEX Coingecko price time series data */
export type LaplaceCoinGeckoArchivePricesMarketArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "laplace.coin_gecko_archive" */
export type LaplaceCoinGeckoArchiveAggregate = {
  __typename?: 'laplace_coin_gecko_archive_aggregate';
  aggregate?: Maybe<LaplaceCoinGeckoArchiveAggregateFields>;
  nodes: Array<LaplaceCoinGeckoArchive>;
};

/** aggregate fields of "laplace.coin_gecko_archive" */
export type LaplaceCoinGeckoArchiveAggregateFields = {
  __typename?: 'laplace_coin_gecko_archive_aggregate_fields';
  avg?: Maybe<LaplaceCoinGeckoArchiveAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceCoinGeckoArchiveMaxFields>;
  min?: Maybe<LaplaceCoinGeckoArchiveMinFields>;
  stddev?: Maybe<LaplaceCoinGeckoArchiveStddevFields>;
  stddev_pop?: Maybe<LaplaceCoinGeckoArchiveStddevPopFields>;
  stddev_samp?: Maybe<LaplaceCoinGeckoArchiveStddevSampFields>;
  sum?: Maybe<LaplaceCoinGeckoArchiveSumFields>;
  var_pop?: Maybe<LaplaceCoinGeckoArchiveVarPopFields>;
  var_samp?: Maybe<LaplaceCoinGeckoArchiveVarSampFields>;
  variance?: Maybe<LaplaceCoinGeckoArchiveVarianceFields>;
};


/** aggregate fields of "laplace.coin_gecko_archive" */
export type LaplaceCoinGeckoArchiveAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceCoinGeckoArchiveSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type LaplaceCoinGeckoArchiveAppendInput = {
  ccy?: InputMaybe<Scalars['jsonb']>;
  market_cap?: InputMaybe<Scalars['jsonb']>;
  prices_market?: InputMaybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type LaplaceCoinGeckoArchiveAvgFields = {
  __typename?: 'laplace_coin_gecko_archive_avg_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.coin_gecko_archive". All fields are combined with a logical 'AND'. */
export type LaplaceCoinGeckoArchiveBoolExp = {
  _and?: InputMaybe<Array<LaplaceCoinGeckoArchiveBoolExp>>;
  _not?: InputMaybe<LaplaceCoinGeckoArchiveBoolExp>;
  _or?: InputMaybe<Array<LaplaceCoinGeckoArchiveBoolExp>>;
  avg_price_usd?: InputMaybe<Float8ComparisonExp>;
  ccy?: InputMaybe<JsonbComparisonExp>;
  coin_gecko_id?: InputMaybe<StringComparisonExp>;
  market_cap?: InputMaybe<JsonbComparisonExp>;
  prices_market?: InputMaybe<JsonbComparisonExp>;
  timestamp?: InputMaybe<TimestamptzComparisonExp>;
  token?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "laplace.coin_gecko_archive" */
export enum LaplaceCoinGeckoArchiveConstraint {
  /** unique or primary key constraint on columns "timestamp", "token" */
  CoinGeckoArchivePkey = 'coin_gecko_archive_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type LaplaceCoinGeckoArchiveDeleteAtPathInput = {
  ccy?: InputMaybe<Array<Scalars['String']>>;
  market_cap?: InputMaybe<Array<Scalars['String']>>;
  prices_market?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type LaplaceCoinGeckoArchiveDeleteElemInput = {
  ccy?: InputMaybe<Scalars['Int']>;
  market_cap?: InputMaybe<Scalars['Int']>;
  prices_market?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type LaplaceCoinGeckoArchiveDeleteKeyInput = {
  ccy?: InputMaybe<Scalars['String']>;
  market_cap?: InputMaybe<Scalars['String']>;
  prices_market?: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "laplace.coin_gecko_archive" */
export type LaplaceCoinGeckoArchiveIncInput = {
  avg_price_usd?: InputMaybe<Scalars['float8']>;
};

/** input type for inserting data into table "laplace.coin_gecko_archive" */
export type LaplaceCoinGeckoArchiveInsertInput = {
  avg_price_usd?: InputMaybe<Scalars['float8']>;
  ccy?: InputMaybe<Scalars['jsonb']>;
  coin_gecko_id?: InputMaybe<Scalars['String']>;
  market_cap?: InputMaybe<Scalars['jsonb']>;
  prices_market?: InputMaybe<Scalars['jsonb']>;
  timestamp?: InputMaybe<Scalars['timestamptz']>;
  token?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type LaplaceCoinGeckoArchiveMaxFields = {
  __typename?: 'laplace_coin_gecko_archive_max_fields';
  avg_price_usd?: Maybe<Scalars['float8']>;
  coin_gecko_id?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['timestamptz']>;
  token?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LaplaceCoinGeckoArchiveMinFields = {
  __typename?: 'laplace_coin_gecko_archive_min_fields';
  avg_price_usd?: Maybe<Scalars['float8']>;
  coin_gecko_id?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['timestamptz']>;
  token?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "laplace.coin_gecko_archive" */
export type LaplaceCoinGeckoArchiveMutationResponse = {
  __typename?: 'laplace_coin_gecko_archive_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceCoinGeckoArchive>;
};

/** on_conflict condition type for table "laplace.coin_gecko_archive" */
export type LaplaceCoinGeckoArchiveOnConflict = {
  constraint: LaplaceCoinGeckoArchiveConstraint;
  update_columns?: Array<LaplaceCoinGeckoArchiveUpdateColumn>;
  where?: InputMaybe<LaplaceCoinGeckoArchiveBoolExp>;
};

/** Ordering options when selecting data from "laplace.coin_gecko_archive". */
export type LaplaceCoinGeckoArchiveOrderBy = {
  avg_price_usd?: InputMaybe<OrderBy>;
  ccy?: InputMaybe<OrderBy>;
  coin_gecko_id?: InputMaybe<OrderBy>;
  market_cap?: InputMaybe<OrderBy>;
  prices_market?: InputMaybe<OrderBy>;
  timestamp?: InputMaybe<OrderBy>;
  token?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.coin_gecko_archive */
export type LaplaceCoinGeckoArchivePkColumnsInput = {
  timestamp: Scalars['timestamptz'];
  token: Scalars['String'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type LaplaceCoinGeckoArchivePrependInput = {
  ccy?: InputMaybe<Scalars['jsonb']>;
  market_cap?: InputMaybe<Scalars['jsonb']>;
  prices_market?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "laplace.coin_gecko_archive" */
export enum LaplaceCoinGeckoArchiveSelectColumn {
  /** column name */
  AvgPriceUsd = 'avg_price_usd',
  /** column name */
  Ccy = 'ccy',
  /** column name */
  CoinGeckoId = 'coin_gecko_id',
  /** column name */
  MarketCap = 'market_cap',
  /** column name */
  PricesMarket = 'prices_market',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Token = 'token'
}

/** input type for updating data in table "laplace.coin_gecko_archive" */
export type LaplaceCoinGeckoArchiveSetInput = {
  avg_price_usd?: InputMaybe<Scalars['float8']>;
  ccy?: InputMaybe<Scalars['jsonb']>;
  coin_gecko_id?: InputMaybe<Scalars['String']>;
  market_cap?: InputMaybe<Scalars['jsonb']>;
  prices_market?: InputMaybe<Scalars['jsonb']>;
  timestamp?: InputMaybe<Scalars['timestamptz']>;
  token?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type LaplaceCoinGeckoArchiveStddevFields = {
  __typename?: 'laplace_coin_gecko_archive_stddev_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceCoinGeckoArchiveStddevPopFields = {
  __typename?: 'laplace_coin_gecko_archive_stddev_pop_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceCoinGeckoArchiveStddevSampFields = {
  __typename?: 'laplace_coin_gecko_archive_stddev_samp_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_coin_gecko_archive" */
export type LaplaceCoinGeckoArchiveStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceCoinGeckoArchiveStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceCoinGeckoArchiveStreamCursorValueInput = {
  avg_price_usd?: InputMaybe<Scalars['float8']>;
  ccy?: InputMaybe<Scalars['jsonb']>;
  coin_gecko_id?: InputMaybe<Scalars['String']>;
  market_cap?: InputMaybe<Scalars['jsonb']>;
  prices_market?: InputMaybe<Scalars['jsonb']>;
  timestamp?: InputMaybe<Scalars['timestamptz']>;
  token?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type LaplaceCoinGeckoArchiveSumFields = {
  __typename?: 'laplace_coin_gecko_archive_sum_fields';
  avg_price_usd?: Maybe<Scalars['float8']>;
};

/** update columns of table "laplace.coin_gecko_archive" */
export enum LaplaceCoinGeckoArchiveUpdateColumn {
  /** column name */
  AvgPriceUsd = 'avg_price_usd',
  /** column name */
  Ccy = 'ccy',
  /** column name */
  CoinGeckoId = 'coin_gecko_id',
  /** column name */
  MarketCap = 'market_cap',
  /** column name */
  PricesMarket = 'prices_market',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Token = 'token'
}

export type LaplaceCoinGeckoArchiveUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<LaplaceCoinGeckoArchiveAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<LaplaceCoinGeckoArchiveDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<LaplaceCoinGeckoArchiveDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<LaplaceCoinGeckoArchiveDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceCoinGeckoArchiveIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<LaplaceCoinGeckoArchivePrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceCoinGeckoArchiveSetInput>;
  where: LaplaceCoinGeckoArchiveBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceCoinGeckoArchiveVarPopFields = {
  __typename?: 'laplace_coin_gecko_archive_var_pop_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceCoinGeckoArchiveVarSampFields = {
  __typename?: 'laplace_coin_gecko_archive_var_samp_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceCoinGeckoArchiveVarianceFields = {
  __typename?: 'laplace_coin_gecko_archive_variance_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** aggregate avg on columns */
export type LaplaceCoinGeckoAvgFields = {
  __typename?: 'laplace_coin_gecko_avg_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.coin_gecko". All fields are combined with a logical 'AND'. */
export type LaplaceCoinGeckoBoolExp = {
  _and?: InputMaybe<Array<LaplaceCoinGeckoBoolExp>>;
  _not?: InputMaybe<LaplaceCoinGeckoBoolExp>;
  _or?: InputMaybe<Array<LaplaceCoinGeckoBoolExp>>;
  avg_price_usd?: InputMaybe<Float8ComparisonExp>;
  ccy?: InputMaybe<JsonbComparisonExp>;
  coin_gecko_id?: InputMaybe<StringComparisonExp>;
  market_cap?: InputMaybe<JsonbComparisonExp>;
  prices_market?: InputMaybe<JsonbComparisonExp>;
  timestamp?: InputMaybe<TimestamptzComparisonExp>;
  token?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "laplace.coin_gecko" */
export enum LaplaceCoinGeckoConstraint {
  /** unique or primary key constraint on columns "token" */
  CoinGeckoPkey = 'coin_gecko_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type LaplaceCoinGeckoDeleteAtPathInput = {
  ccy?: InputMaybe<Array<Scalars['String']>>;
  market_cap?: InputMaybe<Array<Scalars['String']>>;
  prices_market?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type LaplaceCoinGeckoDeleteElemInput = {
  ccy?: InputMaybe<Scalars['Int']>;
  market_cap?: InputMaybe<Scalars['Int']>;
  prices_market?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type LaplaceCoinGeckoDeleteKeyInput = {
  ccy?: InputMaybe<Scalars['String']>;
  market_cap?: InputMaybe<Scalars['String']>;
  prices_market?: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "laplace.coin_gecko" */
export type LaplaceCoinGeckoIncInput = {
  avg_price_usd?: InputMaybe<Scalars['float8']>;
};

/** input type for inserting data into table "laplace.coin_gecko" */
export type LaplaceCoinGeckoInsertInput = {
  avg_price_usd?: InputMaybe<Scalars['float8']>;
  ccy?: InputMaybe<Scalars['jsonb']>;
  coin_gecko_id?: InputMaybe<Scalars['String']>;
  market_cap?: InputMaybe<Scalars['jsonb']>;
  prices_market?: InputMaybe<Scalars['jsonb']>;
  timestamp?: InputMaybe<Scalars['timestamptz']>;
  token?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type LaplaceCoinGeckoMaxFields = {
  __typename?: 'laplace_coin_gecko_max_fields';
  avg_price_usd?: Maybe<Scalars['float8']>;
  coin_gecko_id?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['timestamptz']>;
  token?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LaplaceCoinGeckoMinFields = {
  __typename?: 'laplace_coin_gecko_min_fields';
  avg_price_usd?: Maybe<Scalars['float8']>;
  coin_gecko_id?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['timestamptz']>;
  token?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "laplace.coin_gecko" */
export type LaplaceCoinGeckoMutationResponse = {
  __typename?: 'laplace_coin_gecko_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceCoinGecko>;
};

/** on_conflict condition type for table "laplace.coin_gecko" */
export type LaplaceCoinGeckoOnConflict = {
  constraint: LaplaceCoinGeckoConstraint;
  update_columns?: Array<LaplaceCoinGeckoUpdateColumn>;
  where?: InputMaybe<LaplaceCoinGeckoBoolExp>;
};

/** Ordering options when selecting data from "laplace.coin_gecko". */
export type LaplaceCoinGeckoOrderBy = {
  avg_price_usd?: InputMaybe<OrderBy>;
  ccy?: InputMaybe<OrderBy>;
  coin_gecko_id?: InputMaybe<OrderBy>;
  market_cap?: InputMaybe<OrderBy>;
  prices_market?: InputMaybe<OrderBy>;
  timestamp?: InputMaybe<OrderBy>;
  token?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.coin_gecko */
export type LaplaceCoinGeckoPkColumnsInput = {
  token: Scalars['String'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type LaplaceCoinGeckoPrependInput = {
  ccy?: InputMaybe<Scalars['jsonb']>;
  market_cap?: InputMaybe<Scalars['jsonb']>;
  prices_market?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "laplace.coin_gecko" */
export enum LaplaceCoinGeckoSelectColumn {
  /** column name */
  AvgPriceUsd = 'avg_price_usd',
  /** column name */
  Ccy = 'ccy',
  /** column name */
  CoinGeckoId = 'coin_gecko_id',
  /** column name */
  MarketCap = 'market_cap',
  /** column name */
  PricesMarket = 'prices_market',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Token = 'token'
}

/** input type for updating data in table "laplace.coin_gecko" */
export type LaplaceCoinGeckoSetInput = {
  avg_price_usd?: InputMaybe<Scalars['float8']>;
  ccy?: InputMaybe<Scalars['jsonb']>;
  coin_gecko_id?: InputMaybe<Scalars['String']>;
  market_cap?: InputMaybe<Scalars['jsonb']>;
  prices_market?: InputMaybe<Scalars['jsonb']>;
  timestamp?: InputMaybe<Scalars['timestamptz']>;
  token?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type LaplaceCoinGeckoStddevFields = {
  __typename?: 'laplace_coin_gecko_stddev_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceCoinGeckoStddevPopFields = {
  __typename?: 'laplace_coin_gecko_stddev_pop_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceCoinGeckoStddevSampFields = {
  __typename?: 'laplace_coin_gecko_stddev_samp_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_coin_gecko" */
export type LaplaceCoinGeckoStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceCoinGeckoStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceCoinGeckoStreamCursorValueInput = {
  avg_price_usd?: InputMaybe<Scalars['float8']>;
  ccy?: InputMaybe<Scalars['jsonb']>;
  coin_gecko_id?: InputMaybe<Scalars['String']>;
  market_cap?: InputMaybe<Scalars['jsonb']>;
  prices_market?: InputMaybe<Scalars['jsonb']>;
  timestamp?: InputMaybe<Scalars['timestamptz']>;
  token?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type LaplaceCoinGeckoSumFields = {
  __typename?: 'laplace_coin_gecko_sum_fields';
  avg_price_usd?: Maybe<Scalars['float8']>;
};

/** update columns of table "laplace.coin_gecko" */
export enum LaplaceCoinGeckoUpdateColumn {
  /** column name */
  AvgPriceUsd = 'avg_price_usd',
  /** column name */
  Ccy = 'ccy',
  /** column name */
  CoinGeckoId = 'coin_gecko_id',
  /** column name */
  MarketCap = 'market_cap',
  /** column name */
  PricesMarket = 'prices_market',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Token = 'token'
}

export type LaplaceCoinGeckoUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<LaplaceCoinGeckoAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<LaplaceCoinGeckoDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<LaplaceCoinGeckoDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<LaplaceCoinGeckoDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceCoinGeckoIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<LaplaceCoinGeckoPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceCoinGeckoSetInput>;
  where: LaplaceCoinGeckoBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceCoinGeckoVarPopFields = {
  __typename?: 'laplace_coin_gecko_var_pop_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceCoinGeckoVarSampFields = {
  __typename?: 'laplace_coin_gecko_var_samp_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceCoinGeckoVarianceFields = {
  __typename?: 'laplace_coin_gecko_variance_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** ALEX collateral rebalancing pool */
export type LaplaceCollateralRebalancingPool = {
  __typename?: 'laplace_collateral_rebalancing_pool';
  balance_x: Scalars['numeric'];
  balance_y: Scalars['numeric'];
  block_height: Scalars['numeric'];
  bs_vol: Scalars['numeric'];
  burn_block_time: Scalars['numeric'];
  conversion_ltv: Scalars['numeric'];
  est_collateral_price: Scalars['numeric'];
  est_collateral_price_per_key_token: Scalars['numeric'];
  est_fwp_collateral_price?: Maybe<Scalars['numeric']>;
  est_token_price_per_key_token: Scalars['numeric'];
  est_total_pool_value: Scalars['numeric'];
  expiry: Scalars['numeric'];
  fee_rate_x: Scalars['numeric'];
  fee_rate_y: Scalars['numeric'];
  fee_rebate: Scalars['numeric'];
  fee_to_address: Scalars['String'];
  final_collateral_per_share?: Maybe<Scalars['numeric']>;
  final_token_per_share?: Maybe<Scalars['numeric']>;
  key_supply: Scalars['numeric'];
  key_token: Scalars['String'];
  ltv_0: Scalars['numeric'];
  moving_average: Scalars['numeric'];
  strike: Scalars['numeric'];
  sync_at: Scalars['timestamptz'];
  token_to_maturity: Scalars['numeric'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
  weight_x: Scalars['numeric'];
  weight_y: Scalars['numeric'];
  yield_supply: Scalars['numeric'];
  yield_token: Scalars['String'];
};

/** aggregated selection of "laplace.collateral_rebalancing_pool" */
export type LaplaceCollateralRebalancingPoolAggregate = {
  __typename?: 'laplace_collateral_rebalancing_pool_aggregate';
  aggregate?: Maybe<LaplaceCollateralRebalancingPoolAggregateFields>;
  nodes: Array<LaplaceCollateralRebalancingPool>;
};

/** aggregate fields of "laplace.collateral_rebalancing_pool" */
export type LaplaceCollateralRebalancingPoolAggregateFields = {
  __typename?: 'laplace_collateral_rebalancing_pool_aggregate_fields';
  avg?: Maybe<LaplaceCollateralRebalancingPoolAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceCollateralRebalancingPoolMaxFields>;
  min?: Maybe<LaplaceCollateralRebalancingPoolMinFields>;
  stddev?: Maybe<LaplaceCollateralRebalancingPoolStddevFields>;
  stddev_pop?: Maybe<LaplaceCollateralRebalancingPoolStddevPopFields>;
  stddev_samp?: Maybe<LaplaceCollateralRebalancingPoolStddevSampFields>;
  sum?: Maybe<LaplaceCollateralRebalancingPoolSumFields>;
  var_pop?: Maybe<LaplaceCollateralRebalancingPoolVarPopFields>;
  var_samp?: Maybe<LaplaceCollateralRebalancingPoolVarSampFields>;
  variance?: Maybe<LaplaceCollateralRebalancingPoolVarianceFields>;
};


/** aggregate fields of "laplace.collateral_rebalancing_pool" */
export type LaplaceCollateralRebalancingPoolAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceCollateralRebalancingPoolSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LaplaceCollateralRebalancingPoolAvgFields = {
  __typename?: 'laplace_collateral_rebalancing_pool_avg_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  bs_vol?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  conversion_ltv?: Maybe<Scalars['Float']>;
  est_collateral_price?: Maybe<Scalars['Float']>;
  est_collateral_price_per_key_token?: Maybe<Scalars['Float']>;
  est_fwp_collateral_price?: Maybe<Scalars['Float']>;
  est_token_price_per_key_token?: Maybe<Scalars['Float']>;
  est_total_pool_value?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  final_collateral_per_share?: Maybe<Scalars['Float']>;
  final_token_per_share?: Maybe<Scalars['Float']>;
  key_supply?: Maybe<Scalars['Float']>;
  ltv_0?: Maybe<Scalars['Float']>;
  moving_average?: Maybe<Scalars['Float']>;
  strike?: Maybe<Scalars['Float']>;
  token_to_maturity?: Maybe<Scalars['Float']>;
  weight_x?: Maybe<Scalars['Float']>;
  weight_y?: Maybe<Scalars['Float']>;
  yield_supply?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.collateral_rebalancing_pool". All fields are combined with a logical 'AND'. */
export type LaplaceCollateralRebalancingPoolBoolExp = {
  _and?: InputMaybe<Array<LaplaceCollateralRebalancingPoolBoolExp>>;
  _not?: InputMaybe<LaplaceCollateralRebalancingPoolBoolExp>;
  _or?: InputMaybe<Array<LaplaceCollateralRebalancingPoolBoolExp>>;
  balance_x?: InputMaybe<NumericComparisonExp>;
  balance_y?: InputMaybe<NumericComparisonExp>;
  block_height?: InputMaybe<NumericComparisonExp>;
  bs_vol?: InputMaybe<NumericComparisonExp>;
  burn_block_time?: InputMaybe<NumericComparisonExp>;
  conversion_ltv?: InputMaybe<NumericComparisonExp>;
  est_collateral_price?: InputMaybe<NumericComparisonExp>;
  est_collateral_price_per_key_token?: InputMaybe<NumericComparisonExp>;
  est_fwp_collateral_price?: InputMaybe<NumericComparisonExp>;
  est_token_price_per_key_token?: InputMaybe<NumericComparisonExp>;
  est_total_pool_value?: InputMaybe<NumericComparisonExp>;
  expiry?: InputMaybe<NumericComparisonExp>;
  fee_rate_x?: InputMaybe<NumericComparisonExp>;
  fee_rate_y?: InputMaybe<NumericComparisonExp>;
  fee_rebate?: InputMaybe<NumericComparisonExp>;
  fee_to_address?: InputMaybe<StringComparisonExp>;
  final_collateral_per_share?: InputMaybe<NumericComparisonExp>;
  final_token_per_share?: InputMaybe<NumericComparisonExp>;
  key_supply?: InputMaybe<NumericComparisonExp>;
  key_token?: InputMaybe<StringComparisonExp>;
  ltv_0?: InputMaybe<NumericComparisonExp>;
  moving_average?: InputMaybe<NumericComparisonExp>;
  strike?: InputMaybe<NumericComparisonExp>;
  sync_at?: InputMaybe<TimestamptzComparisonExp>;
  token_to_maturity?: InputMaybe<NumericComparisonExp>;
  token_x?: InputMaybe<StringComparisonExp>;
  token_y?: InputMaybe<StringComparisonExp>;
  weight_x?: InputMaybe<NumericComparisonExp>;
  weight_y?: InputMaybe<NumericComparisonExp>;
  yield_supply?: InputMaybe<NumericComparisonExp>;
  yield_token?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "laplace.collateral_rebalancing_pool" */
export enum LaplaceCollateralRebalancingPoolConstraint {
  /** unique or primary key constraint on columns "block_height", "token_y", "expiry", "token_x" */
  CollateralRebalancingPoolPkey = 'collateral_rebalancing_pool_pkey'
}

/** input type for incrementing numeric columns in table "laplace.collateral_rebalancing_pool" */
export type LaplaceCollateralRebalancingPoolIncInput = {
  balance_x?: InputMaybe<Scalars['numeric']>;
  balance_y?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  bs_vol?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  conversion_ltv?: InputMaybe<Scalars['numeric']>;
  est_collateral_price?: InputMaybe<Scalars['numeric']>;
  est_collateral_price_per_key_token?: InputMaybe<Scalars['numeric']>;
  est_fwp_collateral_price?: InputMaybe<Scalars['numeric']>;
  est_token_price_per_key_token?: InputMaybe<Scalars['numeric']>;
  est_total_pool_value?: InputMaybe<Scalars['numeric']>;
  expiry?: InputMaybe<Scalars['numeric']>;
  fee_rate_x?: InputMaybe<Scalars['numeric']>;
  fee_rate_y?: InputMaybe<Scalars['numeric']>;
  fee_rebate?: InputMaybe<Scalars['numeric']>;
  final_collateral_per_share?: InputMaybe<Scalars['numeric']>;
  final_token_per_share?: InputMaybe<Scalars['numeric']>;
  key_supply?: InputMaybe<Scalars['numeric']>;
  ltv_0?: InputMaybe<Scalars['numeric']>;
  moving_average?: InputMaybe<Scalars['numeric']>;
  strike?: InputMaybe<Scalars['numeric']>;
  token_to_maturity?: InputMaybe<Scalars['numeric']>;
  weight_x?: InputMaybe<Scalars['numeric']>;
  weight_y?: InputMaybe<Scalars['numeric']>;
  yield_supply?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "laplace.collateral_rebalancing_pool" */
export type LaplaceCollateralRebalancingPoolInsertInput = {
  balance_x?: InputMaybe<Scalars['numeric']>;
  balance_y?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  bs_vol?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  conversion_ltv?: InputMaybe<Scalars['numeric']>;
  est_collateral_price?: InputMaybe<Scalars['numeric']>;
  est_collateral_price_per_key_token?: InputMaybe<Scalars['numeric']>;
  est_fwp_collateral_price?: InputMaybe<Scalars['numeric']>;
  est_token_price_per_key_token?: InputMaybe<Scalars['numeric']>;
  est_total_pool_value?: InputMaybe<Scalars['numeric']>;
  expiry?: InputMaybe<Scalars['numeric']>;
  fee_rate_x?: InputMaybe<Scalars['numeric']>;
  fee_rate_y?: InputMaybe<Scalars['numeric']>;
  fee_rebate?: InputMaybe<Scalars['numeric']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  final_collateral_per_share?: InputMaybe<Scalars['numeric']>;
  final_token_per_share?: InputMaybe<Scalars['numeric']>;
  key_supply?: InputMaybe<Scalars['numeric']>;
  key_token?: InputMaybe<Scalars['String']>;
  ltv_0?: InputMaybe<Scalars['numeric']>;
  moving_average?: InputMaybe<Scalars['numeric']>;
  strike?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_to_maturity?: InputMaybe<Scalars['numeric']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  weight_x?: InputMaybe<Scalars['numeric']>;
  weight_y?: InputMaybe<Scalars['numeric']>;
  yield_supply?: InputMaybe<Scalars['numeric']>;
  yield_token?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type LaplaceCollateralRebalancingPoolMaxFields = {
  __typename?: 'laplace_collateral_rebalancing_pool_max_fields';
  balance_x?: Maybe<Scalars['numeric']>;
  balance_y?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['numeric']>;
  bs_vol?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  conversion_ltv?: Maybe<Scalars['numeric']>;
  est_collateral_price?: Maybe<Scalars['numeric']>;
  est_collateral_price_per_key_token?: Maybe<Scalars['numeric']>;
  est_fwp_collateral_price?: Maybe<Scalars['numeric']>;
  est_token_price_per_key_token?: Maybe<Scalars['numeric']>;
  est_total_pool_value?: Maybe<Scalars['numeric']>;
  expiry?: Maybe<Scalars['numeric']>;
  fee_rate_x?: Maybe<Scalars['numeric']>;
  fee_rate_y?: Maybe<Scalars['numeric']>;
  fee_rebate?: Maybe<Scalars['numeric']>;
  fee_to_address?: Maybe<Scalars['String']>;
  final_collateral_per_share?: Maybe<Scalars['numeric']>;
  final_token_per_share?: Maybe<Scalars['numeric']>;
  key_supply?: Maybe<Scalars['numeric']>;
  key_token?: Maybe<Scalars['String']>;
  ltv_0?: Maybe<Scalars['numeric']>;
  moving_average?: Maybe<Scalars['numeric']>;
  strike?: Maybe<Scalars['numeric']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_to_maturity?: Maybe<Scalars['numeric']>;
  token_x?: Maybe<Scalars['String']>;
  token_y?: Maybe<Scalars['String']>;
  weight_x?: Maybe<Scalars['numeric']>;
  weight_y?: Maybe<Scalars['numeric']>;
  yield_supply?: Maybe<Scalars['numeric']>;
  yield_token?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LaplaceCollateralRebalancingPoolMinFields = {
  __typename?: 'laplace_collateral_rebalancing_pool_min_fields';
  balance_x?: Maybe<Scalars['numeric']>;
  balance_y?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['numeric']>;
  bs_vol?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  conversion_ltv?: Maybe<Scalars['numeric']>;
  est_collateral_price?: Maybe<Scalars['numeric']>;
  est_collateral_price_per_key_token?: Maybe<Scalars['numeric']>;
  est_fwp_collateral_price?: Maybe<Scalars['numeric']>;
  est_token_price_per_key_token?: Maybe<Scalars['numeric']>;
  est_total_pool_value?: Maybe<Scalars['numeric']>;
  expiry?: Maybe<Scalars['numeric']>;
  fee_rate_x?: Maybe<Scalars['numeric']>;
  fee_rate_y?: Maybe<Scalars['numeric']>;
  fee_rebate?: Maybe<Scalars['numeric']>;
  fee_to_address?: Maybe<Scalars['String']>;
  final_collateral_per_share?: Maybe<Scalars['numeric']>;
  final_token_per_share?: Maybe<Scalars['numeric']>;
  key_supply?: Maybe<Scalars['numeric']>;
  key_token?: Maybe<Scalars['String']>;
  ltv_0?: Maybe<Scalars['numeric']>;
  moving_average?: Maybe<Scalars['numeric']>;
  strike?: Maybe<Scalars['numeric']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_to_maturity?: Maybe<Scalars['numeric']>;
  token_x?: Maybe<Scalars['String']>;
  token_y?: Maybe<Scalars['String']>;
  weight_x?: Maybe<Scalars['numeric']>;
  weight_y?: Maybe<Scalars['numeric']>;
  yield_supply?: Maybe<Scalars['numeric']>;
  yield_token?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "laplace.collateral_rebalancing_pool" */
export type LaplaceCollateralRebalancingPoolMutationResponse = {
  __typename?: 'laplace_collateral_rebalancing_pool_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceCollateralRebalancingPool>;
};

/** on_conflict condition type for table "laplace.collateral_rebalancing_pool" */
export type LaplaceCollateralRebalancingPoolOnConflict = {
  constraint: LaplaceCollateralRebalancingPoolConstraint;
  update_columns?: Array<LaplaceCollateralRebalancingPoolUpdateColumn>;
  where?: InputMaybe<LaplaceCollateralRebalancingPoolBoolExp>;
};

/** Ordering options when selecting data from "laplace.collateral_rebalancing_pool". */
export type LaplaceCollateralRebalancingPoolOrderBy = {
  balance_x?: InputMaybe<OrderBy>;
  balance_y?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  bs_vol?: InputMaybe<OrderBy>;
  burn_block_time?: InputMaybe<OrderBy>;
  conversion_ltv?: InputMaybe<OrderBy>;
  est_collateral_price?: InputMaybe<OrderBy>;
  est_collateral_price_per_key_token?: InputMaybe<OrderBy>;
  est_fwp_collateral_price?: InputMaybe<OrderBy>;
  est_token_price_per_key_token?: InputMaybe<OrderBy>;
  est_total_pool_value?: InputMaybe<OrderBy>;
  expiry?: InputMaybe<OrderBy>;
  fee_rate_x?: InputMaybe<OrderBy>;
  fee_rate_y?: InputMaybe<OrderBy>;
  fee_rebate?: InputMaybe<OrderBy>;
  fee_to_address?: InputMaybe<OrderBy>;
  final_collateral_per_share?: InputMaybe<OrderBy>;
  final_token_per_share?: InputMaybe<OrderBy>;
  key_supply?: InputMaybe<OrderBy>;
  key_token?: InputMaybe<OrderBy>;
  ltv_0?: InputMaybe<OrderBy>;
  moving_average?: InputMaybe<OrderBy>;
  strike?: InputMaybe<OrderBy>;
  sync_at?: InputMaybe<OrderBy>;
  token_to_maturity?: InputMaybe<OrderBy>;
  token_x?: InputMaybe<OrderBy>;
  token_y?: InputMaybe<OrderBy>;
  weight_x?: InputMaybe<OrderBy>;
  weight_y?: InputMaybe<OrderBy>;
  yield_supply?: InputMaybe<OrderBy>;
  yield_token?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.collateral_rebalancing_pool */
export type LaplaceCollateralRebalancingPoolPkColumnsInput = {
  block_height: Scalars['numeric'];
  expiry: Scalars['numeric'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};

/** select columns of table "laplace.collateral_rebalancing_pool" */
export enum LaplaceCollateralRebalancingPoolSelectColumn {
  /** column name */
  BalanceX = 'balance_x',
  /** column name */
  BalanceY = 'balance_y',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BsVol = 'bs_vol',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  ConversionLtv = 'conversion_ltv',
  /** column name */
  EstCollateralPrice = 'est_collateral_price',
  /** column name */
  EstCollateralPricePerKeyToken = 'est_collateral_price_per_key_token',
  /** column name */
  EstFwpCollateralPrice = 'est_fwp_collateral_price',
  /** column name */
  EstTokenPricePerKeyToken = 'est_token_price_per_key_token',
  /** column name */
  EstTotalPoolValue = 'est_total_pool_value',
  /** column name */
  Expiry = 'expiry',
  /** column name */
  FeeRateX = 'fee_rate_x',
  /** column name */
  FeeRateY = 'fee_rate_y',
  /** column name */
  FeeRebate = 'fee_rebate',
  /** column name */
  FeeToAddress = 'fee_to_address',
  /** column name */
  FinalCollateralPerShare = 'final_collateral_per_share',
  /** column name */
  FinalTokenPerShare = 'final_token_per_share',
  /** column name */
  KeySupply = 'key_supply',
  /** column name */
  KeyToken = 'key_token',
  /** column name */
  Ltv_0 = 'ltv_0',
  /** column name */
  MovingAverage = 'moving_average',
  /** column name */
  Strike = 'strike',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenToMaturity = 'token_to_maturity',
  /** column name */
  TokenX = 'token_x',
  /** column name */
  TokenY = 'token_y',
  /** column name */
  WeightX = 'weight_x',
  /** column name */
  WeightY = 'weight_y',
  /** column name */
  YieldSupply = 'yield_supply',
  /** column name */
  YieldToken = 'yield_token'
}

/** input type for updating data in table "laplace.collateral_rebalancing_pool" */
export type LaplaceCollateralRebalancingPoolSetInput = {
  balance_x?: InputMaybe<Scalars['numeric']>;
  balance_y?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  bs_vol?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  conversion_ltv?: InputMaybe<Scalars['numeric']>;
  est_collateral_price?: InputMaybe<Scalars['numeric']>;
  est_collateral_price_per_key_token?: InputMaybe<Scalars['numeric']>;
  est_fwp_collateral_price?: InputMaybe<Scalars['numeric']>;
  est_token_price_per_key_token?: InputMaybe<Scalars['numeric']>;
  est_total_pool_value?: InputMaybe<Scalars['numeric']>;
  expiry?: InputMaybe<Scalars['numeric']>;
  fee_rate_x?: InputMaybe<Scalars['numeric']>;
  fee_rate_y?: InputMaybe<Scalars['numeric']>;
  fee_rebate?: InputMaybe<Scalars['numeric']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  final_collateral_per_share?: InputMaybe<Scalars['numeric']>;
  final_token_per_share?: InputMaybe<Scalars['numeric']>;
  key_supply?: InputMaybe<Scalars['numeric']>;
  key_token?: InputMaybe<Scalars['String']>;
  ltv_0?: InputMaybe<Scalars['numeric']>;
  moving_average?: InputMaybe<Scalars['numeric']>;
  strike?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_to_maturity?: InputMaybe<Scalars['numeric']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  weight_x?: InputMaybe<Scalars['numeric']>;
  weight_y?: InputMaybe<Scalars['numeric']>;
  yield_supply?: InputMaybe<Scalars['numeric']>;
  yield_token?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type LaplaceCollateralRebalancingPoolStddevFields = {
  __typename?: 'laplace_collateral_rebalancing_pool_stddev_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  bs_vol?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  conversion_ltv?: Maybe<Scalars['Float']>;
  est_collateral_price?: Maybe<Scalars['Float']>;
  est_collateral_price_per_key_token?: Maybe<Scalars['Float']>;
  est_fwp_collateral_price?: Maybe<Scalars['Float']>;
  est_token_price_per_key_token?: Maybe<Scalars['Float']>;
  est_total_pool_value?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  final_collateral_per_share?: Maybe<Scalars['Float']>;
  final_token_per_share?: Maybe<Scalars['Float']>;
  key_supply?: Maybe<Scalars['Float']>;
  ltv_0?: Maybe<Scalars['Float']>;
  moving_average?: Maybe<Scalars['Float']>;
  strike?: Maybe<Scalars['Float']>;
  token_to_maturity?: Maybe<Scalars['Float']>;
  weight_x?: Maybe<Scalars['Float']>;
  weight_y?: Maybe<Scalars['Float']>;
  yield_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceCollateralRebalancingPoolStddevPopFields = {
  __typename?: 'laplace_collateral_rebalancing_pool_stddev_pop_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  bs_vol?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  conversion_ltv?: Maybe<Scalars['Float']>;
  est_collateral_price?: Maybe<Scalars['Float']>;
  est_collateral_price_per_key_token?: Maybe<Scalars['Float']>;
  est_fwp_collateral_price?: Maybe<Scalars['Float']>;
  est_token_price_per_key_token?: Maybe<Scalars['Float']>;
  est_total_pool_value?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  final_collateral_per_share?: Maybe<Scalars['Float']>;
  final_token_per_share?: Maybe<Scalars['Float']>;
  key_supply?: Maybe<Scalars['Float']>;
  ltv_0?: Maybe<Scalars['Float']>;
  moving_average?: Maybe<Scalars['Float']>;
  strike?: Maybe<Scalars['Float']>;
  token_to_maturity?: Maybe<Scalars['Float']>;
  weight_x?: Maybe<Scalars['Float']>;
  weight_y?: Maybe<Scalars['Float']>;
  yield_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceCollateralRebalancingPoolStddevSampFields = {
  __typename?: 'laplace_collateral_rebalancing_pool_stddev_samp_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  bs_vol?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  conversion_ltv?: Maybe<Scalars['Float']>;
  est_collateral_price?: Maybe<Scalars['Float']>;
  est_collateral_price_per_key_token?: Maybe<Scalars['Float']>;
  est_fwp_collateral_price?: Maybe<Scalars['Float']>;
  est_token_price_per_key_token?: Maybe<Scalars['Float']>;
  est_total_pool_value?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  final_collateral_per_share?: Maybe<Scalars['Float']>;
  final_token_per_share?: Maybe<Scalars['Float']>;
  key_supply?: Maybe<Scalars['Float']>;
  ltv_0?: Maybe<Scalars['Float']>;
  moving_average?: Maybe<Scalars['Float']>;
  strike?: Maybe<Scalars['Float']>;
  token_to_maturity?: Maybe<Scalars['Float']>;
  weight_x?: Maybe<Scalars['Float']>;
  weight_y?: Maybe<Scalars['Float']>;
  yield_supply?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_collateral_rebalancing_pool" */
export type LaplaceCollateralRebalancingPoolStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceCollateralRebalancingPoolStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceCollateralRebalancingPoolStreamCursorValueInput = {
  balance_x?: InputMaybe<Scalars['numeric']>;
  balance_y?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  bs_vol?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  conversion_ltv?: InputMaybe<Scalars['numeric']>;
  est_collateral_price?: InputMaybe<Scalars['numeric']>;
  est_collateral_price_per_key_token?: InputMaybe<Scalars['numeric']>;
  est_fwp_collateral_price?: InputMaybe<Scalars['numeric']>;
  est_token_price_per_key_token?: InputMaybe<Scalars['numeric']>;
  est_total_pool_value?: InputMaybe<Scalars['numeric']>;
  expiry?: InputMaybe<Scalars['numeric']>;
  fee_rate_x?: InputMaybe<Scalars['numeric']>;
  fee_rate_y?: InputMaybe<Scalars['numeric']>;
  fee_rebate?: InputMaybe<Scalars['numeric']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  final_collateral_per_share?: InputMaybe<Scalars['numeric']>;
  final_token_per_share?: InputMaybe<Scalars['numeric']>;
  key_supply?: InputMaybe<Scalars['numeric']>;
  key_token?: InputMaybe<Scalars['String']>;
  ltv_0?: InputMaybe<Scalars['numeric']>;
  moving_average?: InputMaybe<Scalars['numeric']>;
  strike?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_to_maturity?: InputMaybe<Scalars['numeric']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  weight_x?: InputMaybe<Scalars['numeric']>;
  weight_y?: InputMaybe<Scalars['numeric']>;
  yield_supply?: InputMaybe<Scalars['numeric']>;
  yield_token?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type LaplaceCollateralRebalancingPoolSumFields = {
  __typename?: 'laplace_collateral_rebalancing_pool_sum_fields';
  balance_x?: Maybe<Scalars['numeric']>;
  balance_y?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['numeric']>;
  bs_vol?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  conversion_ltv?: Maybe<Scalars['numeric']>;
  est_collateral_price?: Maybe<Scalars['numeric']>;
  est_collateral_price_per_key_token?: Maybe<Scalars['numeric']>;
  est_fwp_collateral_price?: Maybe<Scalars['numeric']>;
  est_token_price_per_key_token?: Maybe<Scalars['numeric']>;
  est_total_pool_value?: Maybe<Scalars['numeric']>;
  expiry?: Maybe<Scalars['numeric']>;
  fee_rate_x?: Maybe<Scalars['numeric']>;
  fee_rate_y?: Maybe<Scalars['numeric']>;
  fee_rebate?: Maybe<Scalars['numeric']>;
  final_collateral_per_share?: Maybe<Scalars['numeric']>;
  final_token_per_share?: Maybe<Scalars['numeric']>;
  key_supply?: Maybe<Scalars['numeric']>;
  ltv_0?: Maybe<Scalars['numeric']>;
  moving_average?: Maybe<Scalars['numeric']>;
  strike?: Maybe<Scalars['numeric']>;
  token_to_maturity?: Maybe<Scalars['numeric']>;
  weight_x?: Maybe<Scalars['numeric']>;
  weight_y?: Maybe<Scalars['numeric']>;
  yield_supply?: Maybe<Scalars['numeric']>;
};

/** update columns of table "laplace.collateral_rebalancing_pool" */
export enum LaplaceCollateralRebalancingPoolUpdateColumn {
  /** column name */
  BalanceX = 'balance_x',
  /** column name */
  BalanceY = 'balance_y',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BsVol = 'bs_vol',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  ConversionLtv = 'conversion_ltv',
  /** column name */
  EstCollateralPrice = 'est_collateral_price',
  /** column name */
  EstCollateralPricePerKeyToken = 'est_collateral_price_per_key_token',
  /** column name */
  EstFwpCollateralPrice = 'est_fwp_collateral_price',
  /** column name */
  EstTokenPricePerKeyToken = 'est_token_price_per_key_token',
  /** column name */
  EstTotalPoolValue = 'est_total_pool_value',
  /** column name */
  Expiry = 'expiry',
  /** column name */
  FeeRateX = 'fee_rate_x',
  /** column name */
  FeeRateY = 'fee_rate_y',
  /** column name */
  FeeRebate = 'fee_rebate',
  /** column name */
  FeeToAddress = 'fee_to_address',
  /** column name */
  FinalCollateralPerShare = 'final_collateral_per_share',
  /** column name */
  FinalTokenPerShare = 'final_token_per_share',
  /** column name */
  KeySupply = 'key_supply',
  /** column name */
  KeyToken = 'key_token',
  /** column name */
  Ltv_0 = 'ltv_0',
  /** column name */
  MovingAverage = 'moving_average',
  /** column name */
  Strike = 'strike',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenToMaturity = 'token_to_maturity',
  /** column name */
  TokenX = 'token_x',
  /** column name */
  TokenY = 'token_y',
  /** column name */
  WeightX = 'weight_x',
  /** column name */
  WeightY = 'weight_y',
  /** column name */
  YieldSupply = 'yield_supply',
  /** column name */
  YieldToken = 'yield_token'
}

export type LaplaceCollateralRebalancingPoolUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceCollateralRebalancingPoolIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceCollateralRebalancingPoolSetInput>;
  where: LaplaceCollateralRebalancingPoolBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceCollateralRebalancingPoolVarPopFields = {
  __typename?: 'laplace_collateral_rebalancing_pool_var_pop_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  bs_vol?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  conversion_ltv?: Maybe<Scalars['Float']>;
  est_collateral_price?: Maybe<Scalars['Float']>;
  est_collateral_price_per_key_token?: Maybe<Scalars['Float']>;
  est_fwp_collateral_price?: Maybe<Scalars['Float']>;
  est_token_price_per_key_token?: Maybe<Scalars['Float']>;
  est_total_pool_value?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  final_collateral_per_share?: Maybe<Scalars['Float']>;
  final_token_per_share?: Maybe<Scalars['Float']>;
  key_supply?: Maybe<Scalars['Float']>;
  ltv_0?: Maybe<Scalars['Float']>;
  moving_average?: Maybe<Scalars['Float']>;
  strike?: Maybe<Scalars['Float']>;
  token_to_maturity?: Maybe<Scalars['Float']>;
  weight_x?: Maybe<Scalars['Float']>;
  weight_y?: Maybe<Scalars['Float']>;
  yield_supply?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceCollateralRebalancingPoolVarSampFields = {
  __typename?: 'laplace_collateral_rebalancing_pool_var_samp_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  bs_vol?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  conversion_ltv?: Maybe<Scalars['Float']>;
  est_collateral_price?: Maybe<Scalars['Float']>;
  est_collateral_price_per_key_token?: Maybe<Scalars['Float']>;
  est_fwp_collateral_price?: Maybe<Scalars['Float']>;
  est_token_price_per_key_token?: Maybe<Scalars['Float']>;
  est_total_pool_value?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  final_collateral_per_share?: Maybe<Scalars['Float']>;
  final_token_per_share?: Maybe<Scalars['Float']>;
  key_supply?: Maybe<Scalars['Float']>;
  ltv_0?: Maybe<Scalars['Float']>;
  moving_average?: Maybe<Scalars['Float']>;
  strike?: Maybe<Scalars['Float']>;
  token_to_maturity?: Maybe<Scalars['Float']>;
  weight_x?: Maybe<Scalars['Float']>;
  weight_y?: Maybe<Scalars['Float']>;
  yield_supply?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceCollateralRebalancingPoolVarianceFields = {
  __typename?: 'laplace_collateral_rebalancing_pool_variance_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  bs_vol?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  conversion_ltv?: Maybe<Scalars['Float']>;
  est_collateral_price?: Maybe<Scalars['Float']>;
  est_collateral_price_per_key_token?: Maybe<Scalars['Float']>;
  est_fwp_collateral_price?: Maybe<Scalars['Float']>;
  est_token_price_per_key_token?: Maybe<Scalars['Float']>;
  est_total_pool_value?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  final_collateral_per_share?: Maybe<Scalars['Float']>;
  final_token_per_share?: Maybe<Scalars['Float']>;
  key_supply?: Maybe<Scalars['Float']>;
  ltv_0?: Maybe<Scalars['Float']>;
  moving_average?: Maybe<Scalars['Float']>;
  strike?: Maybe<Scalars['Float']>;
  token_to_maturity?: Maybe<Scalars['Float']>;
  weight_x?: Maybe<Scalars['Float']>;
  weight_y?: Maybe<Scalars['Float']>;
  yield_supply?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "laplace.config_contracts" */
export type LaplaceConfigContracts = {
  __typename?: 'laplace_config_contracts';
  contract: Scalars['String'];
  full_name?: Maybe<Scalars['String']>;
};

/** aggregated selection of "laplace.config_contracts" */
export type LaplaceConfigContractsAggregate = {
  __typename?: 'laplace_config_contracts_aggregate';
  aggregate?: Maybe<LaplaceConfigContractsAggregateFields>;
  nodes: Array<LaplaceConfigContracts>;
};

/** aggregate fields of "laplace.config_contracts" */
export type LaplaceConfigContractsAggregateFields = {
  __typename?: 'laplace_config_contracts_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<LaplaceConfigContractsMaxFields>;
  min?: Maybe<LaplaceConfigContractsMinFields>;
};


/** aggregate fields of "laplace.config_contracts" */
export type LaplaceConfigContractsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceConfigContractsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "laplace.config_contracts". All fields are combined with a logical 'AND'. */
export type LaplaceConfigContractsBoolExp = {
  _and?: InputMaybe<Array<LaplaceConfigContractsBoolExp>>;
  _not?: InputMaybe<LaplaceConfigContractsBoolExp>;
  _or?: InputMaybe<Array<LaplaceConfigContractsBoolExp>>;
  contract?: InputMaybe<StringComparisonExp>;
  full_name?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "laplace.config_contracts" */
export enum LaplaceConfigContractsConstraint {
  /** unique or primary key constraint on columns "contract" */
  ConfigContractsPkey = 'config_contracts_pkey'
}

/** input type for inserting data into table "laplace.config_contracts" */
export type LaplaceConfigContractsInsertInput = {
  contract?: InputMaybe<Scalars['String']>;
  full_name?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type LaplaceConfigContractsMaxFields = {
  __typename?: 'laplace_config_contracts_max_fields';
  contract?: Maybe<Scalars['String']>;
  full_name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LaplaceConfigContractsMinFields = {
  __typename?: 'laplace_config_contracts_min_fields';
  contract?: Maybe<Scalars['String']>;
  full_name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "laplace.config_contracts" */
export type LaplaceConfigContractsMutationResponse = {
  __typename?: 'laplace_config_contracts_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceConfigContracts>;
};

/** on_conflict condition type for table "laplace.config_contracts" */
export type LaplaceConfigContractsOnConflict = {
  constraint: LaplaceConfigContractsConstraint;
  update_columns?: Array<LaplaceConfigContractsUpdateColumn>;
  where?: InputMaybe<LaplaceConfigContractsBoolExp>;
};

/** Ordering options when selecting data from "laplace.config_contracts". */
export type LaplaceConfigContractsOrderBy = {
  contract?: InputMaybe<OrderBy>;
  full_name?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.config_contracts */
export type LaplaceConfigContractsPkColumnsInput = {
  contract: Scalars['String'];
};

/** select columns of table "laplace.config_contracts" */
export enum LaplaceConfigContractsSelectColumn {
  /** column name */
  Contract = 'contract',
  /** column name */
  FullName = 'full_name'
}

/** input type for updating data in table "laplace.config_contracts" */
export type LaplaceConfigContractsSetInput = {
  contract?: InputMaybe<Scalars['String']>;
  full_name?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "laplace_config_contracts" */
export type LaplaceConfigContractsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceConfigContractsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceConfigContractsStreamCursorValueInput = {
  contract?: InputMaybe<Scalars['String']>;
  full_name?: InputMaybe<Scalars['String']>;
};

/** update columns of table "laplace.config_contracts" */
export enum LaplaceConfigContractsUpdateColumn {
  /** column name */
  Contract = 'contract',
  /** column name */
  FullName = 'full_name'
}

export type LaplaceConfigContractsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceConfigContractsSetInput>;
  where: LaplaceConfigContractsBoolExp;
};

/** Contract function calls index by function signature */
export type LaplaceContractCalls = {
  __typename?: 'laplace_contract_calls';
  anchor_mode: Scalars['smallint'];
  arg1?: Maybe<Scalars['String']>;
  arg2?: Maybe<Scalars['String']>;
  arg3?: Maybe<Scalars['String']>;
  arg4?: Maybe<Scalars['String']>;
  arg5?: Maybe<Scalars['String']>;
  block_height: Scalars['Int'];
  contract_id: Scalars['String'];
  contract_name: Scalars['String'];
  events: Scalars['jsonb'];
  execution_cost_read_count: Scalars['bigint'];
  execution_cost_read_length: Scalars['bigint'];
  execution_cost_runtime: Scalars['bigint'];
  execution_cost_write_count: Scalars['bigint'];
  execution_cost_write_length: Scalars['bigint'];
  fee_rate: Scalars['bigint'];
  function_args: Scalars['jsonb'];
  function_name: Scalars['String'];
  nonce: Scalars['Int'];
  sender_address: Scalars['String'];
  transaction_result: Scalars['jsonb'];
  transaction_result_type: Scalars['String'];
  tx_id: Scalars['bytea'];
};


/** Contract function calls index by function signature */
export type LaplaceContractCallsEventsArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** Contract function calls index by function signature */
export type LaplaceContractCallsFunctionArgsArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** Contract function calls index by function signature */
export type LaplaceContractCallsTransactionResultArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "laplace.contract_calls" */
export type LaplaceContractCallsAggregate = {
  __typename?: 'laplace_contract_calls_aggregate';
  aggregate?: Maybe<LaplaceContractCallsAggregateFields>;
  nodes: Array<LaplaceContractCalls>;
};

/** aggregate fields of "laplace.contract_calls" */
export type LaplaceContractCallsAggregateFields = {
  __typename?: 'laplace_contract_calls_aggregate_fields';
  avg?: Maybe<LaplaceContractCallsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceContractCallsMaxFields>;
  min?: Maybe<LaplaceContractCallsMinFields>;
  stddev?: Maybe<LaplaceContractCallsStddevFields>;
  stddev_pop?: Maybe<LaplaceContractCallsStddevPopFields>;
  stddev_samp?: Maybe<LaplaceContractCallsStddevSampFields>;
  sum?: Maybe<LaplaceContractCallsSumFields>;
  var_pop?: Maybe<LaplaceContractCallsVarPopFields>;
  var_samp?: Maybe<LaplaceContractCallsVarSampFields>;
  variance?: Maybe<LaplaceContractCallsVarianceFields>;
};


/** aggregate fields of "laplace.contract_calls" */
export type LaplaceContractCallsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceContractCallsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type LaplaceContractCallsAppendInput = {
  events?: InputMaybe<Scalars['jsonb']>;
  function_args?: InputMaybe<Scalars['jsonb']>;
  transaction_result?: InputMaybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type LaplaceContractCallsAvgFields = {
  __typename?: 'laplace_contract_calls_avg_fields';
  anchor_mode?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  execution_cost_read_count?: Maybe<Scalars['Float']>;
  execution_cost_read_length?: Maybe<Scalars['Float']>;
  execution_cost_runtime?: Maybe<Scalars['Float']>;
  execution_cost_write_count?: Maybe<Scalars['Float']>;
  execution_cost_write_length?: Maybe<Scalars['Float']>;
  fee_rate?: Maybe<Scalars['Float']>;
  nonce?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.contract_calls". All fields are combined with a logical 'AND'. */
export type LaplaceContractCallsBoolExp = {
  _and?: InputMaybe<Array<LaplaceContractCallsBoolExp>>;
  _not?: InputMaybe<LaplaceContractCallsBoolExp>;
  _or?: InputMaybe<Array<LaplaceContractCallsBoolExp>>;
  anchor_mode?: InputMaybe<SmallintComparisonExp>;
  arg1?: InputMaybe<StringComparisonExp>;
  arg2?: InputMaybe<StringComparisonExp>;
  arg3?: InputMaybe<StringComparisonExp>;
  arg4?: InputMaybe<StringComparisonExp>;
  arg5?: InputMaybe<StringComparisonExp>;
  block_height?: InputMaybe<IntComparisonExp>;
  contract_id?: InputMaybe<StringComparisonExp>;
  contract_name?: InputMaybe<StringComparisonExp>;
  events?: InputMaybe<JsonbComparisonExp>;
  execution_cost_read_count?: InputMaybe<BigintComparisonExp>;
  execution_cost_read_length?: InputMaybe<BigintComparisonExp>;
  execution_cost_runtime?: InputMaybe<BigintComparisonExp>;
  execution_cost_write_count?: InputMaybe<BigintComparisonExp>;
  execution_cost_write_length?: InputMaybe<BigintComparisonExp>;
  fee_rate?: InputMaybe<BigintComparisonExp>;
  function_args?: InputMaybe<JsonbComparisonExp>;
  function_name?: InputMaybe<StringComparisonExp>;
  nonce?: InputMaybe<IntComparisonExp>;
  sender_address?: InputMaybe<StringComparisonExp>;
  transaction_result?: InputMaybe<JsonbComparisonExp>;
  transaction_result_type?: InputMaybe<StringComparisonExp>;
  tx_id?: InputMaybe<ByteaComparisonExp>;
};

/** unique or primary key constraints on table "laplace.contract_calls" */
export enum LaplaceContractCallsConstraint {
  /** unique or primary key constraint on columns "block_height", "tx_id" */
  ContractCallsPkey = 'contract_calls_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type LaplaceContractCallsDeleteAtPathInput = {
  events?: InputMaybe<Array<Scalars['String']>>;
  function_args?: InputMaybe<Array<Scalars['String']>>;
  transaction_result?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type LaplaceContractCallsDeleteElemInput = {
  events?: InputMaybe<Scalars['Int']>;
  function_args?: InputMaybe<Scalars['Int']>;
  transaction_result?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type LaplaceContractCallsDeleteKeyInput = {
  events?: InputMaybe<Scalars['String']>;
  function_args?: InputMaybe<Scalars['String']>;
  transaction_result?: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "laplace.contract_calls" */
export type LaplaceContractCallsIncInput = {
  anchor_mode?: InputMaybe<Scalars['smallint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  execution_cost_read_count?: InputMaybe<Scalars['bigint']>;
  execution_cost_read_length?: InputMaybe<Scalars['bigint']>;
  execution_cost_runtime?: InputMaybe<Scalars['bigint']>;
  execution_cost_write_count?: InputMaybe<Scalars['bigint']>;
  execution_cost_write_length?: InputMaybe<Scalars['bigint']>;
  fee_rate?: InputMaybe<Scalars['bigint']>;
  nonce?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "laplace.contract_calls" */
export type LaplaceContractCallsInsertInput = {
  anchor_mode?: InputMaybe<Scalars['smallint']>;
  arg1?: InputMaybe<Scalars['String']>;
  arg2?: InputMaybe<Scalars['String']>;
  arg3?: InputMaybe<Scalars['String']>;
  arg4?: InputMaybe<Scalars['String']>;
  arg5?: InputMaybe<Scalars['String']>;
  block_height?: InputMaybe<Scalars['Int']>;
  contract_id?: InputMaybe<Scalars['String']>;
  contract_name?: InputMaybe<Scalars['String']>;
  events?: InputMaybe<Scalars['jsonb']>;
  execution_cost_read_count?: InputMaybe<Scalars['bigint']>;
  execution_cost_read_length?: InputMaybe<Scalars['bigint']>;
  execution_cost_runtime?: InputMaybe<Scalars['bigint']>;
  execution_cost_write_count?: InputMaybe<Scalars['bigint']>;
  execution_cost_write_length?: InputMaybe<Scalars['bigint']>;
  fee_rate?: InputMaybe<Scalars['bigint']>;
  function_args?: InputMaybe<Scalars['jsonb']>;
  function_name?: InputMaybe<Scalars['String']>;
  nonce?: InputMaybe<Scalars['Int']>;
  sender_address?: InputMaybe<Scalars['String']>;
  transaction_result?: InputMaybe<Scalars['jsonb']>;
  transaction_result_type?: InputMaybe<Scalars['String']>;
  tx_id?: InputMaybe<Scalars['bytea']>;
};

/** aggregate max on columns */
export type LaplaceContractCallsMaxFields = {
  __typename?: 'laplace_contract_calls_max_fields';
  anchor_mode?: Maybe<Scalars['smallint']>;
  arg1?: Maybe<Scalars['String']>;
  arg2?: Maybe<Scalars['String']>;
  arg3?: Maybe<Scalars['String']>;
  arg4?: Maybe<Scalars['String']>;
  arg5?: Maybe<Scalars['String']>;
  block_height?: Maybe<Scalars['Int']>;
  contract_id?: Maybe<Scalars['String']>;
  contract_name?: Maybe<Scalars['String']>;
  execution_cost_read_count?: Maybe<Scalars['bigint']>;
  execution_cost_read_length?: Maybe<Scalars['bigint']>;
  execution_cost_runtime?: Maybe<Scalars['bigint']>;
  execution_cost_write_count?: Maybe<Scalars['bigint']>;
  execution_cost_write_length?: Maybe<Scalars['bigint']>;
  fee_rate?: Maybe<Scalars['bigint']>;
  function_name?: Maybe<Scalars['String']>;
  nonce?: Maybe<Scalars['Int']>;
  sender_address?: Maybe<Scalars['String']>;
  transaction_result_type?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LaplaceContractCallsMinFields = {
  __typename?: 'laplace_contract_calls_min_fields';
  anchor_mode?: Maybe<Scalars['smallint']>;
  arg1?: Maybe<Scalars['String']>;
  arg2?: Maybe<Scalars['String']>;
  arg3?: Maybe<Scalars['String']>;
  arg4?: Maybe<Scalars['String']>;
  arg5?: Maybe<Scalars['String']>;
  block_height?: Maybe<Scalars['Int']>;
  contract_id?: Maybe<Scalars['String']>;
  contract_name?: Maybe<Scalars['String']>;
  execution_cost_read_count?: Maybe<Scalars['bigint']>;
  execution_cost_read_length?: Maybe<Scalars['bigint']>;
  execution_cost_runtime?: Maybe<Scalars['bigint']>;
  execution_cost_write_count?: Maybe<Scalars['bigint']>;
  execution_cost_write_length?: Maybe<Scalars['bigint']>;
  fee_rate?: Maybe<Scalars['bigint']>;
  function_name?: Maybe<Scalars['String']>;
  nonce?: Maybe<Scalars['Int']>;
  sender_address?: Maybe<Scalars['String']>;
  transaction_result_type?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "laplace.contract_calls" */
export type LaplaceContractCallsMutationResponse = {
  __typename?: 'laplace_contract_calls_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceContractCalls>;
};

/** on_conflict condition type for table "laplace.contract_calls" */
export type LaplaceContractCallsOnConflict = {
  constraint: LaplaceContractCallsConstraint;
  update_columns?: Array<LaplaceContractCallsUpdateColumn>;
  where?: InputMaybe<LaplaceContractCallsBoolExp>;
};

/** Ordering options when selecting data from "laplace.contract_calls". */
export type LaplaceContractCallsOrderBy = {
  anchor_mode?: InputMaybe<OrderBy>;
  arg1?: InputMaybe<OrderBy>;
  arg2?: InputMaybe<OrderBy>;
  arg3?: InputMaybe<OrderBy>;
  arg4?: InputMaybe<OrderBy>;
  arg5?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  contract_id?: InputMaybe<OrderBy>;
  contract_name?: InputMaybe<OrderBy>;
  events?: InputMaybe<OrderBy>;
  execution_cost_read_count?: InputMaybe<OrderBy>;
  execution_cost_read_length?: InputMaybe<OrderBy>;
  execution_cost_runtime?: InputMaybe<OrderBy>;
  execution_cost_write_count?: InputMaybe<OrderBy>;
  execution_cost_write_length?: InputMaybe<OrderBy>;
  fee_rate?: InputMaybe<OrderBy>;
  function_args?: InputMaybe<OrderBy>;
  function_name?: InputMaybe<OrderBy>;
  nonce?: InputMaybe<OrderBy>;
  sender_address?: InputMaybe<OrderBy>;
  transaction_result?: InputMaybe<OrderBy>;
  transaction_result_type?: InputMaybe<OrderBy>;
  tx_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.contract_calls */
export type LaplaceContractCallsPkColumnsInput = {
  block_height: Scalars['Int'];
  tx_id: Scalars['bytea'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type LaplaceContractCallsPrependInput = {
  events?: InputMaybe<Scalars['jsonb']>;
  function_args?: InputMaybe<Scalars['jsonb']>;
  transaction_result?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "laplace.contract_calls" */
export enum LaplaceContractCallsSelectColumn {
  /** column name */
  AnchorMode = 'anchor_mode',
  /** column name */
  Arg1 = 'arg1',
  /** column name */
  Arg2 = 'arg2',
  /** column name */
  Arg3 = 'arg3',
  /** column name */
  Arg4 = 'arg4',
  /** column name */
  Arg5 = 'arg5',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  ContractId = 'contract_id',
  /** column name */
  ContractName = 'contract_name',
  /** column name */
  Events = 'events',
  /** column name */
  ExecutionCostReadCount = 'execution_cost_read_count',
  /** column name */
  ExecutionCostReadLength = 'execution_cost_read_length',
  /** column name */
  ExecutionCostRuntime = 'execution_cost_runtime',
  /** column name */
  ExecutionCostWriteCount = 'execution_cost_write_count',
  /** column name */
  ExecutionCostWriteLength = 'execution_cost_write_length',
  /** column name */
  FeeRate = 'fee_rate',
  /** column name */
  FunctionArgs = 'function_args',
  /** column name */
  FunctionName = 'function_name',
  /** column name */
  Nonce = 'nonce',
  /** column name */
  SenderAddress = 'sender_address',
  /** column name */
  TransactionResult = 'transaction_result',
  /** column name */
  TransactionResultType = 'transaction_result_type',
  /** column name */
  TxId = 'tx_id'
}

/** input type for updating data in table "laplace.contract_calls" */
export type LaplaceContractCallsSetInput = {
  anchor_mode?: InputMaybe<Scalars['smallint']>;
  arg1?: InputMaybe<Scalars['String']>;
  arg2?: InputMaybe<Scalars['String']>;
  arg3?: InputMaybe<Scalars['String']>;
  arg4?: InputMaybe<Scalars['String']>;
  arg5?: InputMaybe<Scalars['String']>;
  block_height?: InputMaybe<Scalars['Int']>;
  contract_id?: InputMaybe<Scalars['String']>;
  contract_name?: InputMaybe<Scalars['String']>;
  events?: InputMaybe<Scalars['jsonb']>;
  execution_cost_read_count?: InputMaybe<Scalars['bigint']>;
  execution_cost_read_length?: InputMaybe<Scalars['bigint']>;
  execution_cost_runtime?: InputMaybe<Scalars['bigint']>;
  execution_cost_write_count?: InputMaybe<Scalars['bigint']>;
  execution_cost_write_length?: InputMaybe<Scalars['bigint']>;
  fee_rate?: InputMaybe<Scalars['bigint']>;
  function_args?: InputMaybe<Scalars['jsonb']>;
  function_name?: InputMaybe<Scalars['String']>;
  nonce?: InputMaybe<Scalars['Int']>;
  sender_address?: InputMaybe<Scalars['String']>;
  transaction_result?: InputMaybe<Scalars['jsonb']>;
  transaction_result_type?: InputMaybe<Scalars['String']>;
  tx_id?: InputMaybe<Scalars['bytea']>;
};

/** aggregate stddev on columns */
export type LaplaceContractCallsStddevFields = {
  __typename?: 'laplace_contract_calls_stddev_fields';
  anchor_mode?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  execution_cost_read_count?: Maybe<Scalars['Float']>;
  execution_cost_read_length?: Maybe<Scalars['Float']>;
  execution_cost_runtime?: Maybe<Scalars['Float']>;
  execution_cost_write_count?: Maybe<Scalars['Float']>;
  execution_cost_write_length?: Maybe<Scalars['Float']>;
  fee_rate?: Maybe<Scalars['Float']>;
  nonce?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceContractCallsStddevPopFields = {
  __typename?: 'laplace_contract_calls_stddev_pop_fields';
  anchor_mode?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  execution_cost_read_count?: Maybe<Scalars['Float']>;
  execution_cost_read_length?: Maybe<Scalars['Float']>;
  execution_cost_runtime?: Maybe<Scalars['Float']>;
  execution_cost_write_count?: Maybe<Scalars['Float']>;
  execution_cost_write_length?: Maybe<Scalars['Float']>;
  fee_rate?: Maybe<Scalars['Float']>;
  nonce?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceContractCallsStddevSampFields = {
  __typename?: 'laplace_contract_calls_stddev_samp_fields';
  anchor_mode?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  execution_cost_read_count?: Maybe<Scalars['Float']>;
  execution_cost_read_length?: Maybe<Scalars['Float']>;
  execution_cost_runtime?: Maybe<Scalars['Float']>;
  execution_cost_write_count?: Maybe<Scalars['Float']>;
  execution_cost_write_length?: Maybe<Scalars['Float']>;
  fee_rate?: Maybe<Scalars['Float']>;
  nonce?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_contract_calls" */
export type LaplaceContractCallsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceContractCallsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceContractCallsStreamCursorValueInput = {
  anchor_mode?: InputMaybe<Scalars['smallint']>;
  arg1?: InputMaybe<Scalars['String']>;
  arg2?: InputMaybe<Scalars['String']>;
  arg3?: InputMaybe<Scalars['String']>;
  arg4?: InputMaybe<Scalars['String']>;
  arg5?: InputMaybe<Scalars['String']>;
  block_height?: InputMaybe<Scalars['Int']>;
  contract_id?: InputMaybe<Scalars['String']>;
  contract_name?: InputMaybe<Scalars['String']>;
  events?: InputMaybe<Scalars['jsonb']>;
  execution_cost_read_count?: InputMaybe<Scalars['bigint']>;
  execution_cost_read_length?: InputMaybe<Scalars['bigint']>;
  execution_cost_runtime?: InputMaybe<Scalars['bigint']>;
  execution_cost_write_count?: InputMaybe<Scalars['bigint']>;
  execution_cost_write_length?: InputMaybe<Scalars['bigint']>;
  fee_rate?: InputMaybe<Scalars['bigint']>;
  function_args?: InputMaybe<Scalars['jsonb']>;
  function_name?: InputMaybe<Scalars['String']>;
  nonce?: InputMaybe<Scalars['Int']>;
  sender_address?: InputMaybe<Scalars['String']>;
  transaction_result?: InputMaybe<Scalars['jsonb']>;
  transaction_result_type?: InputMaybe<Scalars['String']>;
  tx_id?: InputMaybe<Scalars['bytea']>;
};

/** aggregate sum on columns */
export type LaplaceContractCallsSumFields = {
  __typename?: 'laplace_contract_calls_sum_fields';
  anchor_mode?: Maybe<Scalars['smallint']>;
  block_height?: Maybe<Scalars['Int']>;
  execution_cost_read_count?: Maybe<Scalars['bigint']>;
  execution_cost_read_length?: Maybe<Scalars['bigint']>;
  execution_cost_runtime?: Maybe<Scalars['bigint']>;
  execution_cost_write_count?: Maybe<Scalars['bigint']>;
  execution_cost_write_length?: Maybe<Scalars['bigint']>;
  fee_rate?: Maybe<Scalars['bigint']>;
  nonce?: Maybe<Scalars['Int']>;
};

/** update columns of table "laplace.contract_calls" */
export enum LaplaceContractCallsUpdateColumn {
  /** column name */
  AnchorMode = 'anchor_mode',
  /** column name */
  Arg1 = 'arg1',
  /** column name */
  Arg2 = 'arg2',
  /** column name */
  Arg3 = 'arg3',
  /** column name */
  Arg4 = 'arg4',
  /** column name */
  Arg5 = 'arg5',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  ContractId = 'contract_id',
  /** column name */
  ContractName = 'contract_name',
  /** column name */
  Events = 'events',
  /** column name */
  ExecutionCostReadCount = 'execution_cost_read_count',
  /** column name */
  ExecutionCostReadLength = 'execution_cost_read_length',
  /** column name */
  ExecutionCostRuntime = 'execution_cost_runtime',
  /** column name */
  ExecutionCostWriteCount = 'execution_cost_write_count',
  /** column name */
  ExecutionCostWriteLength = 'execution_cost_write_length',
  /** column name */
  FeeRate = 'fee_rate',
  /** column name */
  FunctionArgs = 'function_args',
  /** column name */
  FunctionName = 'function_name',
  /** column name */
  Nonce = 'nonce',
  /** column name */
  SenderAddress = 'sender_address',
  /** column name */
  TransactionResult = 'transaction_result',
  /** column name */
  TransactionResultType = 'transaction_result_type',
  /** column name */
  TxId = 'tx_id'
}

export type LaplaceContractCallsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<LaplaceContractCallsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<LaplaceContractCallsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<LaplaceContractCallsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<LaplaceContractCallsDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceContractCallsIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<LaplaceContractCallsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceContractCallsSetInput>;
  where: LaplaceContractCallsBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceContractCallsVarPopFields = {
  __typename?: 'laplace_contract_calls_var_pop_fields';
  anchor_mode?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  execution_cost_read_count?: Maybe<Scalars['Float']>;
  execution_cost_read_length?: Maybe<Scalars['Float']>;
  execution_cost_runtime?: Maybe<Scalars['Float']>;
  execution_cost_write_count?: Maybe<Scalars['Float']>;
  execution_cost_write_length?: Maybe<Scalars['Float']>;
  fee_rate?: Maybe<Scalars['Float']>;
  nonce?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceContractCallsVarSampFields = {
  __typename?: 'laplace_contract_calls_var_samp_fields';
  anchor_mode?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  execution_cost_read_count?: Maybe<Scalars['Float']>;
  execution_cost_read_length?: Maybe<Scalars['Float']>;
  execution_cost_runtime?: Maybe<Scalars['Float']>;
  execution_cost_write_count?: Maybe<Scalars['Float']>;
  execution_cost_write_length?: Maybe<Scalars['Float']>;
  fee_rate?: Maybe<Scalars['Float']>;
  nonce?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceContractCallsVarianceFields = {
  __typename?: 'laplace_contract_calls_variance_fields';
  anchor_mode?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  execution_cost_read_count?: Maybe<Scalars['Float']>;
  execution_cost_read_length?: Maybe<Scalars['Float']>;
  execution_cost_runtime?: Maybe<Scalars['Float']>;
  execution_cost_write_count?: Maybe<Scalars['Float']>;
  execution_cost_write_length?: Maybe<Scalars['Float']>;
  fee_rate?: Maybe<Scalars['Float']>;
  nonce?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "laplace.current_token_price" */
export type LaplaceCurrentTokenPrice = {
  __typename?: 'laplace_current_token_price';
  avg_price_usd?: Maybe<Scalars['float8']>;
  token?: Maybe<Scalars['String']>;
};

/** aggregated selection of "laplace.current_token_price" */
export type LaplaceCurrentTokenPriceAggregate = {
  __typename?: 'laplace_current_token_price_aggregate';
  aggregate?: Maybe<LaplaceCurrentTokenPriceAggregateFields>;
  nodes: Array<LaplaceCurrentTokenPrice>;
};

/** aggregate fields of "laplace.current_token_price" */
export type LaplaceCurrentTokenPriceAggregateFields = {
  __typename?: 'laplace_current_token_price_aggregate_fields';
  avg?: Maybe<LaplaceCurrentTokenPriceAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceCurrentTokenPriceMaxFields>;
  min?: Maybe<LaplaceCurrentTokenPriceMinFields>;
  stddev?: Maybe<LaplaceCurrentTokenPriceStddevFields>;
  stddev_pop?: Maybe<LaplaceCurrentTokenPriceStddevPopFields>;
  stddev_samp?: Maybe<LaplaceCurrentTokenPriceStddevSampFields>;
  sum?: Maybe<LaplaceCurrentTokenPriceSumFields>;
  var_pop?: Maybe<LaplaceCurrentTokenPriceVarPopFields>;
  var_samp?: Maybe<LaplaceCurrentTokenPriceVarSampFields>;
  variance?: Maybe<LaplaceCurrentTokenPriceVarianceFields>;
};


/** aggregate fields of "laplace.current_token_price" */
export type LaplaceCurrentTokenPriceAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceCurrentTokenPriceSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LaplaceCurrentTokenPriceAvgFields = {
  __typename?: 'laplace_current_token_price_avg_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.current_token_price". All fields are combined with a logical 'AND'. */
export type LaplaceCurrentTokenPriceBoolExp = {
  _and?: InputMaybe<Array<LaplaceCurrentTokenPriceBoolExp>>;
  _not?: InputMaybe<LaplaceCurrentTokenPriceBoolExp>;
  _or?: InputMaybe<Array<LaplaceCurrentTokenPriceBoolExp>>;
  avg_price_usd?: InputMaybe<Float8ComparisonExp>;
  token?: InputMaybe<StringComparisonExp>;
};

/** aggregate max on columns */
export type LaplaceCurrentTokenPriceMaxFields = {
  __typename?: 'laplace_current_token_price_max_fields';
  avg_price_usd?: Maybe<Scalars['float8']>;
  token?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LaplaceCurrentTokenPriceMinFields = {
  __typename?: 'laplace_current_token_price_min_fields';
  avg_price_usd?: Maybe<Scalars['float8']>;
  token?: Maybe<Scalars['String']>;
};

/** Ordering options when selecting data from "laplace.current_token_price". */
export type LaplaceCurrentTokenPriceOrderBy = {
  avg_price_usd?: InputMaybe<OrderBy>;
  token?: InputMaybe<OrderBy>;
};

/** select columns of table "laplace.current_token_price" */
export enum LaplaceCurrentTokenPriceSelectColumn {
  /** column name */
  AvgPriceUsd = 'avg_price_usd',
  /** column name */
  Token = 'token'
}

/** aggregate stddev on columns */
export type LaplaceCurrentTokenPriceStddevFields = {
  __typename?: 'laplace_current_token_price_stddev_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceCurrentTokenPriceStddevPopFields = {
  __typename?: 'laplace_current_token_price_stddev_pop_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceCurrentTokenPriceStddevSampFields = {
  __typename?: 'laplace_current_token_price_stddev_samp_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_current_token_price" */
export type LaplaceCurrentTokenPriceStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceCurrentTokenPriceStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceCurrentTokenPriceStreamCursorValueInput = {
  avg_price_usd?: InputMaybe<Scalars['float8']>;
  token?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type LaplaceCurrentTokenPriceSumFields = {
  __typename?: 'laplace_current_token_price_sum_fields';
  avg_price_usd?: Maybe<Scalars['float8']>;
};

/** aggregate var_pop on columns */
export type LaplaceCurrentTokenPriceVarPopFields = {
  __typename?: 'laplace_current_token_price_var_pop_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceCurrentTokenPriceVarSampFields = {
  __typename?: 'laplace_current_token_price_var_samp_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceCurrentTokenPriceVarianceFields = {
  __typename?: 'laplace_current_token_price_variance_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** ALEX deployed contracts relevant to ALEX app */
export type LaplaceDeployedContracts = {
  __typename?: 'laplace_deployed_contracts';
  block_height: Scalars['String'];
  contract_name: Scalars['String'];
  contract_type: Scalars['String'];
  data_type: Scalars['String'];
  deployer_address: Scalars['String'];
  tx_id: Scalars['String'];
};

/** aggregated selection of "laplace.deployed_contracts" */
export type LaplaceDeployedContractsAggregate = {
  __typename?: 'laplace_deployed_contracts_aggregate';
  aggregate?: Maybe<LaplaceDeployedContractsAggregateFields>;
  nodes: Array<LaplaceDeployedContracts>;
};

/** aggregate fields of "laplace.deployed_contracts" */
export type LaplaceDeployedContractsAggregateFields = {
  __typename?: 'laplace_deployed_contracts_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<LaplaceDeployedContractsMaxFields>;
  min?: Maybe<LaplaceDeployedContractsMinFields>;
};


/** aggregate fields of "laplace.deployed_contracts" */
export type LaplaceDeployedContractsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceDeployedContractsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "laplace.deployed_contracts". All fields are combined with a logical 'AND'. */
export type LaplaceDeployedContractsBoolExp = {
  _and?: InputMaybe<Array<LaplaceDeployedContractsBoolExp>>;
  _not?: InputMaybe<LaplaceDeployedContractsBoolExp>;
  _or?: InputMaybe<Array<LaplaceDeployedContractsBoolExp>>;
  block_height?: InputMaybe<StringComparisonExp>;
  contract_name?: InputMaybe<StringComparisonExp>;
  contract_type?: InputMaybe<StringComparisonExp>;
  data_type?: InputMaybe<StringComparisonExp>;
  deployer_address?: InputMaybe<StringComparisonExp>;
  tx_id?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "laplace.deployed_contracts" */
export enum LaplaceDeployedContractsConstraint {
  /** unique or primary key constraint on columns "deployer_address", "tx_id", "contract_name" */
  DeployedContractsPkey = 'deployed_contracts_pkey'
}

/** input type for inserting data into table "laplace.deployed_contracts" */
export type LaplaceDeployedContractsInsertInput = {
  block_height?: InputMaybe<Scalars['String']>;
  contract_name?: InputMaybe<Scalars['String']>;
  contract_type?: InputMaybe<Scalars['String']>;
  data_type?: InputMaybe<Scalars['String']>;
  deployer_address?: InputMaybe<Scalars['String']>;
  tx_id?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type LaplaceDeployedContractsMaxFields = {
  __typename?: 'laplace_deployed_contracts_max_fields';
  block_height?: Maybe<Scalars['String']>;
  contract_name?: Maybe<Scalars['String']>;
  contract_type?: Maybe<Scalars['String']>;
  data_type?: Maybe<Scalars['String']>;
  deployer_address?: Maybe<Scalars['String']>;
  tx_id?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LaplaceDeployedContractsMinFields = {
  __typename?: 'laplace_deployed_contracts_min_fields';
  block_height?: Maybe<Scalars['String']>;
  contract_name?: Maybe<Scalars['String']>;
  contract_type?: Maybe<Scalars['String']>;
  data_type?: Maybe<Scalars['String']>;
  deployer_address?: Maybe<Scalars['String']>;
  tx_id?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "laplace.deployed_contracts" */
export type LaplaceDeployedContractsMutationResponse = {
  __typename?: 'laplace_deployed_contracts_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceDeployedContracts>;
};

/** on_conflict condition type for table "laplace.deployed_contracts" */
export type LaplaceDeployedContractsOnConflict = {
  constraint: LaplaceDeployedContractsConstraint;
  update_columns?: Array<LaplaceDeployedContractsUpdateColumn>;
  where?: InputMaybe<LaplaceDeployedContractsBoolExp>;
};

/** Ordering options when selecting data from "laplace.deployed_contracts". */
export type LaplaceDeployedContractsOrderBy = {
  block_height?: InputMaybe<OrderBy>;
  contract_name?: InputMaybe<OrderBy>;
  contract_type?: InputMaybe<OrderBy>;
  data_type?: InputMaybe<OrderBy>;
  deployer_address?: InputMaybe<OrderBy>;
  tx_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.deployed_contracts */
export type LaplaceDeployedContractsPkColumnsInput = {
  contract_name: Scalars['String'];
  deployer_address: Scalars['String'];
  tx_id: Scalars['String'];
};

/** select columns of table "laplace.deployed_contracts" */
export enum LaplaceDeployedContractsSelectColumn {
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  ContractName = 'contract_name',
  /** column name */
  ContractType = 'contract_type',
  /** column name */
  DataType = 'data_type',
  /** column name */
  DeployerAddress = 'deployer_address',
  /** column name */
  TxId = 'tx_id'
}

/** input type for updating data in table "laplace.deployed_contracts" */
export type LaplaceDeployedContractsSetInput = {
  block_height?: InputMaybe<Scalars['String']>;
  contract_name?: InputMaybe<Scalars['String']>;
  contract_type?: InputMaybe<Scalars['String']>;
  data_type?: InputMaybe<Scalars['String']>;
  deployer_address?: InputMaybe<Scalars['String']>;
  tx_id?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "laplace_deployed_contracts" */
export type LaplaceDeployedContractsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceDeployedContractsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceDeployedContractsStreamCursorValueInput = {
  block_height?: InputMaybe<Scalars['String']>;
  contract_name?: InputMaybe<Scalars['String']>;
  contract_type?: InputMaybe<Scalars['String']>;
  data_type?: InputMaybe<Scalars['String']>;
  deployer_address?: InputMaybe<Scalars['String']>;
  tx_id?: InputMaybe<Scalars['String']>;
};

/** update columns of table "laplace.deployed_contracts" */
export enum LaplaceDeployedContractsUpdateColumn {
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  ContractName = 'contract_name',
  /** column name */
  ContractType = 'contract_type',
  /** column name */
  DataType = 'data_type',
  /** column name */
  DeployerAddress = 'deployer_address',
  /** column name */
  TxId = 'tx_id'
}

export type LaplaceDeployedContractsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceDeployedContractsSetInput>;
  where: LaplaceDeployedContractsBoolExp;
};

/** External token price fetched using read-only calls */
export type LaplaceExternalTokenPrice = {
  __typename?: 'laplace_external_token_price';
  time_stamp?: Maybe<Scalars['timestamptz']>;
  token_name: Scalars['String'];
  value: Scalars['numeric'];
};

/** aggregated selection of "laplace.external_token_price" */
export type LaplaceExternalTokenPriceAggregate = {
  __typename?: 'laplace_external_token_price_aggregate';
  aggregate?: Maybe<LaplaceExternalTokenPriceAggregateFields>;
  nodes: Array<LaplaceExternalTokenPrice>;
};

/** aggregate fields of "laplace.external_token_price" */
export type LaplaceExternalTokenPriceAggregateFields = {
  __typename?: 'laplace_external_token_price_aggregate_fields';
  avg?: Maybe<LaplaceExternalTokenPriceAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceExternalTokenPriceMaxFields>;
  min?: Maybe<LaplaceExternalTokenPriceMinFields>;
  stddev?: Maybe<LaplaceExternalTokenPriceStddevFields>;
  stddev_pop?: Maybe<LaplaceExternalTokenPriceStddevPopFields>;
  stddev_samp?: Maybe<LaplaceExternalTokenPriceStddevSampFields>;
  sum?: Maybe<LaplaceExternalTokenPriceSumFields>;
  var_pop?: Maybe<LaplaceExternalTokenPriceVarPopFields>;
  var_samp?: Maybe<LaplaceExternalTokenPriceVarSampFields>;
  variance?: Maybe<LaplaceExternalTokenPriceVarianceFields>;
};


/** aggregate fields of "laplace.external_token_price" */
export type LaplaceExternalTokenPriceAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceExternalTokenPriceSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LaplaceExternalTokenPriceAvgFields = {
  __typename?: 'laplace_external_token_price_avg_fields';
  value?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.external_token_price". All fields are combined with a logical 'AND'. */
export type LaplaceExternalTokenPriceBoolExp = {
  _and?: InputMaybe<Array<LaplaceExternalTokenPriceBoolExp>>;
  _not?: InputMaybe<LaplaceExternalTokenPriceBoolExp>;
  _or?: InputMaybe<Array<LaplaceExternalTokenPriceBoolExp>>;
  time_stamp?: InputMaybe<TimestamptzComparisonExp>;
  token_name?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<NumericComparisonExp>;
};

/** unique or primary key constraints on table "laplace.external_token_price" */
export enum LaplaceExternalTokenPriceConstraint {
  /** unique or primary key constraint on columns "token_name" */
  ExternalTokenPricePkey = 'external_token_price_pkey'
}

/** input type for incrementing numeric columns in table "laplace.external_token_price" */
export type LaplaceExternalTokenPriceIncInput = {
  value?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "laplace.external_token_price" */
export type LaplaceExternalTokenPriceInsertInput = {
  time_stamp?: InputMaybe<Scalars['timestamptz']>;
  token_name?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['numeric']>;
};

/** aggregate max on columns */
export type LaplaceExternalTokenPriceMaxFields = {
  __typename?: 'laplace_external_token_price_max_fields';
  time_stamp?: Maybe<Scalars['timestamptz']>;
  token_name?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type LaplaceExternalTokenPriceMinFields = {
  __typename?: 'laplace_external_token_price_min_fields';
  time_stamp?: Maybe<Scalars['timestamptz']>;
  token_name?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['numeric']>;
};

/** response of any mutation on the table "laplace.external_token_price" */
export type LaplaceExternalTokenPriceMutationResponse = {
  __typename?: 'laplace_external_token_price_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceExternalTokenPrice>;
};

/** on_conflict condition type for table "laplace.external_token_price" */
export type LaplaceExternalTokenPriceOnConflict = {
  constraint: LaplaceExternalTokenPriceConstraint;
  update_columns?: Array<LaplaceExternalTokenPriceUpdateColumn>;
  where?: InputMaybe<LaplaceExternalTokenPriceBoolExp>;
};

/** Ordering options when selecting data from "laplace.external_token_price". */
export type LaplaceExternalTokenPriceOrderBy = {
  time_stamp?: InputMaybe<OrderBy>;
  token_name?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.external_token_price */
export type LaplaceExternalTokenPricePkColumnsInput = {
  token_name: Scalars['String'];
};

/** select columns of table "laplace.external_token_price" */
export enum LaplaceExternalTokenPriceSelectColumn {
  /** column name */
  TimeStamp = 'time_stamp',
  /** column name */
  TokenName = 'token_name',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "laplace.external_token_price" */
export type LaplaceExternalTokenPriceSetInput = {
  time_stamp?: InputMaybe<Scalars['timestamptz']>;
  token_name?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['numeric']>;
};

/** aggregate stddev on columns */
export type LaplaceExternalTokenPriceStddevFields = {
  __typename?: 'laplace_external_token_price_stddev_fields';
  value?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceExternalTokenPriceStddevPopFields = {
  __typename?: 'laplace_external_token_price_stddev_pop_fields';
  value?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceExternalTokenPriceStddevSampFields = {
  __typename?: 'laplace_external_token_price_stddev_samp_fields';
  value?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_external_token_price" */
export type LaplaceExternalTokenPriceStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceExternalTokenPriceStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceExternalTokenPriceStreamCursorValueInput = {
  time_stamp?: InputMaybe<Scalars['timestamptz']>;
  token_name?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['numeric']>;
};

/** aggregate sum on columns */
export type LaplaceExternalTokenPriceSumFields = {
  __typename?: 'laplace_external_token_price_sum_fields';
  value?: Maybe<Scalars['numeric']>;
};

/** update columns of table "laplace.external_token_price" */
export enum LaplaceExternalTokenPriceUpdateColumn {
  /** column name */
  TimeStamp = 'time_stamp',
  /** column name */
  TokenName = 'token_name',
  /** column name */
  Value = 'value'
}

export type LaplaceExternalTokenPriceUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceExternalTokenPriceIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceExternalTokenPriceSetInput>;
  where: LaplaceExternalTokenPriceBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceExternalTokenPriceVarPopFields = {
  __typename?: 'laplace_external_token_price_var_pop_fields';
  value?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceExternalTokenPriceVarSampFields = {
  __typename?: 'laplace_external_token_price_var_samp_fields';
  value?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceExternalTokenPriceVarianceFields = {
  __typename?: 'laplace_external_token_price_variance_fields';
  value?: Maybe<Scalars['Float']>;
};

/** Contract fixed_weight_pool_v1_01 per-block data */
export type LaplaceFixedWeightPoolV1_01 = {
  __typename?: 'laplace_fixed_weight_pool_v1_01';
  balance_x: Scalars['bigint'];
  balance_y: Scalars['bigint'];
  block_height: Scalars['Int'];
  burn_block_time: Scalars['Int'];
  est_pool_token_price: Scalars['bigint'];
  est_token_y_price: Scalars['bigint'];
  fee_rate_x: Scalars['bigint'];
  fee_rate_y: Scalars['bigint'];
  fee_rebate: Scalars['bigint'];
  fee_to_address: Scalars['String'];
  latest_oracle_resilient: Scalars['bigint'];
  oracle_average: Scalars['bigint'];
  oracle_enabled: Scalars['Boolean'];
  oracle_instant: Scalars['bigint'];
  oracle_resilient: Scalars['bigint'];
  pool_token: Scalars['String'];
  sync_at: Scalars['timestamptz'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
  total_supply: Scalars['bigint'];
  weight_x: Scalars['bigint'];
  weight_y: Scalars['bigint'];
};

/** aggregated selection of "laplace.fixed_weight_pool_v1_01" */
export type LaplaceFixedWeightPoolV1_01Aggregate = {
  __typename?: 'laplace_fixed_weight_pool_v1_01_aggregate';
  aggregate?: Maybe<LaplaceFixedWeightPoolV1_01AggregateFields>;
  nodes: Array<LaplaceFixedWeightPoolV1_01>;
};

/** aggregate fields of "laplace.fixed_weight_pool_v1_01" */
export type LaplaceFixedWeightPoolV1_01AggregateFields = {
  __typename?: 'laplace_fixed_weight_pool_v1_01_aggregate_fields';
  avg?: Maybe<LaplaceFixedWeightPoolV1_01AvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceFixedWeightPoolV1_01MaxFields>;
  min?: Maybe<LaplaceFixedWeightPoolV1_01MinFields>;
  stddev?: Maybe<LaplaceFixedWeightPoolV1_01StddevFields>;
  stddev_pop?: Maybe<LaplaceFixedWeightPoolV1_01StddevPopFields>;
  stddev_samp?: Maybe<LaplaceFixedWeightPoolV1_01StddevSampFields>;
  sum?: Maybe<LaplaceFixedWeightPoolV1_01SumFields>;
  var_pop?: Maybe<LaplaceFixedWeightPoolV1_01VarPopFields>;
  var_samp?: Maybe<LaplaceFixedWeightPoolV1_01VarSampFields>;
  variance?: Maybe<LaplaceFixedWeightPoolV1_01VarianceFields>;
};


/** aggregate fields of "laplace.fixed_weight_pool_v1_01" */
export type LaplaceFixedWeightPoolV1_01AggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceFixedWeightPoolV1_01SelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LaplaceFixedWeightPoolV1_01AvgFields = {
  __typename?: 'laplace_fixed_weight_pool_v1_01_avg_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  weight_x?: Maybe<Scalars['Float']>;
  weight_y?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.fixed_weight_pool_v1_01". All fields are combined with a logical 'AND'. */
export type LaplaceFixedWeightPoolV1_01BoolExp = {
  _and?: InputMaybe<Array<LaplaceFixedWeightPoolV1_01BoolExp>>;
  _not?: InputMaybe<LaplaceFixedWeightPoolV1_01BoolExp>;
  _or?: InputMaybe<Array<LaplaceFixedWeightPoolV1_01BoolExp>>;
  balance_x?: InputMaybe<BigintComparisonExp>;
  balance_y?: InputMaybe<BigintComparisonExp>;
  block_height?: InputMaybe<IntComparisonExp>;
  burn_block_time?: InputMaybe<IntComparisonExp>;
  est_pool_token_price?: InputMaybe<BigintComparisonExp>;
  est_token_y_price?: InputMaybe<BigintComparisonExp>;
  fee_rate_x?: InputMaybe<BigintComparisonExp>;
  fee_rate_y?: InputMaybe<BigintComparisonExp>;
  fee_rebate?: InputMaybe<BigintComparisonExp>;
  fee_to_address?: InputMaybe<StringComparisonExp>;
  latest_oracle_resilient?: InputMaybe<BigintComparisonExp>;
  oracle_average?: InputMaybe<BigintComparisonExp>;
  oracle_enabled?: InputMaybe<BooleanComparisonExp>;
  oracle_instant?: InputMaybe<BigintComparisonExp>;
  oracle_resilient?: InputMaybe<BigintComparisonExp>;
  pool_token?: InputMaybe<StringComparisonExp>;
  sync_at?: InputMaybe<TimestamptzComparisonExp>;
  token_x?: InputMaybe<StringComparisonExp>;
  token_y?: InputMaybe<StringComparisonExp>;
  total_supply?: InputMaybe<BigintComparisonExp>;
  weight_x?: InputMaybe<BigintComparisonExp>;
  weight_y?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "laplace.fixed_weight_pool_v1_01" */
export enum LaplaceFixedWeightPoolV1_01Constraint {
  /** unique or primary key constraint on columns "block_height", "weight_x", "token_y", "token_x", "weight_y" */
  FixedWeightPoolV1_01Pkey = 'fixed_weight_pool_v1_01_pkey'
}

/** input type for incrementing numeric columns in table "laplace.fixed_weight_pool_v1_01" */
export type LaplaceFixedWeightPoolV1_01IncInput = {
  balance_x?: InputMaybe<Scalars['bigint']>;
  balance_y?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  est_pool_token_price?: InputMaybe<Scalars['bigint']>;
  est_token_y_price?: InputMaybe<Scalars['bigint']>;
  fee_rate_x?: InputMaybe<Scalars['bigint']>;
  fee_rate_y?: InputMaybe<Scalars['bigint']>;
  fee_rebate?: InputMaybe<Scalars['bigint']>;
  latest_oracle_resilient?: InputMaybe<Scalars['bigint']>;
  oracle_average?: InputMaybe<Scalars['bigint']>;
  oracle_instant?: InputMaybe<Scalars['bigint']>;
  oracle_resilient?: InputMaybe<Scalars['bigint']>;
  total_supply?: InputMaybe<Scalars['bigint']>;
  weight_x?: InputMaybe<Scalars['bigint']>;
  weight_y?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "laplace.fixed_weight_pool_v1_01" */
export type LaplaceFixedWeightPoolV1_01InsertInput = {
  balance_x?: InputMaybe<Scalars['bigint']>;
  balance_y?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  est_pool_token_price?: InputMaybe<Scalars['bigint']>;
  est_token_y_price?: InputMaybe<Scalars['bigint']>;
  fee_rate_x?: InputMaybe<Scalars['bigint']>;
  fee_rate_y?: InputMaybe<Scalars['bigint']>;
  fee_rebate?: InputMaybe<Scalars['bigint']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  latest_oracle_resilient?: InputMaybe<Scalars['bigint']>;
  oracle_average?: InputMaybe<Scalars['bigint']>;
  oracle_enabled?: InputMaybe<Scalars['Boolean']>;
  oracle_instant?: InputMaybe<Scalars['bigint']>;
  oracle_resilient?: InputMaybe<Scalars['bigint']>;
  pool_token?: InputMaybe<Scalars['String']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  total_supply?: InputMaybe<Scalars['bigint']>;
  weight_x?: InputMaybe<Scalars['bigint']>;
  weight_y?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type LaplaceFixedWeightPoolV1_01MaxFields = {
  __typename?: 'laplace_fixed_weight_pool_v1_01_max_fields';
  balance_x?: Maybe<Scalars['bigint']>;
  balance_y?: Maybe<Scalars['bigint']>;
  block_height?: Maybe<Scalars['Int']>;
  burn_block_time?: Maybe<Scalars['Int']>;
  est_pool_token_price?: Maybe<Scalars['bigint']>;
  est_token_y_price?: Maybe<Scalars['bigint']>;
  fee_rate_x?: Maybe<Scalars['bigint']>;
  fee_rate_y?: Maybe<Scalars['bigint']>;
  fee_rebate?: Maybe<Scalars['bigint']>;
  fee_to_address?: Maybe<Scalars['String']>;
  latest_oracle_resilient?: Maybe<Scalars['bigint']>;
  oracle_average?: Maybe<Scalars['bigint']>;
  oracle_instant?: Maybe<Scalars['bigint']>;
  oracle_resilient?: Maybe<Scalars['bigint']>;
  pool_token?: Maybe<Scalars['String']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_x?: Maybe<Scalars['String']>;
  token_y?: Maybe<Scalars['String']>;
  total_supply?: Maybe<Scalars['bigint']>;
  weight_x?: Maybe<Scalars['bigint']>;
  weight_y?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type LaplaceFixedWeightPoolV1_01MinFields = {
  __typename?: 'laplace_fixed_weight_pool_v1_01_min_fields';
  balance_x?: Maybe<Scalars['bigint']>;
  balance_y?: Maybe<Scalars['bigint']>;
  block_height?: Maybe<Scalars['Int']>;
  burn_block_time?: Maybe<Scalars['Int']>;
  est_pool_token_price?: Maybe<Scalars['bigint']>;
  est_token_y_price?: Maybe<Scalars['bigint']>;
  fee_rate_x?: Maybe<Scalars['bigint']>;
  fee_rate_y?: Maybe<Scalars['bigint']>;
  fee_rebate?: Maybe<Scalars['bigint']>;
  fee_to_address?: Maybe<Scalars['String']>;
  latest_oracle_resilient?: Maybe<Scalars['bigint']>;
  oracle_average?: Maybe<Scalars['bigint']>;
  oracle_instant?: Maybe<Scalars['bigint']>;
  oracle_resilient?: Maybe<Scalars['bigint']>;
  pool_token?: Maybe<Scalars['String']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_x?: Maybe<Scalars['String']>;
  token_y?: Maybe<Scalars['String']>;
  total_supply?: Maybe<Scalars['bigint']>;
  weight_x?: Maybe<Scalars['bigint']>;
  weight_y?: Maybe<Scalars['bigint']>;
};

/** response of any mutation on the table "laplace.fixed_weight_pool_v1_01" */
export type LaplaceFixedWeightPoolV1_01MutationResponse = {
  __typename?: 'laplace_fixed_weight_pool_v1_01_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceFixedWeightPoolV1_01>;
};

/** on_conflict condition type for table "laplace.fixed_weight_pool_v1_01" */
export type LaplaceFixedWeightPoolV1_01OnConflict = {
  constraint: LaplaceFixedWeightPoolV1_01Constraint;
  update_columns?: Array<LaplaceFixedWeightPoolV1_01UpdateColumn>;
  where?: InputMaybe<LaplaceFixedWeightPoolV1_01BoolExp>;
};

/** Ordering options when selecting data from "laplace.fixed_weight_pool_v1_01". */
export type LaplaceFixedWeightPoolV1_01OrderBy = {
  balance_x?: InputMaybe<OrderBy>;
  balance_y?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  burn_block_time?: InputMaybe<OrderBy>;
  est_pool_token_price?: InputMaybe<OrderBy>;
  est_token_y_price?: InputMaybe<OrderBy>;
  fee_rate_x?: InputMaybe<OrderBy>;
  fee_rate_y?: InputMaybe<OrderBy>;
  fee_rebate?: InputMaybe<OrderBy>;
  fee_to_address?: InputMaybe<OrderBy>;
  latest_oracle_resilient?: InputMaybe<OrderBy>;
  oracle_average?: InputMaybe<OrderBy>;
  oracle_enabled?: InputMaybe<OrderBy>;
  oracle_instant?: InputMaybe<OrderBy>;
  oracle_resilient?: InputMaybe<OrderBy>;
  pool_token?: InputMaybe<OrderBy>;
  sync_at?: InputMaybe<OrderBy>;
  token_x?: InputMaybe<OrderBy>;
  token_y?: InputMaybe<OrderBy>;
  total_supply?: InputMaybe<OrderBy>;
  weight_x?: InputMaybe<OrderBy>;
  weight_y?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.fixed_weight_pool_v1_01 */
export type LaplaceFixedWeightPoolV1_01PkColumnsInput = {
  block_height: Scalars['Int'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
  weight_x: Scalars['bigint'];
  weight_y: Scalars['bigint'];
};

/** select columns of table "laplace.fixed_weight_pool_v1_01" */
export enum LaplaceFixedWeightPoolV1_01SelectColumn {
  /** column name */
  BalanceX = 'balance_x',
  /** column name */
  BalanceY = 'balance_y',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  EstPoolTokenPrice = 'est_pool_token_price',
  /** column name */
  EstTokenYPrice = 'est_token_y_price',
  /** column name */
  FeeRateX = 'fee_rate_x',
  /** column name */
  FeeRateY = 'fee_rate_y',
  /** column name */
  FeeRebate = 'fee_rebate',
  /** column name */
  FeeToAddress = 'fee_to_address',
  /** column name */
  LatestOracleResilient = 'latest_oracle_resilient',
  /** column name */
  OracleAverage = 'oracle_average',
  /** column name */
  OracleEnabled = 'oracle_enabled',
  /** column name */
  OracleInstant = 'oracle_instant',
  /** column name */
  OracleResilient = 'oracle_resilient',
  /** column name */
  PoolToken = 'pool_token',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenX = 'token_x',
  /** column name */
  TokenY = 'token_y',
  /** column name */
  TotalSupply = 'total_supply',
  /** column name */
  WeightX = 'weight_x',
  /** column name */
  WeightY = 'weight_y'
}

/** input type for updating data in table "laplace.fixed_weight_pool_v1_01" */
export type LaplaceFixedWeightPoolV1_01SetInput = {
  balance_x?: InputMaybe<Scalars['bigint']>;
  balance_y?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  est_pool_token_price?: InputMaybe<Scalars['bigint']>;
  est_token_y_price?: InputMaybe<Scalars['bigint']>;
  fee_rate_x?: InputMaybe<Scalars['bigint']>;
  fee_rate_y?: InputMaybe<Scalars['bigint']>;
  fee_rebate?: InputMaybe<Scalars['bigint']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  latest_oracle_resilient?: InputMaybe<Scalars['bigint']>;
  oracle_average?: InputMaybe<Scalars['bigint']>;
  oracle_enabled?: InputMaybe<Scalars['Boolean']>;
  oracle_instant?: InputMaybe<Scalars['bigint']>;
  oracle_resilient?: InputMaybe<Scalars['bigint']>;
  pool_token?: InputMaybe<Scalars['String']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  total_supply?: InputMaybe<Scalars['bigint']>;
  weight_x?: InputMaybe<Scalars['bigint']>;
  weight_y?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type LaplaceFixedWeightPoolV1_01StddevFields = {
  __typename?: 'laplace_fixed_weight_pool_v1_01_stddev_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  weight_x?: Maybe<Scalars['Float']>;
  weight_y?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceFixedWeightPoolV1_01StddevPopFields = {
  __typename?: 'laplace_fixed_weight_pool_v1_01_stddev_pop_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  weight_x?: Maybe<Scalars['Float']>;
  weight_y?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceFixedWeightPoolV1_01StddevSampFields = {
  __typename?: 'laplace_fixed_weight_pool_v1_01_stddev_samp_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  weight_x?: Maybe<Scalars['Float']>;
  weight_y?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_fixed_weight_pool_v1_01" */
export type LaplaceFixedWeightPoolV1_01StreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceFixedWeightPoolV1_01StreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceFixedWeightPoolV1_01StreamCursorValueInput = {
  balance_x?: InputMaybe<Scalars['bigint']>;
  balance_y?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  est_pool_token_price?: InputMaybe<Scalars['bigint']>;
  est_token_y_price?: InputMaybe<Scalars['bigint']>;
  fee_rate_x?: InputMaybe<Scalars['bigint']>;
  fee_rate_y?: InputMaybe<Scalars['bigint']>;
  fee_rebate?: InputMaybe<Scalars['bigint']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  latest_oracle_resilient?: InputMaybe<Scalars['bigint']>;
  oracle_average?: InputMaybe<Scalars['bigint']>;
  oracle_enabled?: InputMaybe<Scalars['Boolean']>;
  oracle_instant?: InputMaybe<Scalars['bigint']>;
  oracle_resilient?: InputMaybe<Scalars['bigint']>;
  pool_token?: InputMaybe<Scalars['String']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  total_supply?: InputMaybe<Scalars['bigint']>;
  weight_x?: InputMaybe<Scalars['bigint']>;
  weight_y?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type LaplaceFixedWeightPoolV1_01SumFields = {
  __typename?: 'laplace_fixed_weight_pool_v1_01_sum_fields';
  balance_x?: Maybe<Scalars['bigint']>;
  balance_y?: Maybe<Scalars['bigint']>;
  block_height?: Maybe<Scalars['Int']>;
  burn_block_time?: Maybe<Scalars['Int']>;
  est_pool_token_price?: Maybe<Scalars['bigint']>;
  est_token_y_price?: Maybe<Scalars['bigint']>;
  fee_rate_x?: Maybe<Scalars['bigint']>;
  fee_rate_y?: Maybe<Scalars['bigint']>;
  fee_rebate?: Maybe<Scalars['bigint']>;
  latest_oracle_resilient?: Maybe<Scalars['bigint']>;
  oracle_average?: Maybe<Scalars['bigint']>;
  oracle_instant?: Maybe<Scalars['bigint']>;
  oracle_resilient?: Maybe<Scalars['bigint']>;
  total_supply?: Maybe<Scalars['bigint']>;
  weight_x?: Maybe<Scalars['bigint']>;
  weight_y?: Maybe<Scalars['bigint']>;
};

/** update columns of table "laplace.fixed_weight_pool_v1_01" */
export enum LaplaceFixedWeightPoolV1_01UpdateColumn {
  /** column name */
  BalanceX = 'balance_x',
  /** column name */
  BalanceY = 'balance_y',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  EstPoolTokenPrice = 'est_pool_token_price',
  /** column name */
  EstTokenYPrice = 'est_token_y_price',
  /** column name */
  FeeRateX = 'fee_rate_x',
  /** column name */
  FeeRateY = 'fee_rate_y',
  /** column name */
  FeeRebate = 'fee_rebate',
  /** column name */
  FeeToAddress = 'fee_to_address',
  /** column name */
  LatestOracleResilient = 'latest_oracle_resilient',
  /** column name */
  OracleAverage = 'oracle_average',
  /** column name */
  OracleEnabled = 'oracle_enabled',
  /** column name */
  OracleInstant = 'oracle_instant',
  /** column name */
  OracleResilient = 'oracle_resilient',
  /** column name */
  PoolToken = 'pool_token',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenX = 'token_x',
  /** column name */
  TokenY = 'token_y',
  /** column name */
  TotalSupply = 'total_supply',
  /** column name */
  WeightX = 'weight_x',
  /** column name */
  WeightY = 'weight_y'
}

export type LaplaceFixedWeightPoolV1_01Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceFixedWeightPoolV1_01IncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceFixedWeightPoolV1_01SetInput>;
  where: LaplaceFixedWeightPoolV1_01BoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceFixedWeightPoolV1_01VarPopFields = {
  __typename?: 'laplace_fixed_weight_pool_v1_01_var_pop_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  weight_x?: Maybe<Scalars['Float']>;
  weight_y?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceFixedWeightPoolV1_01VarSampFields = {
  __typename?: 'laplace_fixed_weight_pool_v1_01_var_samp_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  weight_x?: Maybe<Scalars['Float']>;
  weight_y?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceFixedWeightPoolV1_01VarianceFields = {
  __typename?: 'laplace_fixed_weight_pool_v1_01_variance_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  weight_x?: Maybe<Scalars['Float']>;
  weight_y?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "laplace.history_price_data" */
export type LaplaceHistoryPriceData = {
  __typename?: 'laplace_history_price_data';
  avg_price_usd: Scalars['numeric'];
  block_height: Scalars['numeric'];
  sync_at: Scalars['timestamptz'];
  token: Scalars['String'];
};

/** aggregated selection of "laplace.history_price_data" */
export type LaplaceHistoryPriceDataAggregate = {
  __typename?: 'laplace_history_price_data_aggregate';
  aggregate?: Maybe<LaplaceHistoryPriceDataAggregateFields>;
  nodes: Array<LaplaceHistoryPriceData>;
};

/** aggregate fields of "laplace.history_price_data" */
export type LaplaceHistoryPriceDataAggregateFields = {
  __typename?: 'laplace_history_price_data_aggregate_fields';
  avg?: Maybe<LaplaceHistoryPriceDataAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceHistoryPriceDataMaxFields>;
  min?: Maybe<LaplaceHistoryPriceDataMinFields>;
  stddev?: Maybe<LaplaceHistoryPriceDataStddevFields>;
  stddev_pop?: Maybe<LaplaceHistoryPriceDataStddevPopFields>;
  stddev_samp?: Maybe<LaplaceHistoryPriceDataStddevSampFields>;
  sum?: Maybe<LaplaceHistoryPriceDataSumFields>;
  var_pop?: Maybe<LaplaceHistoryPriceDataVarPopFields>;
  var_samp?: Maybe<LaplaceHistoryPriceDataVarSampFields>;
  variance?: Maybe<LaplaceHistoryPriceDataVarianceFields>;
};


/** aggregate fields of "laplace.history_price_data" */
export type LaplaceHistoryPriceDataAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceHistoryPriceDataSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LaplaceHistoryPriceDataAvgFields = {
  __typename?: 'laplace_history_price_data_avg_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.history_price_data". All fields are combined with a logical 'AND'. */
export type LaplaceHistoryPriceDataBoolExp = {
  _and?: InputMaybe<Array<LaplaceHistoryPriceDataBoolExp>>;
  _not?: InputMaybe<LaplaceHistoryPriceDataBoolExp>;
  _or?: InputMaybe<Array<LaplaceHistoryPriceDataBoolExp>>;
  avg_price_usd?: InputMaybe<NumericComparisonExp>;
  block_height?: InputMaybe<NumericComparisonExp>;
  sync_at?: InputMaybe<TimestamptzComparisonExp>;
  token?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "laplace.history_price_data" */
export enum LaplaceHistoryPriceDataConstraint {
  /** unique or primary key constraint on columns "block_height", "token" */
  HistoryPriceDataPkey = 'history_price_data_pkey'
}

/** input type for incrementing numeric columns in table "laplace.history_price_data" */
export type LaplaceHistoryPriceDataIncInput = {
  avg_price_usd?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "laplace.history_price_data" */
export type LaplaceHistoryPriceDataInsertInput = {
  avg_price_usd?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type LaplaceHistoryPriceDataMaxFields = {
  __typename?: 'laplace_history_price_data_max_fields';
  avg_price_usd?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['numeric']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LaplaceHistoryPriceDataMinFields = {
  __typename?: 'laplace_history_price_data_min_fields';
  avg_price_usd?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['numeric']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "laplace.history_price_data" */
export type LaplaceHistoryPriceDataMutationResponse = {
  __typename?: 'laplace_history_price_data_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceHistoryPriceData>;
};

/** on_conflict condition type for table "laplace.history_price_data" */
export type LaplaceHistoryPriceDataOnConflict = {
  constraint: LaplaceHistoryPriceDataConstraint;
  update_columns?: Array<LaplaceHistoryPriceDataUpdateColumn>;
  where?: InputMaybe<LaplaceHistoryPriceDataBoolExp>;
};

/** Ordering options when selecting data from "laplace.history_price_data". */
export type LaplaceHistoryPriceDataOrderBy = {
  avg_price_usd?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  sync_at?: InputMaybe<OrderBy>;
  token?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.history_price_data */
export type LaplaceHistoryPriceDataPkColumnsInput = {
  block_height: Scalars['numeric'];
  token: Scalars['String'];
};

/** select columns of table "laplace.history_price_data" */
export enum LaplaceHistoryPriceDataSelectColumn {
  /** column name */
  AvgPriceUsd = 'avg_price_usd',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  Token = 'token'
}

/** input type for updating data in table "laplace.history_price_data" */
export type LaplaceHistoryPriceDataSetInput = {
  avg_price_usd?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type LaplaceHistoryPriceDataStddevFields = {
  __typename?: 'laplace_history_price_data_stddev_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceHistoryPriceDataStddevPopFields = {
  __typename?: 'laplace_history_price_data_stddev_pop_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceHistoryPriceDataStddevSampFields = {
  __typename?: 'laplace_history_price_data_stddev_samp_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_history_price_data" */
export type LaplaceHistoryPriceDataStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceHistoryPriceDataStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceHistoryPriceDataStreamCursorValueInput = {
  avg_price_usd?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type LaplaceHistoryPriceDataSumFields = {
  __typename?: 'laplace_history_price_data_sum_fields';
  avg_price_usd?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['numeric']>;
};

/** update columns of table "laplace.history_price_data" */
export enum LaplaceHistoryPriceDataUpdateColumn {
  /** column name */
  AvgPriceUsd = 'avg_price_usd',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  Token = 'token'
}

export type LaplaceHistoryPriceDataUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceHistoryPriceDataIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceHistoryPriceDataSetInput>;
  where: LaplaceHistoryPriceDataBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceHistoryPriceDataVarPopFields = {
  __typename?: 'laplace_history_price_data_var_pop_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceHistoryPriceDataVarSampFields = {
  __typename?: 'laplace_history_price_data_var_samp_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceHistoryPriceDataVarianceFields = {
  __typename?: 'laplace_history_price_data_variance_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
};

/** ALEX staking statistics history */
export type LaplaceHistoryStakingStats = {
  __typename?: 'laplace_history_staking_stats';
  cycle: Scalars['Int'];
  sync_at: Scalars['timestamptz'];
  sync_at_block_height: Scalars['Int'];
  token: Scalars['String'];
  total_staked: Scalars['numeric'];
};

/** aggregated selection of "laplace.history_staking_stats" */
export type LaplaceHistoryStakingStatsAggregate = {
  __typename?: 'laplace_history_staking_stats_aggregate';
  aggregate?: Maybe<LaplaceHistoryStakingStatsAggregateFields>;
  nodes: Array<LaplaceHistoryStakingStats>;
};

/** aggregate fields of "laplace.history_staking_stats" */
export type LaplaceHistoryStakingStatsAggregateFields = {
  __typename?: 'laplace_history_staking_stats_aggregate_fields';
  avg?: Maybe<LaplaceHistoryStakingStatsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceHistoryStakingStatsMaxFields>;
  min?: Maybe<LaplaceHistoryStakingStatsMinFields>;
  stddev?: Maybe<LaplaceHistoryStakingStatsStddevFields>;
  stddev_pop?: Maybe<LaplaceHistoryStakingStatsStddevPopFields>;
  stddev_samp?: Maybe<LaplaceHistoryStakingStatsStddevSampFields>;
  sum?: Maybe<LaplaceHistoryStakingStatsSumFields>;
  var_pop?: Maybe<LaplaceHistoryStakingStatsVarPopFields>;
  var_samp?: Maybe<LaplaceHistoryStakingStatsVarSampFields>;
  variance?: Maybe<LaplaceHistoryStakingStatsVarianceFields>;
};


/** aggregate fields of "laplace.history_staking_stats" */
export type LaplaceHistoryStakingStatsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceHistoryStakingStatsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LaplaceHistoryStakingStatsAvgFields = {
  __typename?: 'laplace_history_staking_stats_avg_fields';
  cycle?: Maybe<Scalars['Float']>;
  sync_at_block_height?: Maybe<Scalars['Float']>;
  total_staked?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.history_staking_stats". All fields are combined with a logical 'AND'. */
export type LaplaceHistoryStakingStatsBoolExp = {
  _and?: InputMaybe<Array<LaplaceHistoryStakingStatsBoolExp>>;
  _not?: InputMaybe<LaplaceHistoryStakingStatsBoolExp>;
  _or?: InputMaybe<Array<LaplaceHistoryStakingStatsBoolExp>>;
  cycle?: InputMaybe<IntComparisonExp>;
  sync_at?: InputMaybe<TimestamptzComparisonExp>;
  sync_at_block_height?: InputMaybe<IntComparisonExp>;
  token?: InputMaybe<StringComparisonExp>;
  total_staked?: InputMaybe<NumericComparisonExp>;
};

/** unique or primary key constraints on table "laplace.history_staking_stats" */
export enum LaplaceHistoryStakingStatsConstraint {
  /** unique or primary key constraint on columns "cycle", "token" */
  HistoryStakingStatsPkey = 'history_staking_stats_pkey'
}

/** input type for incrementing numeric columns in table "laplace.history_staking_stats" */
export type LaplaceHistoryStakingStatsIncInput = {
  cycle?: InputMaybe<Scalars['Int']>;
  sync_at_block_height?: InputMaybe<Scalars['Int']>;
  total_staked?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "laplace.history_staking_stats" */
export type LaplaceHistoryStakingStatsInsertInput = {
  cycle?: InputMaybe<Scalars['Int']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  sync_at_block_height?: InputMaybe<Scalars['Int']>;
  token?: InputMaybe<Scalars['String']>;
  total_staked?: InputMaybe<Scalars['numeric']>;
};

/** aggregate max on columns */
export type LaplaceHistoryStakingStatsMaxFields = {
  __typename?: 'laplace_history_staking_stats_max_fields';
  cycle?: Maybe<Scalars['Int']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  sync_at_block_height?: Maybe<Scalars['Int']>;
  token?: Maybe<Scalars['String']>;
  total_staked?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type LaplaceHistoryStakingStatsMinFields = {
  __typename?: 'laplace_history_staking_stats_min_fields';
  cycle?: Maybe<Scalars['Int']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  sync_at_block_height?: Maybe<Scalars['Int']>;
  token?: Maybe<Scalars['String']>;
  total_staked?: Maybe<Scalars['numeric']>;
};

/** response of any mutation on the table "laplace.history_staking_stats" */
export type LaplaceHistoryStakingStatsMutationResponse = {
  __typename?: 'laplace_history_staking_stats_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceHistoryStakingStats>;
};

/** on_conflict condition type for table "laplace.history_staking_stats" */
export type LaplaceHistoryStakingStatsOnConflict = {
  constraint: LaplaceHistoryStakingStatsConstraint;
  update_columns?: Array<LaplaceHistoryStakingStatsUpdateColumn>;
  where?: InputMaybe<LaplaceHistoryStakingStatsBoolExp>;
};

/** Ordering options when selecting data from "laplace.history_staking_stats". */
export type LaplaceHistoryStakingStatsOrderBy = {
  cycle?: InputMaybe<OrderBy>;
  sync_at?: InputMaybe<OrderBy>;
  sync_at_block_height?: InputMaybe<OrderBy>;
  token?: InputMaybe<OrderBy>;
  total_staked?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.history_staking_stats */
export type LaplaceHistoryStakingStatsPkColumnsInput = {
  cycle: Scalars['Int'];
  token: Scalars['String'];
};

/** select columns of table "laplace.history_staking_stats" */
export enum LaplaceHistoryStakingStatsSelectColumn {
  /** column name */
  Cycle = 'cycle',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  SyncAtBlockHeight = 'sync_at_block_height',
  /** column name */
  Token = 'token',
  /** column name */
  TotalStaked = 'total_staked'
}

/** input type for updating data in table "laplace.history_staking_stats" */
export type LaplaceHistoryStakingStatsSetInput = {
  cycle?: InputMaybe<Scalars['Int']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  sync_at_block_height?: InputMaybe<Scalars['Int']>;
  token?: InputMaybe<Scalars['String']>;
  total_staked?: InputMaybe<Scalars['numeric']>;
};

/** aggregate stddev on columns */
export type LaplaceHistoryStakingStatsStddevFields = {
  __typename?: 'laplace_history_staking_stats_stddev_fields';
  cycle?: Maybe<Scalars['Float']>;
  sync_at_block_height?: Maybe<Scalars['Float']>;
  total_staked?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceHistoryStakingStatsStddevPopFields = {
  __typename?: 'laplace_history_staking_stats_stddev_pop_fields';
  cycle?: Maybe<Scalars['Float']>;
  sync_at_block_height?: Maybe<Scalars['Float']>;
  total_staked?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceHistoryStakingStatsStddevSampFields = {
  __typename?: 'laplace_history_staking_stats_stddev_samp_fields';
  cycle?: Maybe<Scalars['Float']>;
  sync_at_block_height?: Maybe<Scalars['Float']>;
  total_staked?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_history_staking_stats" */
export type LaplaceHistoryStakingStatsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceHistoryStakingStatsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceHistoryStakingStatsStreamCursorValueInput = {
  cycle?: InputMaybe<Scalars['Int']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  sync_at_block_height?: InputMaybe<Scalars['Int']>;
  token?: InputMaybe<Scalars['String']>;
  total_staked?: InputMaybe<Scalars['numeric']>;
};

/** aggregate sum on columns */
export type LaplaceHistoryStakingStatsSumFields = {
  __typename?: 'laplace_history_staking_stats_sum_fields';
  cycle?: Maybe<Scalars['Int']>;
  sync_at_block_height?: Maybe<Scalars['Int']>;
  total_staked?: Maybe<Scalars['numeric']>;
};

/** update columns of table "laplace.history_staking_stats" */
export enum LaplaceHistoryStakingStatsUpdateColumn {
  /** column name */
  Cycle = 'cycle',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  SyncAtBlockHeight = 'sync_at_block_height',
  /** column name */
  Token = 'token',
  /** column name */
  TotalStaked = 'total_staked'
}

export type LaplaceHistoryStakingStatsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceHistoryStakingStatsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceHistoryStakingStatsSetInput>;
  where: LaplaceHistoryStakingStatsBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceHistoryStakingStatsVarPopFields = {
  __typename?: 'laplace_history_staking_stats_var_pop_fields';
  cycle?: Maybe<Scalars['Float']>;
  sync_at_block_height?: Maybe<Scalars['Float']>;
  total_staked?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceHistoryStakingStatsVarSampFields = {
  __typename?: 'laplace_history_staking_stats_var_samp_fields';
  cycle?: Maybe<Scalars['Float']>;
  sync_at_block_height?: Maybe<Scalars['Float']>;
  total_staked?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceHistoryStakingStatsVarianceFields = {
  __typename?: 'laplace_history_staking_stats_variance_fields';
  cycle?: Maybe<Scalars['Float']>;
  sync_at_block_height?: Maybe<Scalars['Float']>;
  total_staked?: Maybe<Scalars['Float']>;
};

/** Tracks the data of IDO pools at initialization */
export type LaplaceIdoPoolCreation = {
  __typename?: 'laplace_ido_pool_creation';
  activation_threshold: Scalars['Int'];
  apower_per_ticket_in_fixed: Scalars['bigint'];
  block_height: Scalars['Int'];
  claim_end_height: Scalars['Int'];
  ido_owner: Scalars['String'];
  ido_token: Scalars['String'];
  ido_tokens_per_ticket: Scalars['Int'];
  payment_token: Scalars['String'];
  price_per_ticket_in_fixed: Scalars['bigint'];
  registration_end_height: Scalars['Int'];
  registration_start_height: Scalars['Int'];
  result_value: Scalars['Int'];
  transaction_result_type: Scalars['String'];
  tx_id: Scalars['String'];
};

/** aggregated selection of "laplace.ido_pool_creation" */
export type LaplaceIdoPoolCreationAggregate = {
  __typename?: 'laplace_ido_pool_creation_aggregate';
  aggregate?: Maybe<LaplaceIdoPoolCreationAggregateFields>;
  nodes: Array<LaplaceIdoPoolCreation>;
};

/** aggregate fields of "laplace.ido_pool_creation" */
export type LaplaceIdoPoolCreationAggregateFields = {
  __typename?: 'laplace_ido_pool_creation_aggregate_fields';
  avg?: Maybe<LaplaceIdoPoolCreationAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceIdoPoolCreationMaxFields>;
  min?: Maybe<LaplaceIdoPoolCreationMinFields>;
  stddev?: Maybe<LaplaceIdoPoolCreationStddevFields>;
  stddev_pop?: Maybe<LaplaceIdoPoolCreationStddevPopFields>;
  stddev_samp?: Maybe<LaplaceIdoPoolCreationStddevSampFields>;
  sum?: Maybe<LaplaceIdoPoolCreationSumFields>;
  var_pop?: Maybe<LaplaceIdoPoolCreationVarPopFields>;
  var_samp?: Maybe<LaplaceIdoPoolCreationVarSampFields>;
  variance?: Maybe<LaplaceIdoPoolCreationVarianceFields>;
};


/** aggregate fields of "laplace.ido_pool_creation" */
export type LaplaceIdoPoolCreationAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceIdoPoolCreationSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LaplaceIdoPoolCreationAvgFields = {
  __typename?: 'laplace_ido_pool_creation_avg_fields';
  activation_threshold?: Maybe<Scalars['Float']>;
  apower_per_ticket_in_fixed?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  claim_end_height?: Maybe<Scalars['Float']>;
  ido_tokens_per_ticket?: Maybe<Scalars['Float']>;
  price_per_ticket_in_fixed?: Maybe<Scalars['Float']>;
  registration_end_height?: Maybe<Scalars['Float']>;
  registration_start_height?: Maybe<Scalars['Float']>;
  result_value?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.ido_pool_creation". All fields are combined with a logical 'AND'. */
export type LaplaceIdoPoolCreationBoolExp = {
  _and?: InputMaybe<Array<LaplaceIdoPoolCreationBoolExp>>;
  _not?: InputMaybe<LaplaceIdoPoolCreationBoolExp>;
  _or?: InputMaybe<Array<LaplaceIdoPoolCreationBoolExp>>;
  activation_threshold?: InputMaybe<IntComparisonExp>;
  apower_per_ticket_in_fixed?: InputMaybe<BigintComparisonExp>;
  block_height?: InputMaybe<IntComparisonExp>;
  claim_end_height?: InputMaybe<IntComparisonExp>;
  ido_owner?: InputMaybe<StringComparisonExp>;
  ido_token?: InputMaybe<StringComparisonExp>;
  ido_tokens_per_ticket?: InputMaybe<IntComparisonExp>;
  payment_token?: InputMaybe<StringComparisonExp>;
  price_per_ticket_in_fixed?: InputMaybe<BigintComparisonExp>;
  registration_end_height?: InputMaybe<IntComparisonExp>;
  registration_start_height?: InputMaybe<IntComparisonExp>;
  result_value?: InputMaybe<IntComparisonExp>;
  transaction_result_type?: InputMaybe<StringComparisonExp>;
  tx_id?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "laplace.ido_pool_creation" */
export enum LaplaceIdoPoolCreationConstraint {
  /** unique or primary key constraint on columns "ido_owner", "registration_end_height", "activation_threshold", "payment_token", "apower_per_ticket_in_fixed", "ido_token", "claim_end_height", "ido_tokens_per_ticket", "tx_id", "registration_start_height" */
  IdoPoolCreationPkey = 'ido_pool_creation_pkey'
}

/** input type for incrementing numeric columns in table "laplace.ido_pool_creation" */
export type LaplaceIdoPoolCreationIncInput = {
  activation_threshold?: InputMaybe<Scalars['Int']>;
  apower_per_ticket_in_fixed?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  claim_end_height?: InputMaybe<Scalars['Int']>;
  ido_tokens_per_ticket?: InputMaybe<Scalars['Int']>;
  price_per_ticket_in_fixed?: InputMaybe<Scalars['bigint']>;
  registration_end_height?: InputMaybe<Scalars['Int']>;
  registration_start_height?: InputMaybe<Scalars['Int']>;
  result_value?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "laplace.ido_pool_creation" */
export type LaplaceIdoPoolCreationInsertInput = {
  activation_threshold?: InputMaybe<Scalars['Int']>;
  apower_per_ticket_in_fixed?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  claim_end_height?: InputMaybe<Scalars['Int']>;
  ido_owner?: InputMaybe<Scalars['String']>;
  ido_token?: InputMaybe<Scalars['String']>;
  ido_tokens_per_ticket?: InputMaybe<Scalars['Int']>;
  payment_token?: InputMaybe<Scalars['String']>;
  price_per_ticket_in_fixed?: InputMaybe<Scalars['bigint']>;
  registration_end_height?: InputMaybe<Scalars['Int']>;
  registration_start_height?: InputMaybe<Scalars['Int']>;
  result_value?: InputMaybe<Scalars['Int']>;
  transaction_result_type?: InputMaybe<Scalars['String']>;
  tx_id?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type LaplaceIdoPoolCreationMaxFields = {
  __typename?: 'laplace_ido_pool_creation_max_fields';
  activation_threshold?: Maybe<Scalars['Int']>;
  apower_per_ticket_in_fixed?: Maybe<Scalars['bigint']>;
  block_height?: Maybe<Scalars['Int']>;
  claim_end_height?: Maybe<Scalars['Int']>;
  ido_owner?: Maybe<Scalars['String']>;
  ido_token?: Maybe<Scalars['String']>;
  ido_tokens_per_ticket?: Maybe<Scalars['Int']>;
  payment_token?: Maybe<Scalars['String']>;
  price_per_ticket_in_fixed?: Maybe<Scalars['bigint']>;
  registration_end_height?: Maybe<Scalars['Int']>;
  registration_start_height?: Maybe<Scalars['Int']>;
  result_value?: Maybe<Scalars['Int']>;
  transaction_result_type?: Maybe<Scalars['String']>;
  tx_id?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LaplaceIdoPoolCreationMinFields = {
  __typename?: 'laplace_ido_pool_creation_min_fields';
  activation_threshold?: Maybe<Scalars['Int']>;
  apower_per_ticket_in_fixed?: Maybe<Scalars['bigint']>;
  block_height?: Maybe<Scalars['Int']>;
  claim_end_height?: Maybe<Scalars['Int']>;
  ido_owner?: Maybe<Scalars['String']>;
  ido_token?: Maybe<Scalars['String']>;
  ido_tokens_per_ticket?: Maybe<Scalars['Int']>;
  payment_token?: Maybe<Scalars['String']>;
  price_per_ticket_in_fixed?: Maybe<Scalars['bigint']>;
  registration_end_height?: Maybe<Scalars['Int']>;
  registration_start_height?: Maybe<Scalars['Int']>;
  result_value?: Maybe<Scalars['Int']>;
  transaction_result_type?: Maybe<Scalars['String']>;
  tx_id?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "laplace.ido_pool_creation" */
export type LaplaceIdoPoolCreationMutationResponse = {
  __typename?: 'laplace_ido_pool_creation_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceIdoPoolCreation>;
};

/** on_conflict condition type for table "laplace.ido_pool_creation" */
export type LaplaceIdoPoolCreationOnConflict = {
  constraint: LaplaceIdoPoolCreationConstraint;
  update_columns?: Array<LaplaceIdoPoolCreationUpdateColumn>;
  where?: InputMaybe<LaplaceIdoPoolCreationBoolExp>;
};

/** Ordering options when selecting data from "laplace.ido_pool_creation". */
export type LaplaceIdoPoolCreationOrderBy = {
  activation_threshold?: InputMaybe<OrderBy>;
  apower_per_ticket_in_fixed?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  claim_end_height?: InputMaybe<OrderBy>;
  ido_owner?: InputMaybe<OrderBy>;
  ido_token?: InputMaybe<OrderBy>;
  ido_tokens_per_ticket?: InputMaybe<OrderBy>;
  payment_token?: InputMaybe<OrderBy>;
  price_per_ticket_in_fixed?: InputMaybe<OrderBy>;
  registration_end_height?: InputMaybe<OrderBy>;
  registration_start_height?: InputMaybe<OrderBy>;
  result_value?: InputMaybe<OrderBy>;
  transaction_result_type?: InputMaybe<OrderBy>;
  tx_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.ido_pool_creation */
export type LaplaceIdoPoolCreationPkColumnsInput = {
  activation_threshold: Scalars['Int'];
  apower_per_ticket_in_fixed: Scalars['bigint'];
  claim_end_height: Scalars['Int'];
  ido_owner: Scalars['String'];
  ido_token: Scalars['String'];
  ido_tokens_per_ticket: Scalars['Int'];
  payment_token: Scalars['String'];
  registration_end_height: Scalars['Int'];
  registration_start_height: Scalars['Int'];
  tx_id: Scalars['String'];
};

/** select columns of table "laplace.ido_pool_creation" */
export enum LaplaceIdoPoolCreationSelectColumn {
  /** column name */
  ActivationThreshold = 'activation_threshold',
  /** column name */
  ApowerPerTicketInFixed = 'apower_per_ticket_in_fixed',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  ClaimEndHeight = 'claim_end_height',
  /** column name */
  IdoOwner = 'ido_owner',
  /** column name */
  IdoToken = 'ido_token',
  /** column name */
  IdoTokensPerTicket = 'ido_tokens_per_ticket',
  /** column name */
  PaymentToken = 'payment_token',
  /** column name */
  PricePerTicketInFixed = 'price_per_ticket_in_fixed',
  /** column name */
  RegistrationEndHeight = 'registration_end_height',
  /** column name */
  RegistrationStartHeight = 'registration_start_height',
  /** column name */
  ResultValue = 'result_value',
  /** column name */
  TransactionResultType = 'transaction_result_type',
  /** column name */
  TxId = 'tx_id'
}

/** input type for updating data in table "laplace.ido_pool_creation" */
export type LaplaceIdoPoolCreationSetInput = {
  activation_threshold?: InputMaybe<Scalars['Int']>;
  apower_per_ticket_in_fixed?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  claim_end_height?: InputMaybe<Scalars['Int']>;
  ido_owner?: InputMaybe<Scalars['String']>;
  ido_token?: InputMaybe<Scalars['String']>;
  ido_tokens_per_ticket?: InputMaybe<Scalars['Int']>;
  payment_token?: InputMaybe<Scalars['String']>;
  price_per_ticket_in_fixed?: InputMaybe<Scalars['bigint']>;
  registration_end_height?: InputMaybe<Scalars['Int']>;
  registration_start_height?: InputMaybe<Scalars['Int']>;
  result_value?: InputMaybe<Scalars['Int']>;
  transaction_result_type?: InputMaybe<Scalars['String']>;
  tx_id?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type LaplaceIdoPoolCreationStddevFields = {
  __typename?: 'laplace_ido_pool_creation_stddev_fields';
  activation_threshold?: Maybe<Scalars['Float']>;
  apower_per_ticket_in_fixed?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  claim_end_height?: Maybe<Scalars['Float']>;
  ido_tokens_per_ticket?: Maybe<Scalars['Float']>;
  price_per_ticket_in_fixed?: Maybe<Scalars['Float']>;
  registration_end_height?: Maybe<Scalars['Float']>;
  registration_start_height?: Maybe<Scalars['Float']>;
  result_value?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceIdoPoolCreationStddevPopFields = {
  __typename?: 'laplace_ido_pool_creation_stddev_pop_fields';
  activation_threshold?: Maybe<Scalars['Float']>;
  apower_per_ticket_in_fixed?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  claim_end_height?: Maybe<Scalars['Float']>;
  ido_tokens_per_ticket?: Maybe<Scalars['Float']>;
  price_per_ticket_in_fixed?: Maybe<Scalars['Float']>;
  registration_end_height?: Maybe<Scalars['Float']>;
  registration_start_height?: Maybe<Scalars['Float']>;
  result_value?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceIdoPoolCreationStddevSampFields = {
  __typename?: 'laplace_ido_pool_creation_stddev_samp_fields';
  activation_threshold?: Maybe<Scalars['Float']>;
  apower_per_ticket_in_fixed?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  claim_end_height?: Maybe<Scalars['Float']>;
  ido_tokens_per_ticket?: Maybe<Scalars['Float']>;
  price_per_ticket_in_fixed?: Maybe<Scalars['Float']>;
  registration_end_height?: Maybe<Scalars['Float']>;
  registration_start_height?: Maybe<Scalars['Float']>;
  result_value?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_ido_pool_creation" */
export type LaplaceIdoPoolCreationStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceIdoPoolCreationStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceIdoPoolCreationStreamCursorValueInput = {
  activation_threshold?: InputMaybe<Scalars['Int']>;
  apower_per_ticket_in_fixed?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  claim_end_height?: InputMaybe<Scalars['Int']>;
  ido_owner?: InputMaybe<Scalars['String']>;
  ido_token?: InputMaybe<Scalars['String']>;
  ido_tokens_per_ticket?: InputMaybe<Scalars['Int']>;
  payment_token?: InputMaybe<Scalars['String']>;
  price_per_ticket_in_fixed?: InputMaybe<Scalars['bigint']>;
  registration_end_height?: InputMaybe<Scalars['Int']>;
  registration_start_height?: InputMaybe<Scalars['Int']>;
  result_value?: InputMaybe<Scalars['Int']>;
  transaction_result_type?: InputMaybe<Scalars['String']>;
  tx_id?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type LaplaceIdoPoolCreationSumFields = {
  __typename?: 'laplace_ido_pool_creation_sum_fields';
  activation_threshold?: Maybe<Scalars['Int']>;
  apower_per_ticket_in_fixed?: Maybe<Scalars['bigint']>;
  block_height?: Maybe<Scalars['Int']>;
  claim_end_height?: Maybe<Scalars['Int']>;
  ido_tokens_per_ticket?: Maybe<Scalars['Int']>;
  price_per_ticket_in_fixed?: Maybe<Scalars['bigint']>;
  registration_end_height?: Maybe<Scalars['Int']>;
  registration_start_height?: Maybe<Scalars['Int']>;
  result_value?: Maybe<Scalars['Int']>;
};

/** update columns of table "laplace.ido_pool_creation" */
export enum LaplaceIdoPoolCreationUpdateColumn {
  /** column name */
  ActivationThreshold = 'activation_threshold',
  /** column name */
  ApowerPerTicketInFixed = 'apower_per_ticket_in_fixed',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  ClaimEndHeight = 'claim_end_height',
  /** column name */
  IdoOwner = 'ido_owner',
  /** column name */
  IdoToken = 'ido_token',
  /** column name */
  IdoTokensPerTicket = 'ido_tokens_per_ticket',
  /** column name */
  PaymentToken = 'payment_token',
  /** column name */
  PricePerTicketInFixed = 'price_per_ticket_in_fixed',
  /** column name */
  RegistrationEndHeight = 'registration_end_height',
  /** column name */
  RegistrationStartHeight = 'registration_start_height',
  /** column name */
  ResultValue = 'result_value',
  /** column name */
  TransactionResultType = 'transaction_result_type',
  /** column name */
  TxId = 'tx_id'
}

export type LaplaceIdoPoolCreationUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceIdoPoolCreationIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceIdoPoolCreationSetInput>;
  where: LaplaceIdoPoolCreationBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceIdoPoolCreationVarPopFields = {
  __typename?: 'laplace_ido_pool_creation_var_pop_fields';
  activation_threshold?: Maybe<Scalars['Float']>;
  apower_per_ticket_in_fixed?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  claim_end_height?: Maybe<Scalars['Float']>;
  ido_tokens_per_ticket?: Maybe<Scalars['Float']>;
  price_per_ticket_in_fixed?: Maybe<Scalars['Float']>;
  registration_end_height?: Maybe<Scalars['Float']>;
  registration_start_height?: Maybe<Scalars['Float']>;
  result_value?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceIdoPoolCreationVarSampFields = {
  __typename?: 'laplace_ido_pool_creation_var_samp_fields';
  activation_threshold?: Maybe<Scalars['Float']>;
  apower_per_ticket_in_fixed?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  claim_end_height?: Maybe<Scalars['Float']>;
  ido_tokens_per_ticket?: Maybe<Scalars['Float']>;
  price_per_ticket_in_fixed?: Maybe<Scalars['Float']>;
  registration_end_height?: Maybe<Scalars['Float']>;
  registration_start_height?: Maybe<Scalars['Float']>;
  result_value?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceIdoPoolCreationVarianceFields = {
  __typename?: 'laplace_ido_pool_creation_variance_fields';
  activation_threshold?: Maybe<Scalars['Float']>;
  apower_per_ticket_in_fixed?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  claim_end_height?: Maybe<Scalars['Float']>;
  ido_tokens_per_ticket?: Maybe<Scalars['Float']>;
  price_per_ticket_in_fixed?: Maybe<Scalars['Float']>;
  registration_end_height?: Maybe<Scalars['Float']>;
  registration_start_height?: Maybe<Scalars['Float']>;
  result_value?: Maybe<Scalars['Float']>;
};

/** ALEX ido register results from alex-launchpad.clar */
export type LaplaceIdoRegister = {
  __typename?: 'laplace_ido_register';
  amount?: Maybe<Scalars['bigint']>;
  apower: Scalars['bigint'];
  block_height: Scalars['Int'];
  contract_call_contract_id: Scalars['String'];
  ido_id: Scalars['Int'];
  payment_token: Scalars['String'];
  registered_end: Scalars['bigint'];
  registered_start: Scalars['bigint'];
  sender_address: Scalars['String'];
  tx_id: Scalars['bytea'];
};

/** aggregated selection of "laplace.ido_register" */
export type LaplaceIdoRegisterAggregate = {
  __typename?: 'laplace_ido_register_aggregate';
  aggregate?: Maybe<LaplaceIdoRegisterAggregateFields>;
  nodes: Array<LaplaceIdoRegister>;
};

/** aggregate fields of "laplace.ido_register" */
export type LaplaceIdoRegisterAggregateFields = {
  __typename?: 'laplace_ido_register_aggregate_fields';
  avg?: Maybe<LaplaceIdoRegisterAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceIdoRegisterMaxFields>;
  min?: Maybe<LaplaceIdoRegisterMinFields>;
  stddev?: Maybe<LaplaceIdoRegisterStddevFields>;
  stddev_pop?: Maybe<LaplaceIdoRegisterStddevPopFields>;
  stddev_samp?: Maybe<LaplaceIdoRegisterStddevSampFields>;
  sum?: Maybe<LaplaceIdoRegisterSumFields>;
  var_pop?: Maybe<LaplaceIdoRegisterVarPopFields>;
  var_samp?: Maybe<LaplaceIdoRegisterVarSampFields>;
  variance?: Maybe<LaplaceIdoRegisterVarianceFields>;
};


/** aggregate fields of "laplace.ido_register" */
export type LaplaceIdoRegisterAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceIdoRegisterSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LaplaceIdoRegisterAvgFields = {
  __typename?: 'laplace_ido_register_avg_fields';
  amount?: Maybe<Scalars['Float']>;
  apower?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  ido_id?: Maybe<Scalars['Float']>;
  registered_end?: Maybe<Scalars['Float']>;
  registered_start?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.ido_register". All fields are combined with a logical 'AND'. */
export type LaplaceIdoRegisterBoolExp = {
  _and?: InputMaybe<Array<LaplaceIdoRegisterBoolExp>>;
  _not?: InputMaybe<LaplaceIdoRegisterBoolExp>;
  _or?: InputMaybe<Array<LaplaceIdoRegisterBoolExp>>;
  amount?: InputMaybe<BigintComparisonExp>;
  apower?: InputMaybe<BigintComparisonExp>;
  block_height?: InputMaybe<IntComparisonExp>;
  contract_call_contract_id?: InputMaybe<StringComparisonExp>;
  ido_id?: InputMaybe<IntComparisonExp>;
  payment_token?: InputMaybe<StringComparisonExp>;
  registered_end?: InputMaybe<BigintComparisonExp>;
  registered_start?: InputMaybe<BigintComparisonExp>;
  sender_address?: InputMaybe<StringComparisonExp>;
  tx_id?: InputMaybe<ByteaComparisonExp>;
};

/** unique or primary key constraints on table "laplace.ido_register" */
export enum LaplaceIdoRegisterConstraint {
  /** unique or primary key constraint on columns "block_height", "tx_id" */
  IdoRegisterPkey = 'ido_register_pkey'
}

/** input type for incrementing numeric columns in table "laplace.ido_register" */
export type LaplaceIdoRegisterIncInput = {
  amount?: InputMaybe<Scalars['bigint']>;
  apower?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  ido_id?: InputMaybe<Scalars['Int']>;
  registered_end?: InputMaybe<Scalars['bigint']>;
  registered_start?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "laplace.ido_register" */
export type LaplaceIdoRegisterInsertInput = {
  amount?: InputMaybe<Scalars['bigint']>;
  apower?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  contract_call_contract_id?: InputMaybe<Scalars['String']>;
  ido_id?: InputMaybe<Scalars['Int']>;
  payment_token?: InputMaybe<Scalars['String']>;
  registered_end?: InputMaybe<Scalars['bigint']>;
  registered_start?: InputMaybe<Scalars['bigint']>;
  sender_address?: InputMaybe<Scalars['String']>;
  tx_id?: InputMaybe<Scalars['bytea']>;
};

/** aggregate max on columns */
export type LaplaceIdoRegisterMaxFields = {
  __typename?: 'laplace_ido_register_max_fields';
  amount?: Maybe<Scalars['bigint']>;
  apower?: Maybe<Scalars['bigint']>;
  block_height?: Maybe<Scalars['Int']>;
  contract_call_contract_id?: Maybe<Scalars['String']>;
  ido_id?: Maybe<Scalars['Int']>;
  payment_token?: Maybe<Scalars['String']>;
  registered_end?: Maybe<Scalars['bigint']>;
  registered_start?: Maybe<Scalars['bigint']>;
  sender_address?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LaplaceIdoRegisterMinFields = {
  __typename?: 'laplace_ido_register_min_fields';
  amount?: Maybe<Scalars['bigint']>;
  apower?: Maybe<Scalars['bigint']>;
  block_height?: Maybe<Scalars['Int']>;
  contract_call_contract_id?: Maybe<Scalars['String']>;
  ido_id?: Maybe<Scalars['Int']>;
  payment_token?: Maybe<Scalars['String']>;
  registered_end?: Maybe<Scalars['bigint']>;
  registered_start?: Maybe<Scalars['bigint']>;
  sender_address?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "laplace.ido_register" */
export type LaplaceIdoRegisterMutationResponse = {
  __typename?: 'laplace_ido_register_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceIdoRegister>;
};

/** on_conflict condition type for table "laplace.ido_register" */
export type LaplaceIdoRegisterOnConflict = {
  constraint: LaplaceIdoRegisterConstraint;
  update_columns?: Array<LaplaceIdoRegisterUpdateColumn>;
  where?: InputMaybe<LaplaceIdoRegisterBoolExp>;
};

/** Ordering options when selecting data from "laplace.ido_register". */
export type LaplaceIdoRegisterOrderBy = {
  amount?: InputMaybe<OrderBy>;
  apower?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  contract_call_contract_id?: InputMaybe<OrderBy>;
  ido_id?: InputMaybe<OrderBy>;
  payment_token?: InputMaybe<OrderBy>;
  registered_end?: InputMaybe<OrderBy>;
  registered_start?: InputMaybe<OrderBy>;
  sender_address?: InputMaybe<OrderBy>;
  tx_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.ido_register */
export type LaplaceIdoRegisterPkColumnsInput = {
  block_height: Scalars['Int'];
  tx_id: Scalars['bytea'];
};

/** select columns of table "laplace.ido_register" */
export enum LaplaceIdoRegisterSelectColumn {
  /** column name */
  Amount = 'amount',
  /** column name */
  Apower = 'apower',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  ContractCallContractId = 'contract_call_contract_id',
  /** column name */
  IdoId = 'ido_id',
  /** column name */
  PaymentToken = 'payment_token',
  /** column name */
  RegisteredEnd = 'registered_end',
  /** column name */
  RegisteredStart = 'registered_start',
  /** column name */
  SenderAddress = 'sender_address',
  /** column name */
  TxId = 'tx_id'
}

/** input type for updating data in table "laplace.ido_register" */
export type LaplaceIdoRegisterSetInput = {
  amount?: InputMaybe<Scalars['bigint']>;
  apower?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  contract_call_contract_id?: InputMaybe<Scalars['String']>;
  ido_id?: InputMaybe<Scalars['Int']>;
  payment_token?: InputMaybe<Scalars['String']>;
  registered_end?: InputMaybe<Scalars['bigint']>;
  registered_start?: InputMaybe<Scalars['bigint']>;
  sender_address?: InputMaybe<Scalars['String']>;
  tx_id?: InputMaybe<Scalars['bytea']>;
};

/** aggregate stddev on columns */
export type LaplaceIdoRegisterStddevFields = {
  __typename?: 'laplace_ido_register_stddev_fields';
  amount?: Maybe<Scalars['Float']>;
  apower?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  ido_id?: Maybe<Scalars['Float']>;
  registered_end?: Maybe<Scalars['Float']>;
  registered_start?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceIdoRegisterStddevPopFields = {
  __typename?: 'laplace_ido_register_stddev_pop_fields';
  amount?: Maybe<Scalars['Float']>;
  apower?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  ido_id?: Maybe<Scalars['Float']>;
  registered_end?: Maybe<Scalars['Float']>;
  registered_start?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceIdoRegisterStddevSampFields = {
  __typename?: 'laplace_ido_register_stddev_samp_fields';
  amount?: Maybe<Scalars['Float']>;
  apower?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  ido_id?: Maybe<Scalars['Float']>;
  registered_end?: Maybe<Scalars['Float']>;
  registered_start?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_ido_register" */
export type LaplaceIdoRegisterStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceIdoRegisterStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceIdoRegisterStreamCursorValueInput = {
  amount?: InputMaybe<Scalars['bigint']>;
  apower?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  contract_call_contract_id?: InputMaybe<Scalars['String']>;
  ido_id?: InputMaybe<Scalars['Int']>;
  payment_token?: InputMaybe<Scalars['String']>;
  registered_end?: InputMaybe<Scalars['bigint']>;
  registered_start?: InputMaybe<Scalars['bigint']>;
  sender_address?: InputMaybe<Scalars['String']>;
  tx_id?: InputMaybe<Scalars['bytea']>;
};

/** aggregate sum on columns */
export type LaplaceIdoRegisterSumFields = {
  __typename?: 'laplace_ido_register_sum_fields';
  amount?: Maybe<Scalars['bigint']>;
  apower?: Maybe<Scalars['bigint']>;
  block_height?: Maybe<Scalars['Int']>;
  ido_id?: Maybe<Scalars['Int']>;
  registered_end?: Maybe<Scalars['bigint']>;
  registered_start?: Maybe<Scalars['bigint']>;
};

/** update columns of table "laplace.ido_register" */
export enum LaplaceIdoRegisterUpdateColumn {
  /** column name */
  Amount = 'amount',
  /** column name */
  Apower = 'apower',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  ContractCallContractId = 'contract_call_contract_id',
  /** column name */
  IdoId = 'ido_id',
  /** column name */
  PaymentToken = 'payment_token',
  /** column name */
  RegisteredEnd = 'registered_end',
  /** column name */
  RegisteredStart = 'registered_start',
  /** column name */
  SenderAddress = 'sender_address',
  /** column name */
  TxId = 'tx_id'
}

export type LaplaceIdoRegisterUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceIdoRegisterIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceIdoRegisterSetInput>;
  where: LaplaceIdoRegisterBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceIdoRegisterVarPopFields = {
  __typename?: 'laplace_ido_register_var_pop_fields';
  amount?: Maybe<Scalars['Float']>;
  apower?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  ido_id?: Maybe<Scalars['Float']>;
  registered_end?: Maybe<Scalars['Float']>;
  registered_start?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceIdoRegisterVarSampFields = {
  __typename?: 'laplace_ido_register_var_samp_fields';
  amount?: Maybe<Scalars['Float']>;
  apower?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  ido_id?: Maybe<Scalars['Float']>;
  registered_end?: Maybe<Scalars['Float']>;
  registered_start?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceIdoRegisterVarianceFields = {
  __typename?: 'laplace_ido_register_variance_fields';
  amount?: Maybe<Scalars['Float']>;
  apower?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  ido_id?: Maybe<Scalars['Float']>;
  registered_end?: Maybe<Scalars['Float']>;
  registered_start?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "laplace.latest_alex_reserve_pools" */
export type LaplaceLatestAlexReservePools = {
  __typename?: 'laplace_latest_alex_reserve_pools';
  activation_block: Scalars['Int'];
  apower_multiplier: Scalars['bigint'];
  block_height: Scalars['Int'];
  burn_block_time: Scalars['Int'];
  coinbase_amount_1: Scalars['bigint'];
  coinbase_amount_2: Scalars['bigint'];
  coinbase_amount_3: Scalars['bigint'];
  coinbase_amount_4: Scalars['bigint'];
  coinbase_amount_5: Scalars['bigint'];
  current_cycle: Scalars['Int'];
  dual_yield_token_deployer_address?: Maybe<Scalars['String']>;
  dual_yield_token_multiplier?: Maybe<Scalars['bigint']>;
  dual_yield_token_name?: Maybe<Scalars['String']>;
  earning_preview: Scalars['jsonb'];
  reserved_balance: Scalars['bigint'];
  reward_cycle_length: Scalars['Int'];
  staking_stats: Scalars['jsonb'];
  sync_at: Scalars['timestamptz'];
  token_deployer_address: Scalars['String'];
  token_halving_cycle: Scalars['Int'];
  token_name: Scalars['String'];
};


/** columns and relationships of "laplace.latest_alex_reserve_pools" */
export type LaplaceLatestAlexReservePoolsEarningPreviewArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "laplace.latest_alex_reserve_pools" */
export type LaplaceLatestAlexReservePoolsStakingStatsArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "laplace.latest_alex_reserve_pools" */
export type LaplaceLatestAlexReservePoolsAggregate = {
  __typename?: 'laplace_latest_alex_reserve_pools_aggregate';
  aggregate?: Maybe<LaplaceLatestAlexReservePoolsAggregateFields>;
  nodes: Array<LaplaceLatestAlexReservePools>;
};

/** aggregate fields of "laplace.latest_alex_reserve_pools" */
export type LaplaceLatestAlexReservePoolsAggregateFields = {
  __typename?: 'laplace_latest_alex_reserve_pools_aggregate_fields';
  avg?: Maybe<LaplaceLatestAlexReservePoolsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceLatestAlexReservePoolsMaxFields>;
  min?: Maybe<LaplaceLatestAlexReservePoolsMinFields>;
  stddev?: Maybe<LaplaceLatestAlexReservePoolsStddevFields>;
  stddev_pop?: Maybe<LaplaceLatestAlexReservePoolsStddevPopFields>;
  stddev_samp?: Maybe<LaplaceLatestAlexReservePoolsStddevSampFields>;
  sum?: Maybe<LaplaceLatestAlexReservePoolsSumFields>;
  var_pop?: Maybe<LaplaceLatestAlexReservePoolsVarPopFields>;
  var_samp?: Maybe<LaplaceLatestAlexReservePoolsVarSampFields>;
  variance?: Maybe<LaplaceLatestAlexReservePoolsVarianceFields>;
};


/** aggregate fields of "laplace.latest_alex_reserve_pools" */
export type LaplaceLatestAlexReservePoolsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceLatestAlexReservePoolsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type LaplaceLatestAlexReservePoolsAppendInput = {
  earning_preview?: InputMaybe<Scalars['jsonb']>;
  staking_stats?: InputMaybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type LaplaceLatestAlexReservePoolsAvgFields = {
  __typename?: 'laplace_latest_alex_reserve_pools_avg_fields';
  activation_block?: Maybe<Scalars['Float']>;
  apower_multiplier?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  coinbase_amount_1?: Maybe<Scalars['Float']>;
  coinbase_amount_2?: Maybe<Scalars['Float']>;
  coinbase_amount_3?: Maybe<Scalars['Float']>;
  coinbase_amount_4?: Maybe<Scalars['Float']>;
  coinbase_amount_5?: Maybe<Scalars['Float']>;
  current_cycle?: Maybe<Scalars['Float']>;
  dual_yield_token_multiplier?: Maybe<Scalars['Float']>;
  reserved_balance?: Maybe<Scalars['Float']>;
  reward_cycle_length?: Maybe<Scalars['Float']>;
  token_halving_cycle?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.latest_alex_reserve_pools". All fields are combined with a logical 'AND'. */
export type LaplaceLatestAlexReservePoolsBoolExp = {
  _and?: InputMaybe<Array<LaplaceLatestAlexReservePoolsBoolExp>>;
  _not?: InputMaybe<LaplaceLatestAlexReservePoolsBoolExp>;
  _or?: InputMaybe<Array<LaplaceLatestAlexReservePoolsBoolExp>>;
  activation_block?: InputMaybe<IntComparisonExp>;
  apower_multiplier?: InputMaybe<BigintComparisonExp>;
  block_height?: InputMaybe<IntComparisonExp>;
  burn_block_time?: InputMaybe<IntComparisonExp>;
  coinbase_amount_1?: InputMaybe<BigintComparisonExp>;
  coinbase_amount_2?: InputMaybe<BigintComparisonExp>;
  coinbase_amount_3?: InputMaybe<BigintComparisonExp>;
  coinbase_amount_4?: InputMaybe<BigintComparisonExp>;
  coinbase_amount_5?: InputMaybe<BigintComparisonExp>;
  current_cycle?: InputMaybe<IntComparisonExp>;
  dual_yield_token_deployer_address?: InputMaybe<StringComparisonExp>;
  dual_yield_token_multiplier?: InputMaybe<BigintComparisonExp>;
  dual_yield_token_name?: InputMaybe<StringComparisonExp>;
  earning_preview?: InputMaybe<JsonbComparisonExp>;
  reserved_balance?: InputMaybe<BigintComparisonExp>;
  reward_cycle_length?: InputMaybe<IntComparisonExp>;
  staking_stats?: InputMaybe<JsonbComparisonExp>;
  sync_at?: InputMaybe<TimestamptzComparisonExp>;
  token_deployer_address?: InputMaybe<StringComparisonExp>;
  token_halving_cycle?: InputMaybe<IntComparisonExp>;
  token_name?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "laplace.latest_alex_reserve_pools" */
export enum LaplaceLatestAlexReservePoolsConstraint {
  /** unique or primary key constraint on columns "token_name", "token_deployer_address" */
  LatestAlexReservePoolsPkey = 'latest_alex_reserve_pools_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type LaplaceLatestAlexReservePoolsDeleteAtPathInput = {
  earning_preview?: InputMaybe<Array<Scalars['String']>>;
  staking_stats?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type LaplaceLatestAlexReservePoolsDeleteElemInput = {
  earning_preview?: InputMaybe<Scalars['Int']>;
  staking_stats?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type LaplaceLatestAlexReservePoolsDeleteKeyInput = {
  earning_preview?: InputMaybe<Scalars['String']>;
  staking_stats?: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "laplace.latest_alex_reserve_pools" */
export type LaplaceLatestAlexReservePoolsIncInput = {
  activation_block?: InputMaybe<Scalars['Int']>;
  apower_multiplier?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  coinbase_amount_1?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_2?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_3?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_4?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_5?: InputMaybe<Scalars['bigint']>;
  current_cycle?: InputMaybe<Scalars['Int']>;
  dual_yield_token_multiplier?: InputMaybe<Scalars['bigint']>;
  reserved_balance?: InputMaybe<Scalars['bigint']>;
  reward_cycle_length?: InputMaybe<Scalars['Int']>;
  token_halving_cycle?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "laplace.latest_alex_reserve_pools" */
export type LaplaceLatestAlexReservePoolsInsertInput = {
  activation_block?: InputMaybe<Scalars['Int']>;
  apower_multiplier?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  coinbase_amount_1?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_2?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_3?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_4?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_5?: InputMaybe<Scalars['bigint']>;
  current_cycle?: InputMaybe<Scalars['Int']>;
  dual_yield_token_deployer_address?: InputMaybe<Scalars['String']>;
  dual_yield_token_multiplier?: InputMaybe<Scalars['bigint']>;
  dual_yield_token_name?: InputMaybe<Scalars['String']>;
  earning_preview?: InputMaybe<Scalars['jsonb']>;
  reserved_balance?: InputMaybe<Scalars['bigint']>;
  reward_cycle_length?: InputMaybe<Scalars['Int']>;
  staking_stats?: InputMaybe<Scalars['jsonb']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_deployer_address?: InputMaybe<Scalars['String']>;
  token_halving_cycle?: InputMaybe<Scalars['Int']>;
  token_name?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type LaplaceLatestAlexReservePoolsMaxFields = {
  __typename?: 'laplace_latest_alex_reserve_pools_max_fields';
  activation_block?: Maybe<Scalars['Int']>;
  apower_multiplier?: Maybe<Scalars['bigint']>;
  block_height?: Maybe<Scalars['Int']>;
  burn_block_time?: Maybe<Scalars['Int']>;
  coinbase_amount_1?: Maybe<Scalars['bigint']>;
  coinbase_amount_2?: Maybe<Scalars['bigint']>;
  coinbase_amount_3?: Maybe<Scalars['bigint']>;
  coinbase_amount_4?: Maybe<Scalars['bigint']>;
  coinbase_amount_5?: Maybe<Scalars['bigint']>;
  current_cycle?: Maybe<Scalars['Int']>;
  dual_yield_token_deployer_address?: Maybe<Scalars['String']>;
  dual_yield_token_multiplier?: Maybe<Scalars['bigint']>;
  dual_yield_token_name?: Maybe<Scalars['String']>;
  reserved_balance?: Maybe<Scalars['bigint']>;
  reward_cycle_length?: Maybe<Scalars['Int']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_deployer_address?: Maybe<Scalars['String']>;
  token_halving_cycle?: Maybe<Scalars['Int']>;
  token_name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LaplaceLatestAlexReservePoolsMinFields = {
  __typename?: 'laplace_latest_alex_reserve_pools_min_fields';
  activation_block?: Maybe<Scalars['Int']>;
  apower_multiplier?: Maybe<Scalars['bigint']>;
  block_height?: Maybe<Scalars['Int']>;
  burn_block_time?: Maybe<Scalars['Int']>;
  coinbase_amount_1?: Maybe<Scalars['bigint']>;
  coinbase_amount_2?: Maybe<Scalars['bigint']>;
  coinbase_amount_3?: Maybe<Scalars['bigint']>;
  coinbase_amount_4?: Maybe<Scalars['bigint']>;
  coinbase_amount_5?: Maybe<Scalars['bigint']>;
  current_cycle?: Maybe<Scalars['Int']>;
  dual_yield_token_deployer_address?: Maybe<Scalars['String']>;
  dual_yield_token_multiplier?: Maybe<Scalars['bigint']>;
  dual_yield_token_name?: Maybe<Scalars['String']>;
  reserved_balance?: Maybe<Scalars['bigint']>;
  reward_cycle_length?: Maybe<Scalars['Int']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_deployer_address?: Maybe<Scalars['String']>;
  token_halving_cycle?: Maybe<Scalars['Int']>;
  token_name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "laplace.latest_alex_reserve_pools" */
export type LaplaceLatestAlexReservePoolsMutationResponse = {
  __typename?: 'laplace_latest_alex_reserve_pools_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceLatestAlexReservePools>;
};

/** on_conflict condition type for table "laplace.latest_alex_reserve_pools" */
export type LaplaceLatestAlexReservePoolsOnConflict = {
  constraint: LaplaceLatestAlexReservePoolsConstraint;
  update_columns?: Array<LaplaceLatestAlexReservePoolsUpdateColumn>;
  where?: InputMaybe<LaplaceLatestAlexReservePoolsBoolExp>;
};

/** Ordering options when selecting data from "laplace.latest_alex_reserve_pools". */
export type LaplaceLatestAlexReservePoolsOrderBy = {
  activation_block?: InputMaybe<OrderBy>;
  apower_multiplier?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  burn_block_time?: InputMaybe<OrderBy>;
  coinbase_amount_1?: InputMaybe<OrderBy>;
  coinbase_amount_2?: InputMaybe<OrderBy>;
  coinbase_amount_3?: InputMaybe<OrderBy>;
  coinbase_amount_4?: InputMaybe<OrderBy>;
  coinbase_amount_5?: InputMaybe<OrderBy>;
  current_cycle?: InputMaybe<OrderBy>;
  dual_yield_token_deployer_address?: InputMaybe<OrderBy>;
  dual_yield_token_multiplier?: InputMaybe<OrderBy>;
  dual_yield_token_name?: InputMaybe<OrderBy>;
  earning_preview?: InputMaybe<OrderBy>;
  reserved_balance?: InputMaybe<OrderBy>;
  reward_cycle_length?: InputMaybe<OrderBy>;
  staking_stats?: InputMaybe<OrderBy>;
  sync_at?: InputMaybe<OrderBy>;
  token_deployer_address?: InputMaybe<OrderBy>;
  token_halving_cycle?: InputMaybe<OrderBy>;
  token_name?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.latest_alex_reserve_pools */
export type LaplaceLatestAlexReservePoolsPkColumnsInput = {
  token_deployer_address: Scalars['String'];
  token_name: Scalars['String'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type LaplaceLatestAlexReservePoolsPrependInput = {
  earning_preview?: InputMaybe<Scalars['jsonb']>;
  staking_stats?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "laplace.latest_alex_reserve_pools" */
export enum LaplaceLatestAlexReservePoolsSelectColumn {
  /** column name */
  ActivationBlock = 'activation_block',
  /** column name */
  ApowerMultiplier = 'apower_multiplier',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  CoinbaseAmount_1 = 'coinbase_amount_1',
  /** column name */
  CoinbaseAmount_2 = 'coinbase_amount_2',
  /** column name */
  CoinbaseAmount_3 = 'coinbase_amount_3',
  /** column name */
  CoinbaseAmount_4 = 'coinbase_amount_4',
  /** column name */
  CoinbaseAmount_5 = 'coinbase_amount_5',
  /** column name */
  CurrentCycle = 'current_cycle',
  /** column name */
  DualYieldTokenDeployerAddress = 'dual_yield_token_deployer_address',
  /** column name */
  DualYieldTokenMultiplier = 'dual_yield_token_multiplier',
  /** column name */
  DualYieldTokenName = 'dual_yield_token_name',
  /** column name */
  EarningPreview = 'earning_preview',
  /** column name */
  ReservedBalance = 'reserved_balance',
  /** column name */
  RewardCycleLength = 'reward_cycle_length',
  /** column name */
  StakingStats = 'staking_stats',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenDeployerAddress = 'token_deployer_address',
  /** column name */
  TokenHalvingCycle = 'token_halving_cycle',
  /** column name */
  TokenName = 'token_name'
}

/** input type for updating data in table "laplace.latest_alex_reserve_pools" */
export type LaplaceLatestAlexReservePoolsSetInput = {
  activation_block?: InputMaybe<Scalars['Int']>;
  apower_multiplier?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  coinbase_amount_1?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_2?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_3?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_4?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_5?: InputMaybe<Scalars['bigint']>;
  current_cycle?: InputMaybe<Scalars['Int']>;
  dual_yield_token_deployer_address?: InputMaybe<Scalars['String']>;
  dual_yield_token_multiplier?: InputMaybe<Scalars['bigint']>;
  dual_yield_token_name?: InputMaybe<Scalars['String']>;
  earning_preview?: InputMaybe<Scalars['jsonb']>;
  reserved_balance?: InputMaybe<Scalars['bigint']>;
  reward_cycle_length?: InputMaybe<Scalars['Int']>;
  staking_stats?: InputMaybe<Scalars['jsonb']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_deployer_address?: InputMaybe<Scalars['String']>;
  token_halving_cycle?: InputMaybe<Scalars['Int']>;
  token_name?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type LaplaceLatestAlexReservePoolsStddevFields = {
  __typename?: 'laplace_latest_alex_reserve_pools_stddev_fields';
  activation_block?: Maybe<Scalars['Float']>;
  apower_multiplier?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  coinbase_amount_1?: Maybe<Scalars['Float']>;
  coinbase_amount_2?: Maybe<Scalars['Float']>;
  coinbase_amount_3?: Maybe<Scalars['Float']>;
  coinbase_amount_4?: Maybe<Scalars['Float']>;
  coinbase_amount_5?: Maybe<Scalars['Float']>;
  current_cycle?: Maybe<Scalars['Float']>;
  dual_yield_token_multiplier?: Maybe<Scalars['Float']>;
  reserved_balance?: Maybe<Scalars['Float']>;
  reward_cycle_length?: Maybe<Scalars['Float']>;
  token_halving_cycle?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceLatestAlexReservePoolsStddevPopFields = {
  __typename?: 'laplace_latest_alex_reserve_pools_stddev_pop_fields';
  activation_block?: Maybe<Scalars['Float']>;
  apower_multiplier?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  coinbase_amount_1?: Maybe<Scalars['Float']>;
  coinbase_amount_2?: Maybe<Scalars['Float']>;
  coinbase_amount_3?: Maybe<Scalars['Float']>;
  coinbase_amount_4?: Maybe<Scalars['Float']>;
  coinbase_amount_5?: Maybe<Scalars['Float']>;
  current_cycle?: Maybe<Scalars['Float']>;
  dual_yield_token_multiplier?: Maybe<Scalars['Float']>;
  reserved_balance?: Maybe<Scalars['Float']>;
  reward_cycle_length?: Maybe<Scalars['Float']>;
  token_halving_cycle?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceLatestAlexReservePoolsStddevSampFields = {
  __typename?: 'laplace_latest_alex_reserve_pools_stddev_samp_fields';
  activation_block?: Maybe<Scalars['Float']>;
  apower_multiplier?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  coinbase_amount_1?: Maybe<Scalars['Float']>;
  coinbase_amount_2?: Maybe<Scalars['Float']>;
  coinbase_amount_3?: Maybe<Scalars['Float']>;
  coinbase_amount_4?: Maybe<Scalars['Float']>;
  coinbase_amount_5?: Maybe<Scalars['Float']>;
  current_cycle?: Maybe<Scalars['Float']>;
  dual_yield_token_multiplier?: Maybe<Scalars['Float']>;
  reserved_balance?: Maybe<Scalars['Float']>;
  reward_cycle_length?: Maybe<Scalars['Float']>;
  token_halving_cycle?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_latest_alex_reserve_pools" */
export type LaplaceLatestAlexReservePoolsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceLatestAlexReservePoolsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceLatestAlexReservePoolsStreamCursorValueInput = {
  activation_block?: InputMaybe<Scalars['Int']>;
  apower_multiplier?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  coinbase_amount_1?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_2?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_3?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_4?: InputMaybe<Scalars['bigint']>;
  coinbase_amount_5?: InputMaybe<Scalars['bigint']>;
  current_cycle?: InputMaybe<Scalars['Int']>;
  dual_yield_token_deployer_address?: InputMaybe<Scalars['String']>;
  dual_yield_token_multiplier?: InputMaybe<Scalars['bigint']>;
  dual_yield_token_name?: InputMaybe<Scalars['String']>;
  earning_preview?: InputMaybe<Scalars['jsonb']>;
  reserved_balance?: InputMaybe<Scalars['bigint']>;
  reward_cycle_length?: InputMaybe<Scalars['Int']>;
  staking_stats?: InputMaybe<Scalars['jsonb']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_deployer_address?: InputMaybe<Scalars['String']>;
  token_halving_cycle?: InputMaybe<Scalars['Int']>;
  token_name?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type LaplaceLatestAlexReservePoolsSumFields = {
  __typename?: 'laplace_latest_alex_reserve_pools_sum_fields';
  activation_block?: Maybe<Scalars['Int']>;
  apower_multiplier?: Maybe<Scalars['bigint']>;
  block_height?: Maybe<Scalars['Int']>;
  burn_block_time?: Maybe<Scalars['Int']>;
  coinbase_amount_1?: Maybe<Scalars['bigint']>;
  coinbase_amount_2?: Maybe<Scalars['bigint']>;
  coinbase_amount_3?: Maybe<Scalars['bigint']>;
  coinbase_amount_4?: Maybe<Scalars['bigint']>;
  coinbase_amount_5?: Maybe<Scalars['bigint']>;
  current_cycle?: Maybe<Scalars['Int']>;
  dual_yield_token_multiplier?: Maybe<Scalars['bigint']>;
  reserved_balance?: Maybe<Scalars['bigint']>;
  reward_cycle_length?: Maybe<Scalars['Int']>;
  token_halving_cycle?: Maybe<Scalars['Int']>;
};

/** update columns of table "laplace.latest_alex_reserve_pools" */
export enum LaplaceLatestAlexReservePoolsUpdateColumn {
  /** column name */
  ActivationBlock = 'activation_block',
  /** column name */
  ApowerMultiplier = 'apower_multiplier',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  CoinbaseAmount_1 = 'coinbase_amount_1',
  /** column name */
  CoinbaseAmount_2 = 'coinbase_amount_2',
  /** column name */
  CoinbaseAmount_3 = 'coinbase_amount_3',
  /** column name */
  CoinbaseAmount_4 = 'coinbase_amount_4',
  /** column name */
  CoinbaseAmount_5 = 'coinbase_amount_5',
  /** column name */
  CurrentCycle = 'current_cycle',
  /** column name */
  DualYieldTokenDeployerAddress = 'dual_yield_token_deployer_address',
  /** column name */
  DualYieldTokenMultiplier = 'dual_yield_token_multiplier',
  /** column name */
  DualYieldTokenName = 'dual_yield_token_name',
  /** column name */
  EarningPreview = 'earning_preview',
  /** column name */
  ReservedBalance = 'reserved_balance',
  /** column name */
  RewardCycleLength = 'reward_cycle_length',
  /** column name */
  StakingStats = 'staking_stats',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenDeployerAddress = 'token_deployer_address',
  /** column name */
  TokenHalvingCycle = 'token_halving_cycle',
  /** column name */
  TokenName = 'token_name'
}

export type LaplaceLatestAlexReservePoolsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<LaplaceLatestAlexReservePoolsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<LaplaceLatestAlexReservePoolsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<LaplaceLatestAlexReservePoolsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<LaplaceLatestAlexReservePoolsDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceLatestAlexReservePoolsIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<LaplaceLatestAlexReservePoolsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceLatestAlexReservePoolsSetInput>;
  where: LaplaceLatestAlexReservePoolsBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceLatestAlexReservePoolsVarPopFields = {
  __typename?: 'laplace_latest_alex_reserve_pools_var_pop_fields';
  activation_block?: Maybe<Scalars['Float']>;
  apower_multiplier?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  coinbase_amount_1?: Maybe<Scalars['Float']>;
  coinbase_amount_2?: Maybe<Scalars['Float']>;
  coinbase_amount_3?: Maybe<Scalars['Float']>;
  coinbase_amount_4?: Maybe<Scalars['Float']>;
  coinbase_amount_5?: Maybe<Scalars['Float']>;
  current_cycle?: Maybe<Scalars['Float']>;
  dual_yield_token_multiplier?: Maybe<Scalars['Float']>;
  reserved_balance?: Maybe<Scalars['Float']>;
  reward_cycle_length?: Maybe<Scalars['Float']>;
  token_halving_cycle?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceLatestAlexReservePoolsVarSampFields = {
  __typename?: 'laplace_latest_alex_reserve_pools_var_samp_fields';
  activation_block?: Maybe<Scalars['Float']>;
  apower_multiplier?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  coinbase_amount_1?: Maybe<Scalars['Float']>;
  coinbase_amount_2?: Maybe<Scalars['Float']>;
  coinbase_amount_3?: Maybe<Scalars['Float']>;
  coinbase_amount_4?: Maybe<Scalars['Float']>;
  coinbase_amount_5?: Maybe<Scalars['Float']>;
  current_cycle?: Maybe<Scalars['Float']>;
  dual_yield_token_multiplier?: Maybe<Scalars['Float']>;
  reserved_balance?: Maybe<Scalars['Float']>;
  reward_cycle_length?: Maybe<Scalars['Float']>;
  token_halving_cycle?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceLatestAlexReservePoolsVarianceFields = {
  __typename?: 'laplace_latest_alex_reserve_pools_variance_fields';
  activation_block?: Maybe<Scalars['Float']>;
  apower_multiplier?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  coinbase_amount_1?: Maybe<Scalars['Float']>;
  coinbase_amount_2?: Maybe<Scalars['Float']>;
  coinbase_amount_3?: Maybe<Scalars['Float']>;
  coinbase_amount_4?: Maybe<Scalars['Float']>;
  coinbase_amount_5?: Maybe<Scalars['Float']>;
  current_cycle?: Maybe<Scalars['Float']>;
  dual_yield_token_multiplier?: Maybe<Scalars['Float']>;
  reserved_balance?: Maybe<Scalars['Float']>;
  reward_cycle_length?: Maybe<Scalars['Float']>;
  token_halving_cycle?: Maybe<Scalars['Float']>;
};

/** auto alex yield vault */
export type LaplaceLatestAutoAlex = {
  __typename?: 'laplace_latest_auto_alex';
  apys: Scalars['jsonb'];
  block_height: Scalars['Int'];
  burn_block_time: Scalars['Int'];
  current_cycle: Scalars['bigint'];
  pool_future_volume_stats: Scalars['jsonb'];
  pool_to_return_stats: Scalars['jsonb'];
  pool_total_staked_stats: Scalars['jsonb'];
  pool_user_id: Scalars['bigint'];
  sync_at: Scalars['timestamptz'];
  token_name: Scalars['String'];
};


/** auto alex yield vault */
export type LaplaceLatestAutoAlexApysArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** auto alex yield vault */
export type LaplaceLatestAutoAlexPoolFutureVolumeStatsArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** auto alex yield vault */
export type LaplaceLatestAutoAlexPoolToReturnStatsArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** auto alex yield vault */
export type LaplaceLatestAutoAlexPoolTotalStakedStatsArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "laplace.latest_auto_alex" */
export type LaplaceLatestAutoAlexAggregate = {
  __typename?: 'laplace_latest_auto_alex_aggregate';
  aggregate?: Maybe<LaplaceLatestAutoAlexAggregateFields>;
  nodes: Array<LaplaceLatestAutoAlex>;
};

/** aggregate fields of "laplace.latest_auto_alex" */
export type LaplaceLatestAutoAlexAggregateFields = {
  __typename?: 'laplace_latest_auto_alex_aggregate_fields';
  avg?: Maybe<LaplaceLatestAutoAlexAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceLatestAutoAlexMaxFields>;
  min?: Maybe<LaplaceLatestAutoAlexMinFields>;
  stddev?: Maybe<LaplaceLatestAutoAlexStddevFields>;
  stddev_pop?: Maybe<LaplaceLatestAutoAlexStddevPopFields>;
  stddev_samp?: Maybe<LaplaceLatestAutoAlexStddevSampFields>;
  sum?: Maybe<LaplaceLatestAutoAlexSumFields>;
  var_pop?: Maybe<LaplaceLatestAutoAlexVarPopFields>;
  var_samp?: Maybe<LaplaceLatestAutoAlexVarSampFields>;
  variance?: Maybe<LaplaceLatestAutoAlexVarianceFields>;
};


/** aggregate fields of "laplace.latest_auto_alex" */
export type LaplaceLatestAutoAlexAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceLatestAutoAlexSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type LaplaceLatestAutoAlexAppendInput = {
  apys?: InputMaybe<Scalars['jsonb']>;
  pool_future_volume_stats?: InputMaybe<Scalars['jsonb']>;
  pool_to_return_stats?: InputMaybe<Scalars['jsonb']>;
  pool_total_staked_stats?: InputMaybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type LaplaceLatestAutoAlexAvgFields = {
  __typename?: 'laplace_latest_auto_alex_avg_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  current_cycle?: Maybe<Scalars['Float']>;
  pool_user_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.latest_auto_alex". All fields are combined with a logical 'AND'. */
export type LaplaceLatestAutoAlexBoolExp = {
  _and?: InputMaybe<Array<LaplaceLatestAutoAlexBoolExp>>;
  _not?: InputMaybe<LaplaceLatestAutoAlexBoolExp>;
  _or?: InputMaybe<Array<LaplaceLatestAutoAlexBoolExp>>;
  apys?: InputMaybe<JsonbComparisonExp>;
  block_height?: InputMaybe<IntComparisonExp>;
  burn_block_time?: InputMaybe<IntComparisonExp>;
  current_cycle?: InputMaybe<BigintComparisonExp>;
  pool_future_volume_stats?: InputMaybe<JsonbComparisonExp>;
  pool_to_return_stats?: InputMaybe<JsonbComparisonExp>;
  pool_total_staked_stats?: InputMaybe<JsonbComparisonExp>;
  pool_user_id?: InputMaybe<BigintComparisonExp>;
  sync_at?: InputMaybe<TimestamptzComparisonExp>;
  token_name?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "laplace.latest_auto_alex" */
export enum LaplaceLatestAutoAlexConstraint {
  /** unique or primary key constraint on columns "token_name" */
  LatestAutoAlexPkey = 'latest_auto_alex_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type LaplaceLatestAutoAlexDeleteAtPathInput = {
  apys?: InputMaybe<Array<Scalars['String']>>;
  pool_future_volume_stats?: InputMaybe<Array<Scalars['String']>>;
  pool_to_return_stats?: InputMaybe<Array<Scalars['String']>>;
  pool_total_staked_stats?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type LaplaceLatestAutoAlexDeleteElemInput = {
  apys?: InputMaybe<Scalars['Int']>;
  pool_future_volume_stats?: InputMaybe<Scalars['Int']>;
  pool_to_return_stats?: InputMaybe<Scalars['Int']>;
  pool_total_staked_stats?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type LaplaceLatestAutoAlexDeleteKeyInput = {
  apys?: InputMaybe<Scalars['String']>;
  pool_future_volume_stats?: InputMaybe<Scalars['String']>;
  pool_to_return_stats?: InputMaybe<Scalars['String']>;
  pool_total_staked_stats?: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "laplace.latest_auto_alex" */
export type LaplaceLatestAutoAlexIncInput = {
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  current_cycle?: InputMaybe<Scalars['bigint']>;
  pool_user_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "laplace.latest_auto_alex" */
export type LaplaceLatestAutoAlexInsertInput = {
  apys?: InputMaybe<Scalars['jsonb']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  current_cycle?: InputMaybe<Scalars['bigint']>;
  pool_future_volume_stats?: InputMaybe<Scalars['jsonb']>;
  pool_to_return_stats?: InputMaybe<Scalars['jsonb']>;
  pool_total_staked_stats?: InputMaybe<Scalars['jsonb']>;
  pool_user_id?: InputMaybe<Scalars['bigint']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_name?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type LaplaceLatestAutoAlexMaxFields = {
  __typename?: 'laplace_latest_auto_alex_max_fields';
  block_height?: Maybe<Scalars['Int']>;
  burn_block_time?: Maybe<Scalars['Int']>;
  current_cycle?: Maybe<Scalars['bigint']>;
  pool_user_id?: Maybe<Scalars['bigint']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LaplaceLatestAutoAlexMinFields = {
  __typename?: 'laplace_latest_auto_alex_min_fields';
  block_height?: Maybe<Scalars['Int']>;
  burn_block_time?: Maybe<Scalars['Int']>;
  current_cycle?: Maybe<Scalars['bigint']>;
  pool_user_id?: Maybe<Scalars['bigint']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "laplace.latest_auto_alex" */
export type LaplaceLatestAutoAlexMutationResponse = {
  __typename?: 'laplace_latest_auto_alex_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceLatestAutoAlex>;
};

/** on_conflict condition type for table "laplace.latest_auto_alex" */
export type LaplaceLatestAutoAlexOnConflict = {
  constraint: LaplaceLatestAutoAlexConstraint;
  update_columns?: Array<LaplaceLatestAutoAlexUpdateColumn>;
  where?: InputMaybe<LaplaceLatestAutoAlexBoolExp>;
};

/** Ordering options when selecting data from "laplace.latest_auto_alex". */
export type LaplaceLatestAutoAlexOrderBy = {
  apys?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  burn_block_time?: InputMaybe<OrderBy>;
  current_cycle?: InputMaybe<OrderBy>;
  pool_future_volume_stats?: InputMaybe<OrderBy>;
  pool_to_return_stats?: InputMaybe<OrderBy>;
  pool_total_staked_stats?: InputMaybe<OrderBy>;
  pool_user_id?: InputMaybe<OrderBy>;
  sync_at?: InputMaybe<OrderBy>;
  token_name?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.latest_auto_alex */
export type LaplaceLatestAutoAlexPkColumnsInput = {
  token_name: Scalars['String'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type LaplaceLatestAutoAlexPrependInput = {
  apys?: InputMaybe<Scalars['jsonb']>;
  pool_future_volume_stats?: InputMaybe<Scalars['jsonb']>;
  pool_to_return_stats?: InputMaybe<Scalars['jsonb']>;
  pool_total_staked_stats?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "laplace.latest_auto_alex" */
export enum LaplaceLatestAutoAlexSelectColumn {
  /** column name */
  Apys = 'apys',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  CurrentCycle = 'current_cycle',
  /** column name */
  PoolFutureVolumeStats = 'pool_future_volume_stats',
  /** column name */
  PoolToReturnStats = 'pool_to_return_stats',
  /** column name */
  PoolTotalStakedStats = 'pool_total_staked_stats',
  /** column name */
  PoolUserId = 'pool_user_id',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenName = 'token_name'
}

/** input type for updating data in table "laplace.latest_auto_alex" */
export type LaplaceLatestAutoAlexSetInput = {
  apys?: InputMaybe<Scalars['jsonb']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  current_cycle?: InputMaybe<Scalars['bigint']>;
  pool_future_volume_stats?: InputMaybe<Scalars['jsonb']>;
  pool_to_return_stats?: InputMaybe<Scalars['jsonb']>;
  pool_total_staked_stats?: InputMaybe<Scalars['jsonb']>;
  pool_user_id?: InputMaybe<Scalars['bigint']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_name?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type LaplaceLatestAutoAlexStddevFields = {
  __typename?: 'laplace_latest_auto_alex_stddev_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  current_cycle?: Maybe<Scalars['Float']>;
  pool_user_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceLatestAutoAlexStddevPopFields = {
  __typename?: 'laplace_latest_auto_alex_stddev_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  current_cycle?: Maybe<Scalars['Float']>;
  pool_user_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceLatestAutoAlexStddevSampFields = {
  __typename?: 'laplace_latest_auto_alex_stddev_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  current_cycle?: Maybe<Scalars['Float']>;
  pool_user_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_latest_auto_alex" */
export type LaplaceLatestAutoAlexStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceLatestAutoAlexStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceLatestAutoAlexStreamCursorValueInput = {
  apys?: InputMaybe<Scalars['jsonb']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  current_cycle?: InputMaybe<Scalars['bigint']>;
  pool_future_volume_stats?: InputMaybe<Scalars['jsonb']>;
  pool_to_return_stats?: InputMaybe<Scalars['jsonb']>;
  pool_total_staked_stats?: InputMaybe<Scalars['jsonb']>;
  pool_user_id?: InputMaybe<Scalars['bigint']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_name?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type LaplaceLatestAutoAlexSumFields = {
  __typename?: 'laplace_latest_auto_alex_sum_fields';
  block_height?: Maybe<Scalars['Int']>;
  burn_block_time?: Maybe<Scalars['Int']>;
  current_cycle?: Maybe<Scalars['bigint']>;
  pool_user_id?: Maybe<Scalars['bigint']>;
};

/** update columns of table "laplace.latest_auto_alex" */
export enum LaplaceLatestAutoAlexUpdateColumn {
  /** column name */
  Apys = 'apys',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  CurrentCycle = 'current_cycle',
  /** column name */
  PoolFutureVolumeStats = 'pool_future_volume_stats',
  /** column name */
  PoolToReturnStats = 'pool_to_return_stats',
  /** column name */
  PoolTotalStakedStats = 'pool_total_staked_stats',
  /** column name */
  PoolUserId = 'pool_user_id',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenName = 'token_name'
}

export type LaplaceLatestAutoAlexUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<LaplaceLatestAutoAlexAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<LaplaceLatestAutoAlexDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<LaplaceLatestAutoAlexDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<LaplaceLatestAutoAlexDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceLatestAutoAlexIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<LaplaceLatestAutoAlexPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceLatestAutoAlexSetInput>;
  where: LaplaceLatestAutoAlexBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceLatestAutoAlexVarPopFields = {
  __typename?: 'laplace_latest_auto_alex_var_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  current_cycle?: Maybe<Scalars['Float']>;
  pool_user_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceLatestAutoAlexVarSampFields = {
  __typename?: 'laplace_latest_auto_alex_var_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  current_cycle?: Maybe<Scalars['Float']>;
  pool_user_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceLatestAutoAlexVarianceFields = {
  __typename?: 'laplace_latest_auto_alex_variance_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  current_cycle?: Maybe<Scalars['Float']>;
  pool_user_id?: Maybe<Scalars['Float']>;
};

/** ALEX latest collateral per share */
export type LaplaceLatestCollateralPerShare = {
  __typename?: 'laplace_latest_collateral_per_share';
  block_height: Scalars['numeric'];
  burn_block_time: Scalars['numeric'];
  collateral_per_share: Scalars['numeric'];
  est_fwp_collateral_price?: Maybe<Scalars['numeric']>;
  expiry: Scalars['numeric'];
  sync_at: Scalars['timestamptz'];
  token_per_share: Scalars['numeric'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};

/** aggregated selection of "laplace.latest_collateral_per_share" */
export type LaplaceLatestCollateralPerShareAggregate = {
  __typename?: 'laplace_latest_collateral_per_share_aggregate';
  aggregate?: Maybe<LaplaceLatestCollateralPerShareAggregateFields>;
  nodes: Array<LaplaceLatestCollateralPerShare>;
};

/** aggregate fields of "laplace.latest_collateral_per_share" */
export type LaplaceLatestCollateralPerShareAggregateFields = {
  __typename?: 'laplace_latest_collateral_per_share_aggregate_fields';
  avg?: Maybe<LaplaceLatestCollateralPerShareAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceLatestCollateralPerShareMaxFields>;
  min?: Maybe<LaplaceLatestCollateralPerShareMinFields>;
  stddev?: Maybe<LaplaceLatestCollateralPerShareStddevFields>;
  stddev_pop?: Maybe<LaplaceLatestCollateralPerShareStddevPopFields>;
  stddev_samp?: Maybe<LaplaceLatestCollateralPerShareStddevSampFields>;
  sum?: Maybe<LaplaceLatestCollateralPerShareSumFields>;
  var_pop?: Maybe<LaplaceLatestCollateralPerShareVarPopFields>;
  var_samp?: Maybe<LaplaceLatestCollateralPerShareVarSampFields>;
  variance?: Maybe<LaplaceLatestCollateralPerShareVarianceFields>;
};


/** aggregate fields of "laplace.latest_collateral_per_share" */
export type LaplaceLatestCollateralPerShareAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceLatestCollateralPerShareSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LaplaceLatestCollateralPerShareAvgFields = {
  __typename?: 'laplace_latest_collateral_per_share_avg_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  collateral_per_share?: Maybe<Scalars['Float']>;
  est_fwp_collateral_price?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  token_per_share?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.latest_collateral_per_share". All fields are combined with a logical 'AND'. */
export type LaplaceLatestCollateralPerShareBoolExp = {
  _and?: InputMaybe<Array<LaplaceLatestCollateralPerShareBoolExp>>;
  _not?: InputMaybe<LaplaceLatestCollateralPerShareBoolExp>;
  _or?: InputMaybe<Array<LaplaceLatestCollateralPerShareBoolExp>>;
  block_height?: InputMaybe<NumericComparisonExp>;
  burn_block_time?: InputMaybe<NumericComparisonExp>;
  collateral_per_share?: InputMaybe<NumericComparisonExp>;
  est_fwp_collateral_price?: InputMaybe<NumericComparisonExp>;
  expiry?: InputMaybe<NumericComparisonExp>;
  sync_at?: InputMaybe<TimestamptzComparisonExp>;
  token_per_share?: InputMaybe<NumericComparisonExp>;
  token_x?: InputMaybe<StringComparisonExp>;
  token_y?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "laplace.latest_collateral_per_share" */
export enum LaplaceLatestCollateralPerShareConstraint {
  /** unique or primary key constraint on columns "token_y", "expiry", "token_x" */
  LatestCollateralPerSharePkey = 'latest_collateral_per_share_pkey'
}

/** input type for incrementing numeric columns in table "laplace.latest_collateral_per_share" */
export type LaplaceLatestCollateralPerShareIncInput = {
  block_height?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  collateral_per_share?: InputMaybe<Scalars['numeric']>;
  est_fwp_collateral_price?: InputMaybe<Scalars['numeric']>;
  expiry?: InputMaybe<Scalars['numeric']>;
  token_per_share?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "laplace.latest_collateral_per_share" */
export type LaplaceLatestCollateralPerShareInsertInput = {
  block_height?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  collateral_per_share?: InputMaybe<Scalars['numeric']>;
  est_fwp_collateral_price?: InputMaybe<Scalars['numeric']>;
  expiry?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_per_share?: InputMaybe<Scalars['numeric']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type LaplaceLatestCollateralPerShareMaxFields = {
  __typename?: 'laplace_latest_collateral_per_share_max_fields';
  block_height?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  collateral_per_share?: Maybe<Scalars['numeric']>;
  est_fwp_collateral_price?: Maybe<Scalars['numeric']>;
  expiry?: Maybe<Scalars['numeric']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_per_share?: Maybe<Scalars['numeric']>;
  token_x?: Maybe<Scalars['String']>;
  token_y?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LaplaceLatestCollateralPerShareMinFields = {
  __typename?: 'laplace_latest_collateral_per_share_min_fields';
  block_height?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  collateral_per_share?: Maybe<Scalars['numeric']>;
  est_fwp_collateral_price?: Maybe<Scalars['numeric']>;
  expiry?: Maybe<Scalars['numeric']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_per_share?: Maybe<Scalars['numeric']>;
  token_x?: Maybe<Scalars['String']>;
  token_y?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "laplace.latest_collateral_per_share" */
export type LaplaceLatestCollateralPerShareMutationResponse = {
  __typename?: 'laplace_latest_collateral_per_share_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceLatestCollateralPerShare>;
};

/** on_conflict condition type for table "laplace.latest_collateral_per_share" */
export type LaplaceLatestCollateralPerShareOnConflict = {
  constraint: LaplaceLatestCollateralPerShareConstraint;
  update_columns?: Array<LaplaceLatestCollateralPerShareUpdateColumn>;
  where?: InputMaybe<LaplaceLatestCollateralPerShareBoolExp>;
};

/** Ordering options when selecting data from "laplace.latest_collateral_per_share". */
export type LaplaceLatestCollateralPerShareOrderBy = {
  block_height?: InputMaybe<OrderBy>;
  burn_block_time?: InputMaybe<OrderBy>;
  collateral_per_share?: InputMaybe<OrderBy>;
  est_fwp_collateral_price?: InputMaybe<OrderBy>;
  expiry?: InputMaybe<OrderBy>;
  sync_at?: InputMaybe<OrderBy>;
  token_per_share?: InputMaybe<OrderBy>;
  token_x?: InputMaybe<OrderBy>;
  token_y?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.latest_collateral_per_share */
export type LaplaceLatestCollateralPerSharePkColumnsInput = {
  expiry: Scalars['numeric'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};

/** select columns of table "laplace.latest_collateral_per_share" */
export enum LaplaceLatestCollateralPerShareSelectColumn {
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  CollateralPerShare = 'collateral_per_share',
  /** column name */
  EstFwpCollateralPrice = 'est_fwp_collateral_price',
  /** column name */
  Expiry = 'expiry',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenPerShare = 'token_per_share',
  /** column name */
  TokenX = 'token_x',
  /** column name */
  TokenY = 'token_y'
}

/** input type for updating data in table "laplace.latest_collateral_per_share" */
export type LaplaceLatestCollateralPerShareSetInput = {
  block_height?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  collateral_per_share?: InputMaybe<Scalars['numeric']>;
  est_fwp_collateral_price?: InputMaybe<Scalars['numeric']>;
  expiry?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_per_share?: InputMaybe<Scalars['numeric']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type LaplaceLatestCollateralPerShareStddevFields = {
  __typename?: 'laplace_latest_collateral_per_share_stddev_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  collateral_per_share?: Maybe<Scalars['Float']>;
  est_fwp_collateral_price?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  token_per_share?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceLatestCollateralPerShareStddevPopFields = {
  __typename?: 'laplace_latest_collateral_per_share_stddev_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  collateral_per_share?: Maybe<Scalars['Float']>;
  est_fwp_collateral_price?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  token_per_share?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceLatestCollateralPerShareStddevSampFields = {
  __typename?: 'laplace_latest_collateral_per_share_stddev_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  collateral_per_share?: Maybe<Scalars['Float']>;
  est_fwp_collateral_price?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  token_per_share?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_latest_collateral_per_share" */
export type LaplaceLatestCollateralPerShareStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceLatestCollateralPerShareStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceLatestCollateralPerShareStreamCursorValueInput = {
  block_height?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  collateral_per_share?: InputMaybe<Scalars['numeric']>;
  est_fwp_collateral_price?: InputMaybe<Scalars['numeric']>;
  expiry?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_per_share?: InputMaybe<Scalars['numeric']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type LaplaceLatestCollateralPerShareSumFields = {
  __typename?: 'laplace_latest_collateral_per_share_sum_fields';
  block_height?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  collateral_per_share?: Maybe<Scalars['numeric']>;
  est_fwp_collateral_price?: Maybe<Scalars['numeric']>;
  expiry?: Maybe<Scalars['numeric']>;
  token_per_share?: Maybe<Scalars['numeric']>;
};

/** update columns of table "laplace.latest_collateral_per_share" */
export enum LaplaceLatestCollateralPerShareUpdateColumn {
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  CollateralPerShare = 'collateral_per_share',
  /** column name */
  EstFwpCollateralPrice = 'est_fwp_collateral_price',
  /** column name */
  Expiry = 'expiry',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenPerShare = 'token_per_share',
  /** column name */
  TokenX = 'token_x',
  /** column name */
  TokenY = 'token_y'
}

export type LaplaceLatestCollateralPerShareUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceLatestCollateralPerShareIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceLatestCollateralPerShareSetInput>;
  where: LaplaceLatestCollateralPerShareBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceLatestCollateralPerShareVarPopFields = {
  __typename?: 'laplace_latest_collateral_per_share_var_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  collateral_per_share?: Maybe<Scalars['Float']>;
  est_fwp_collateral_price?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  token_per_share?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceLatestCollateralPerShareVarSampFields = {
  __typename?: 'laplace_latest_collateral_per_share_var_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  collateral_per_share?: Maybe<Scalars['Float']>;
  est_fwp_collateral_price?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  token_per_share?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceLatestCollateralPerShareVarianceFields = {
  __typename?: 'laplace_latest_collateral_per_share_variance_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  collateral_per_share?: Maybe<Scalars['Float']>;
  est_fwp_collateral_price?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  token_per_share?: Maybe<Scalars['Float']>;
};

/** ALEX latest collateral rebalancing pool */
export type LaplaceLatestCollateralRebalancingPool = {
  __typename?: 'laplace_latest_collateral_rebalancing_pool';
  balance_x: Scalars['numeric'];
  balance_y: Scalars['numeric'];
  block_height: Scalars['numeric'];
  bs_vol: Scalars['numeric'];
  burn_block_time: Scalars['numeric'];
  conversion_ltv: Scalars['numeric'];
  est_collateral_price: Scalars['numeric'];
  est_collateral_price_per_key_token: Scalars['numeric'];
  est_fwp_collateral_price?: Maybe<Scalars['numeric']>;
  est_token_price_per_key_token: Scalars['numeric'];
  est_total_pool_value: Scalars['numeric'];
  expiry: Scalars['numeric'];
  fee_rate_x: Scalars['numeric'];
  fee_rate_y: Scalars['numeric'];
  fee_rebate: Scalars['numeric'];
  fee_to_address: Scalars['String'];
  final_collateral_per_share?: Maybe<Scalars['numeric']>;
  final_token_per_share?: Maybe<Scalars['numeric']>;
  key_supply: Scalars['numeric'];
  key_token: Scalars['String'];
  ltv_0: Scalars['numeric'];
  moving_average: Scalars['numeric'];
  strike: Scalars['numeric'];
  sync_at: Scalars['timestamptz'];
  token_to_maturity: Scalars['numeric'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
  weight_x: Scalars['numeric'];
  weight_y: Scalars['numeric'];
  yield_supply: Scalars['numeric'];
  yield_token: Scalars['String'];
};

/** aggregated selection of "laplace.latest_collateral_rebalancing_pool" */
export type LaplaceLatestCollateralRebalancingPoolAggregate = {
  __typename?: 'laplace_latest_collateral_rebalancing_pool_aggregate';
  aggregate?: Maybe<LaplaceLatestCollateralRebalancingPoolAggregateFields>;
  nodes: Array<LaplaceLatestCollateralRebalancingPool>;
};

/** aggregate fields of "laplace.latest_collateral_rebalancing_pool" */
export type LaplaceLatestCollateralRebalancingPoolAggregateFields = {
  __typename?: 'laplace_latest_collateral_rebalancing_pool_aggregate_fields';
  avg?: Maybe<LaplaceLatestCollateralRebalancingPoolAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceLatestCollateralRebalancingPoolMaxFields>;
  min?: Maybe<LaplaceLatestCollateralRebalancingPoolMinFields>;
  stddev?: Maybe<LaplaceLatestCollateralRebalancingPoolStddevFields>;
  stddev_pop?: Maybe<LaplaceLatestCollateralRebalancingPoolStddevPopFields>;
  stddev_samp?: Maybe<LaplaceLatestCollateralRebalancingPoolStddevSampFields>;
  sum?: Maybe<LaplaceLatestCollateralRebalancingPoolSumFields>;
  var_pop?: Maybe<LaplaceLatestCollateralRebalancingPoolVarPopFields>;
  var_samp?: Maybe<LaplaceLatestCollateralRebalancingPoolVarSampFields>;
  variance?: Maybe<LaplaceLatestCollateralRebalancingPoolVarianceFields>;
};


/** aggregate fields of "laplace.latest_collateral_rebalancing_pool" */
export type LaplaceLatestCollateralRebalancingPoolAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceLatestCollateralRebalancingPoolSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LaplaceLatestCollateralRebalancingPoolAvgFields = {
  __typename?: 'laplace_latest_collateral_rebalancing_pool_avg_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  bs_vol?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  conversion_ltv?: Maybe<Scalars['Float']>;
  est_collateral_price?: Maybe<Scalars['Float']>;
  est_collateral_price_per_key_token?: Maybe<Scalars['Float']>;
  est_fwp_collateral_price?: Maybe<Scalars['Float']>;
  est_token_price_per_key_token?: Maybe<Scalars['Float']>;
  est_total_pool_value?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  final_collateral_per_share?: Maybe<Scalars['Float']>;
  final_token_per_share?: Maybe<Scalars['Float']>;
  key_supply?: Maybe<Scalars['Float']>;
  ltv_0?: Maybe<Scalars['Float']>;
  moving_average?: Maybe<Scalars['Float']>;
  strike?: Maybe<Scalars['Float']>;
  token_to_maturity?: Maybe<Scalars['Float']>;
  weight_x?: Maybe<Scalars['Float']>;
  weight_y?: Maybe<Scalars['Float']>;
  yield_supply?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.latest_collateral_rebalancing_pool". All fields are combined with a logical 'AND'. */
export type LaplaceLatestCollateralRebalancingPoolBoolExp = {
  _and?: InputMaybe<Array<LaplaceLatestCollateralRebalancingPoolBoolExp>>;
  _not?: InputMaybe<LaplaceLatestCollateralRebalancingPoolBoolExp>;
  _or?: InputMaybe<Array<LaplaceLatestCollateralRebalancingPoolBoolExp>>;
  balance_x?: InputMaybe<NumericComparisonExp>;
  balance_y?: InputMaybe<NumericComparisonExp>;
  block_height?: InputMaybe<NumericComparisonExp>;
  bs_vol?: InputMaybe<NumericComparisonExp>;
  burn_block_time?: InputMaybe<NumericComparisonExp>;
  conversion_ltv?: InputMaybe<NumericComparisonExp>;
  est_collateral_price?: InputMaybe<NumericComparisonExp>;
  est_collateral_price_per_key_token?: InputMaybe<NumericComparisonExp>;
  est_fwp_collateral_price?: InputMaybe<NumericComparisonExp>;
  est_token_price_per_key_token?: InputMaybe<NumericComparisonExp>;
  est_total_pool_value?: InputMaybe<NumericComparisonExp>;
  expiry?: InputMaybe<NumericComparisonExp>;
  fee_rate_x?: InputMaybe<NumericComparisonExp>;
  fee_rate_y?: InputMaybe<NumericComparisonExp>;
  fee_rebate?: InputMaybe<NumericComparisonExp>;
  fee_to_address?: InputMaybe<StringComparisonExp>;
  final_collateral_per_share?: InputMaybe<NumericComparisonExp>;
  final_token_per_share?: InputMaybe<NumericComparisonExp>;
  key_supply?: InputMaybe<NumericComparisonExp>;
  key_token?: InputMaybe<StringComparisonExp>;
  ltv_0?: InputMaybe<NumericComparisonExp>;
  moving_average?: InputMaybe<NumericComparisonExp>;
  strike?: InputMaybe<NumericComparisonExp>;
  sync_at?: InputMaybe<TimestamptzComparisonExp>;
  token_to_maturity?: InputMaybe<NumericComparisonExp>;
  token_x?: InputMaybe<StringComparisonExp>;
  token_y?: InputMaybe<StringComparisonExp>;
  weight_x?: InputMaybe<NumericComparisonExp>;
  weight_y?: InputMaybe<NumericComparisonExp>;
  yield_supply?: InputMaybe<NumericComparisonExp>;
  yield_token?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "laplace.latest_collateral_rebalancing_pool" */
export enum LaplaceLatestCollateralRebalancingPoolConstraint {
  /** unique or primary key constraint on columns "token_y", "expiry", "token_x" */
  LatestCollateralRebalancingPoolPkey = 'latest_collateral_rebalancing_pool_pkey'
}

/** input type for incrementing numeric columns in table "laplace.latest_collateral_rebalancing_pool" */
export type LaplaceLatestCollateralRebalancingPoolIncInput = {
  balance_x?: InputMaybe<Scalars['numeric']>;
  balance_y?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  bs_vol?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  conversion_ltv?: InputMaybe<Scalars['numeric']>;
  est_collateral_price?: InputMaybe<Scalars['numeric']>;
  est_collateral_price_per_key_token?: InputMaybe<Scalars['numeric']>;
  est_fwp_collateral_price?: InputMaybe<Scalars['numeric']>;
  est_token_price_per_key_token?: InputMaybe<Scalars['numeric']>;
  est_total_pool_value?: InputMaybe<Scalars['numeric']>;
  expiry?: InputMaybe<Scalars['numeric']>;
  fee_rate_x?: InputMaybe<Scalars['numeric']>;
  fee_rate_y?: InputMaybe<Scalars['numeric']>;
  fee_rebate?: InputMaybe<Scalars['numeric']>;
  final_collateral_per_share?: InputMaybe<Scalars['numeric']>;
  final_token_per_share?: InputMaybe<Scalars['numeric']>;
  key_supply?: InputMaybe<Scalars['numeric']>;
  ltv_0?: InputMaybe<Scalars['numeric']>;
  moving_average?: InputMaybe<Scalars['numeric']>;
  strike?: InputMaybe<Scalars['numeric']>;
  token_to_maturity?: InputMaybe<Scalars['numeric']>;
  weight_x?: InputMaybe<Scalars['numeric']>;
  weight_y?: InputMaybe<Scalars['numeric']>;
  yield_supply?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "laplace.latest_collateral_rebalancing_pool" */
export type LaplaceLatestCollateralRebalancingPoolInsertInput = {
  balance_x?: InputMaybe<Scalars['numeric']>;
  balance_y?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  bs_vol?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  conversion_ltv?: InputMaybe<Scalars['numeric']>;
  est_collateral_price?: InputMaybe<Scalars['numeric']>;
  est_collateral_price_per_key_token?: InputMaybe<Scalars['numeric']>;
  est_fwp_collateral_price?: InputMaybe<Scalars['numeric']>;
  est_token_price_per_key_token?: InputMaybe<Scalars['numeric']>;
  est_total_pool_value?: InputMaybe<Scalars['numeric']>;
  expiry?: InputMaybe<Scalars['numeric']>;
  fee_rate_x?: InputMaybe<Scalars['numeric']>;
  fee_rate_y?: InputMaybe<Scalars['numeric']>;
  fee_rebate?: InputMaybe<Scalars['numeric']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  final_collateral_per_share?: InputMaybe<Scalars['numeric']>;
  final_token_per_share?: InputMaybe<Scalars['numeric']>;
  key_supply?: InputMaybe<Scalars['numeric']>;
  key_token?: InputMaybe<Scalars['String']>;
  ltv_0?: InputMaybe<Scalars['numeric']>;
  moving_average?: InputMaybe<Scalars['numeric']>;
  strike?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_to_maturity?: InputMaybe<Scalars['numeric']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  weight_x?: InputMaybe<Scalars['numeric']>;
  weight_y?: InputMaybe<Scalars['numeric']>;
  yield_supply?: InputMaybe<Scalars['numeric']>;
  yield_token?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type LaplaceLatestCollateralRebalancingPoolMaxFields = {
  __typename?: 'laplace_latest_collateral_rebalancing_pool_max_fields';
  balance_x?: Maybe<Scalars['numeric']>;
  balance_y?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['numeric']>;
  bs_vol?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  conversion_ltv?: Maybe<Scalars['numeric']>;
  est_collateral_price?: Maybe<Scalars['numeric']>;
  est_collateral_price_per_key_token?: Maybe<Scalars['numeric']>;
  est_fwp_collateral_price?: Maybe<Scalars['numeric']>;
  est_token_price_per_key_token?: Maybe<Scalars['numeric']>;
  est_total_pool_value?: Maybe<Scalars['numeric']>;
  expiry?: Maybe<Scalars['numeric']>;
  fee_rate_x?: Maybe<Scalars['numeric']>;
  fee_rate_y?: Maybe<Scalars['numeric']>;
  fee_rebate?: Maybe<Scalars['numeric']>;
  fee_to_address?: Maybe<Scalars['String']>;
  final_collateral_per_share?: Maybe<Scalars['numeric']>;
  final_token_per_share?: Maybe<Scalars['numeric']>;
  key_supply?: Maybe<Scalars['numeric']>;
  key_token?: Maybe<Scalars['String']>;
  ltv_0?: Maybe<Scalars['numeric']>;
  moving_average?: Maybe<Scalars['numeric']>;
  strike?: Maybe<Scalars['numeric']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_to_maturity?: Maybe<Scalars['numeric']>;
  token_x?: Maybe<Scalars['String']>;
  token_y?: Maybe<Scalars['String']>;
  weight_x?: Maybe<Scalars['numeric']>;
  weight_y?: Maybe<Scalars['numeric']>;
  yield_supply?: Maybe<Scalars['numeric']>;
  yield_token?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LaplaceLatestCollateralRebalancingPoolMinFields = {
  __typename?: 'laplace_latest_collateral_rebalancing_pool_min_fields';
  balance_x?: Maybe<Scalars['numeric']>;
  balance_y?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['numeric']>;
  bs_vol?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  conversion_ltv?: Maybe<Scalars['numeric']>;
  est_collateral_price?: Maybe<Scalars['numeric']>;
  est_collateral_price_per_key_token?: Maybe<Scalars['numeric']>;
  est_fwp_collateral_price?: Maybe<Scalars['numeric']>;
  est_token_price_per_key_token?: Maybe<Scalars['numeric']>;
  est_total_pool_value?: Maybe<Scalars['numeric']>;
  expiry?: Maybe<Scalars['numeric']>;
  fee_rate_x?: Maybe<Scalars['numeric']>;
  fee_rate_y?: Maybe<Scalars['numeric']>;
  fee_rebate?: Maybe<Scalars['numeric']>;
  fee_to_address?: Maybe<Scalars['String']>;
  final_collateral_per_share?: Maybe<Scalars['numeric']>;
  final_token_per_share?: Maybe<Scalars['numeric']>;
  key_supply?: Maybe<Scalars['numeric']>;
  key_token?: Maybe<Scalars['String']>;
  ltv_0?: Maybe<Scalars['numeric']>;
  moving_average?: Maybe<Scalars['numeric']>;
  strike?: Maybe<Scalars['numeric']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_to_maturity?: Maybe<Scalars['numeric']>;
  token_x?: Maybe<Scalars['String']>;
  token_y?: Maybe<Scalars['String']>;
  weight_x?: Maybe<Scalars['numeric']>;
  weight_y?: Maybe<Scalars['numeric']>;
  yield_supply?: Maybe<Scalars['numeric']>;
  yield_token?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "laplace.latest_collateral_rebalancing_pool" */
export type LaplaceLatestCollateralRebalancingPoolMutationResponse = {
  __typename?: 'laplace_latest_collateral_rebalancing_pool_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceLatestCollateralRebalancingPool>;
};

/** on_conflict condition type for table "laplace.latest_collateral_rebalancing_pool" */
export type LaplaceLatestCollateralRebalancingPoolOnConflict = {
  constraint: LaplaceLatestCollateralRebalancingPoolConstraint;
  update_columns?: Array<LaplaceLatestCollateralRebalancingPoolUpdateColumn>;
  where?: InputMaybe<LaplaceLatestCollateralRebalancingPoolBoolExp>;
};

/** Ordering options when selecting data from "laplace.latest_collateral_rebalancing_pool". */
export type LaplaceLatestCollateralRebalancingPoolOrderBy = {
  balance_x?: InputMaybe<OrderBy>;
  balance_y?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  bs_vol?: InputMaybe<OrderBy>;
  burn_block_time?: InputMaybe<OrderBy>;
  conversion_ltv?: InputMaybe<OrderBy>;
  est_collateral_price?: InputMaybe<OrderBy>;
  est_collateral_price_per_key_token?: InputMaybe<OrderBy>;
  est_fwp_collateral_price?: InputMaybe<OrderBy>;
  est_token_price_per_key_token?: InputMaybe<OrderBy>;
  est_total_pool_value?: InputMaybe<OrderBy>;
  expiry?: InputMaybe<OrderBy>;
  fee_rate_x?: InputMaybe<OrderBy>;
  fee_rate_y?: InputMaybe<OrderBy>;
  fee_rebate?: InputMaybe<OrderBy>;
  fee_to_address?: InputMaybe<OrderBy>;
  final_collateral_per_share?: InputMaybe<OrderBy>;
  final_token_per_share?: InputMaybe<OrderBy>;
  key_supply?: InputMaybe<OrderBy>;
  key_token?: InputMaybe<OrderBy>;
  ltv_0?: InputMaybe<OrderBy>;
  moving_average?: InputMaybe<OrderBy>;
  strike?: InputMaybe<OrderBy>;
  sync_at?: InputMaybe<OrderBy>;
  token_to_maturity?: InputMaybe<OrderBy>;
  token_x?: InputMaybe<OrderBy>;
  token_y?: InputMaybe<OrderBy>;
  weight_x?: InputMaybe<OrderBy>;
  weight_y?: InputMaybe<OrderBy>;
  yield_supply?: InputMaybe<OrderBy>;
  yield_token?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.latest_collateral_rebalancing_pool */
export type LaplaceLatestCollateralRebalancingPoolPkColumnsInput = {
  expiry: Scalars['numeric'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};

/** select columns of table "laplace.latest_collateral_rebalancing_pool" */
export enum LaplaceLatestCollateralRebalancingPoolSelectColumn {
  /** column name */
  BalanceX = 'balance_x',
  /** column name */
  BalanceY = 'balance_y',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BsVol = 'bs_vol',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  ConversionLtv = 'conversion_ltv',
  /** column name */
  EstCollateralPrice = 'est_collateral_price',
  /** column name */
  EstCollateralPricePerKeyToken = 'est_collateral_price_per_key_token',
  /** column name */
  EstFwpCollateralPrice = 'est_fwp_collateral_price',
  /** column name */
  EstTokenPricePerKeyToken = 'est_token_price_per_key_token',
  /** column name */
  EstTotalPoolValue = 'est_total_pool_value',
  /** column name */
  Expiry = 'expiry',
  /** column name */
  FeeRateX = 'fee_rate_x',
  /** column name */
  FeeRateY = 'fee_rate_y',
  /** column name */
  FeeRebate = 'fee_rebate',
  /** column name */
  FeeToAddress = 'fee_to_address',
  /** column name */
  FinalCollateralPerShare = 'final_collateral_per_share',
  /** column name */
  FinalTokenPerShare = 'final_token_per_share',
  /** column name */
  KeySupply = 'key_supply',
  /** column name */
  KeyToken = 'key_token',
  /** column name */
  Ltv_0 = 'ltv_0',
  /** column name */
  MovingAverage = 'moving_average',
  /** column name */
  Strike = 'strike',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenToMaturity = 'token_to_maturity',
  /** column name */
  TokenX = 'token_x',
  /** column name */
  TokenY = 'token_y',
  /** column name */
  WeightX = 'weight_x',
  /** column name */
  WeightY = 'weight_y',
  /** column name */
  YieldSupply = 'yield_supply',
  /** column name */
  YieldToken = 'yield_token'
}

/** input type for updating data in table "laplace.latest_collateral_rebalancing_pool" */
export type LaplaceLatestCollateralRebalancingPoolSetInput = {
  balance_x?: InputMaybe<Scalars['numeric']>;
  balance_y?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  bs_vol?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  conversion_ltv?: InputMaybe<Scalars['numeric']>;
  est_collateral_price?: InputMaybe<Scalars['numeric']>;
  est_collateral_price_per_key_token?: InputMaybe<Scalars['numeric']>;
  est_fwp_collateral_price?: InputMaybe<Scalars['numeric']>;
  est_token_price_per_key_token?: InputMaybe<Scalars['numeric']>;
  est_total_pool_value?: InputMaybe<Scalars['numeric']>;
  expiry?: InputMaybe<Scalars['numeric']>;
  fee_rate_x?: InputMaybe<Scalars['numeric']>;
  fee_rate_y?: InputMaybe<Scalars['numeric']>;
  fee_rebate?: InputMaybe<Scalars['numeric']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  final_collateral_per_share?: InputMaybe<Scalars['numeric']>;
  final_token_per_share?: InputMaybe<Scalars['numeric']>;
  key_supply?: InputMaybe<Scalars['numeric']>;
  key_token?: InputMaybe<Scalars['String']>;
  ltv_0?: InputMaybe<Scalars['numeric']>;
  moving_average?: InputMaybe<Scalars['numeric']>;
  strike?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_to_maturity?: InputMaybe<Scalars['numeric']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  weight_x?: InputMaybe<Scalars['numeric']>;
  weight_y?: InputMaybe<Scalars['numeric']>;
  yield_supply?: InputMaybe<Scalars['numeric']>;
  yield_token?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type LaplaceLatestCollateralRebalancingPoolStddevFields = {
  __typename?: 'laplace_latest_collateral_rebalancing_pool_stddev_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  bs_vol?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  conversion_ltv?: Maybe<Scalars['Float']>;
  est_collateral_price?: Maybe<Scalars['Float']>;
  est_collateral_price_per_key_token?: Maybe<Scalars['Float']>;
  est_fwp_collateral_price?: Maybe<Scalars['Float']>;
  est_token_price_per_key_token?: Maybe<Scalars['Float']>;
  est_total_pool_value?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  final_collateral_per_share?: Maybe<Scalars['Float']>;
  final_token_per_share?: Maybe<Scalars['Float']>;
  key_supply?: Maybe<Scalars['Float']>;
  ltv_0?: Maybe<Scalars['Float']>;
  moving_average?: Maybe<Scalars['Float']>;
  strike?: Maybe<Scalars['Float']>;
  token_to_maturity?: Maybe<Scalars['Float']>;
  weight_x?: Maybe<Scalars['Float']>;
  weight_y?: Maybe<Scalars['Float']>;
  yield_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceLatestCollateralRebalancingPoolStddevPopFields = {
  __typename?: 'laplace_latest_collateral_rebalancing_pool_stddev_pop_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  bs_vol?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  conversion_ltv?: Maybe<Scalars['Float']>;
  est_collateral_price?: Maybe<Scalars['Float']>;
  est_collateral_price_per_key_token?: Maybe<Scalars['Float']>;
  est_fwp_collateral_price?: Maybe<Scalars['Float']>;
  est_token_price_per_key_token?: Maybe<Scalars['Float']>;
  est_total_pool_value?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  final_collateral_per_share?: Maybe<Scalars['Float']>;
  final_token_per_share?: Maybe<Scalars['Float']>;
  key_supply?: Maybe<Scalars['Float']>;
  ltv_0?: Maybe<Scalars['Float']>;
  moving_average?: Maybe<Scalars['Float']>;
  strike?: Maybe<Scalars['Float']>;
  token_to_maturity?: Maybe<Scalars['Float']>;
  weight_x?: Maybe<Scalars['Float']>;
  weight_y?: Maybe<Scalars['Float']>;
  yield_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceLatestCollateralRebalancingPoolStddevSampFields = {
  __typename?: 'laplace_latest_collateral_rebalancing_pool_stddev_samp_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  bs_vol?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  conversion_ltv?: Maybe<Scalars['Float']>;
  est_collateral_price?: Maybe<Scalars['Float']>;
  est_collateral_price_per_key_token?: Maybe<Scalars['Float']>;
  est_fwp_collateral_price?: Maybe<Scalars['Float']>;
  est_token_price_per_key_token?: Maybe<Scalars['Float']>;
  est_total_pool_value?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  final_collateral_per_share?: Maybe<Scalars['Float']>;
  final_token_per_share?: Maybe<Scalars['Float']>;
  key_supply?: Maybe<Scalars['Float']>;
  ltv_0?: Maybe<Scalars['Float']>;
  moving_average?: Maybe<Scalars['Float']>;
  strike?: Maybe<Scalars['Float']>;
  token_to_maturity?: Maybe<Scalars['Float']>;
  weight_x?: Maybe<Scalars['Float']>;
  weight_y?: Maybe<Scalars['Float']>;
  yield_supply?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_latest_collateral_rebalancing_pool" */
export type LaplaceLatestCollateralRebalancingPoolStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceLatestCollateralRebalancingPoolStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceLatestCollateralRebalancingPoolStreamCursorValueInput = {
  balance_x?: InputMaybe<Scalars['numeric']>;
  balance_y?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  bs_vol?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  conversion_ltv?: InputMaybe<Scalars['numeric']>;
  est_collateral_price?: InputMaybe<Scalars['numeric']>;
  est_collateral_price_per_key_token?: InputMaybe<Scalars['numeric']>;
  est_fwp_collateral_price?: InputMaybe<Scalars['numeric']>;
  est_token_price_per_key_token?: InputMaybe<Scalars['numeric']>;
  est_total_pool_value?: InputMaybe<Scalars['numeric']>;
  expiry?: InputMaybe<Scalars['numeric']>;
  fee_rate_x?: InputMaybe<Scalars['numeric']>;
  fee_rate_y?: InputMaybe<Scalars['numeric']>;
  fee_rebate?: InputMaybe<Scalars['numeric']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  final_collateral_per_share?: InputMaybe<Scalars['numeric']>;
  final_token_per_share?: InputMaybe<Scalars['numeric']>;
  key_supply?: InputMaybe<Scalars['numeric']>;
  key_token?: InputMaybe<Scalars['String']>;
  ltv_0?: InputMaybe<Scalars['numeric']>;
  moving_average?: InputMaybe<Scalars['numeric']>;
  strike?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_to_maturity?: InputMaybe<Scalars['numeric']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  weight_x?: InputMaybe<Scalars['numeric']>;
  weight_y?: InputMaybe<Scalars['numeric']>;
  yield_supply?: InputMaybe<Scalars['numeric']>;
  yield_token?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type LaplaceLatestCollateralRebalancingPoolSumFields = {
  __typename?: 'laplace_latest_collateral_rebalancing_pool_sum_fields';
  balance_x?: Maybe<Scalars['numeric']>;
  balance_y?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['numeric']>;
  bs_vol?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  conversion_ltv?: Maybe<Scalars['numeric']>;
  est_collateral_price?: Maybe<Scalars['numeric']>;
  est_collateral_price_per_key_token?: Maybe<Scalars['numeric']>;
  est_fwp_collateral_price?: Maybe<Scalars['numeric']>;
  est_token_price_per_key_token?: Maybe<Scalars['numeric']>;
  est_total_pool_value?: Maybe<Scalars['numeric']>;
  expiry?: Maybe<Scalars['numeric']>;
  fee_rate_x?: Maybe<Scalars['numeric']>;
  fee_rate_y?: Maybe<Scalars['numeric']>;
  fee_rebate?: Maybe<Scalars['numeric']>;
  final_collateral_per_share?: Maybe<Scalars['numeric']>;
  final_token_per_share?: Maybe<Scalars['numeric']>;
  key_supply?: Maybe<Scalars['numeric']>;
  ltv_0?: Maybe<Scalars['numeric']>;
  moving_average?: Maybe<Scalars['numeric']>;
  strike?: Maybe<Scalars['numeric']>;
  token_to_maturity?: Maybe<Scalars['numeric']>;
  weight_x?: Maybe<Scalars['numeric']>;
  weight_y?: Maybe<Scalars['numeric']>;
  yield_supply?: Maybe<Scalars['numeric']>;
};

/** update columns of table "laplace.latest_collateral_rebalancing_pool" */
export enum LaplaceLatestCollateralRebalancingPoolUpdateColumn {
  /** column name */
  BalanceX = 'balance_x',
  /** column name */
  BalanceY = 'balance_y',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BsVol = 'bs_vol',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  ConversionLtv = 'conversion_ltv',
  /** column name */
  EstCollateralPrice = 'est_collateral_price',
  /** column name */
  EstCollateralPricePerKeyToken = 'est_collateral_price_per_key_token',
  /** column name */
  EstFwpCollateralPrice = 'est_fwp_collateral_price',
  /** column name */
  EstTokenPricePerKeyToken = 'est_token_price_per_key_token',
  /** column name */
  EstTotalPoolValue = 'est_total_pool_value',
  /** column name */
  Expiry = 'expiry',
  /** column name */
  FeeRateX = 'fee_rate_x',
  /** column name */
  FeeRateY = 'fee_rate_y',
  /** column name */
  FeeRebate = 'fee_rebate',
  /** column name */
  FeeToAddress = 'fee_to_address',
  /** column name */
  FinalCollateralPerShare = 'final_collateral_per_share',
  /** column name */
  FinalTokenPerShare = 'final_token_per_share',
  /** column name */
  KeySupply = 'key_supply',
  /** column name */
  KeyToken = 'key_token',
  /** column name */
  Ltv_0 = 'ltv_0',
  /** column name */
  MovingAverage = 'moving_average',
  /** column name */
  Strike = 'strike',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenToMaturity = 'token_to_maturity',
  /** column name */
  TokenX = 'token_x',
  /** column name */
  TokenY = 'token_y',
  /** column name */
  WeightX = 'weight_x',
  /** column name */
  WeightY = 'weight_y',
  /** column name */
  YieldSupply = 'yield_supply',
  /** column name */
  YieldToken = 'yield_token'
}

export type LaplaceLatestCollateralRebalancingPoolUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceLatestCollateralRebalancingPoolIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceLatestCollateralRebalancingPoolSetInput>;
  where: LaplaceLatestCollateralRebalancingPoolBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceLatestCollateralRebalancingPoolVarPopFields = {
  __typename?: 'laplace_latest_collateral_rebalancing_pool_var_pop_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  bs_vol?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  conversion_ltv?: Maybe<Scalars['Float']>;
  est_collateral_price?: Maybe<Scalars['Float']>;
  est_collateral_price_per_key_token?: Maybe<Scalars['Float']>;
  est_fwp_collateral_price?: Maybe<Scalars['Float']>;
  est_token_price_per_key_token?: Maybe<Scalars['Float']>;
  est_total_pool_value?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  final_collateral_per_share?: Maybe<Scalars['Float']>;
  final_token_per_share?: Maybe<Scalars['Float']>;
  key_supply?: Maybe<Scalars['Float']>;
  ltv_0?: Maybe<Scalars['Float']>;
  moving_average?: Maybe<Scalars['Float']>;
  strike?: Maybe<Scalars['Float']>;
  token_to_maturity?: Maybe<Scalars['Float']>;
  weight_x?: Maybe<Scalars['Float']>;
  weight_y?: Maybe<Scalars['Float']>;
  yield_supply?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceLatestCollateralRebalancingPoolVarSampFields = {
  __typename?: 'laplace_latest_collateral_rebalancing_pool_var_samp_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  bs_vol?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  conversion_ltv?: Maybe<Scalars['Float']>;
  est_collateral_price?: Maybe<Scalars['Float']>;
  est_collateral_price_per_key_token?: Maybe<Scalars['Float']>;
  est_fwp_collateral_price?: Maybe<Scalars['Float']>;
  est_token_price_per_key_token?: Maybe<Scalars['Float']>;
  est_total_pool_value?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  final_collateral_per_share?: Maybe<Scalars['Float']>;
  final_token_per_share?: Maybe<Scalars['Float']>;
  key_supply?: Maybe<Scalars['Float']>;
  ltv_0?: Maybe<Scalars['Float']>;
  moving_average?: Maybe<Scalars['Float']>;
  strike?: Maybe<Scalars['Float']>;
  token_to_maturity?: Maybe<Scalars['Float']>;
  weight_x?: Maybe<Scalars['Float']>;
  weight_y?: Maybe<Scalars['Float']>;
  yield_supply?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceLatestCollateralRebalancingPoolVarianceFields = {
  __typename?: 'laplace_latest_collateral_rebalancing_pool_variance_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  bs_vol?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  conversion_ltv?: Maybe<Scalars['Float']>;
  est_collateral_price?: Maybe<Scalars['Float']>;
  est_collateral_price_per_key_token?: Maybe<Scalars['Float']>;
  est_fwp_collateral_price?: Maybe<Scalars['Float']>;
  est_token_price_per_key_token?: Maybe<Scalars['Float']>;
  est_total_pool_value?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  final_collateral_per_share?: Maybe<Scalars['Float']>;
  final_token_per_share?: Maybe<Scalars['Float']>;
  key_supply?: Maybe<Scalars['Float']>;
  ltv_0?: Maybe<Scalars['Float']>;
  moving_average?: Maybe<Scalars['Float']>;
  strike?: Maybe<Scalars['Float']>;
  token_to_maturity?: Maybe<Scalars['Float']>;
  weight_x?: Maybe<Scalars['Float']>;
  weight_y?: Maybe<Scalars['Float']>;
  yield_supply?: Maybe<Scalars['Float']>;
};

/** Contract fixed_weight_pool_v1_01 latest-block data */
export type LaplaceLatestFixedWeightPoolV1_01 = {
  __typename?: 'laplace_latest_fixed_weight_pool_v1_01';
  balance_x: Scalars['bigint'];
  balance_y: Scalars['bigint'];
  block_height: Scalars['Int'];
  burn_block_time: Scalars['Int'];
  est_pool_token_price: Scalars['bigint'];
  est_token_y_price: Scalars['bigint'];
  fee_rate_x: Scalars['bigint'];
  fee_rate_y: Scalars['bigint'];
  fee_rebate: Scalars['bigint'];
  fee_to_address: Scalars['String'];
  latest_oracle_resilient: Scalars['bigint'];
  oracle_average: Scalars['bigint'];
  oracle_enabled: Scalars['Boolean'];
  oracle_instant: Scalars['bigint'];
  oracle_resilient: Scalars['bigint'];
  pool_token: Scalars['String'];
  sync_at: Scalars['timestamptz'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
  total_supply: Scalars['bigint'];
  weight_x: Scalars['bigint'];
  weight_y: Scalars['bigint'];
};

/** aggregated selection of "laplace.latest_fixed_weight_pool_v1_01" */
export type LaplaceLatestFixedWeightPoolV1_01Aggregate = {
  __typename?: 'laplace_latest_fixed_weight_pool_v1_01_aggregate';
  aggregate?: Maybe<LaplaceLatestFixedWeightPoolV1_01AggregateFields>;
  nodes: Array<LaplaceLatestFixedWeightPoolV1_01>;
};

/** aggregate fields of "laplace.latest_fixed_weight_pool_v1_01" */
export type LaplaceLatestFixedWeightPoolV1_01AggregateFields = {
  __typename?: 'laplace_latest_fixed_weight_pool_v1_01_aggregate_fields';
  avg?: Maybe<LaplaceLatestFixedWeightPoolV1_01AvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceLatestFixedWeightPoolV1_01MaxFields>;
  min?: Maybe<LaplaceLatestFixedWeightPoolV1_01MinFields>;
  stddev?: Maybe<LaplaceLatestFixedWeightPoolV1_01StddevFields>;
  stddev_pop?: Maybe<LaplaceLatestFixedWeightPoolV1_01StddevPopFields>;
  stddev_samp?: Maybe<LaplaceLatestFixedWeightPoolV1_01StddevSampFields>;
  sum?: Maybe<LaplaceLatestFixedWeightPoolV1_01SumFields>;
  var_pop?: Maybe<LaplaceLatestFixedWeightPoolV1_01VarPopFields>;
  var_samp?: Maybe<LaplaceLatestFixedWeightPoolV1_01VarSampFields>;
  variance?: Maybe<LaplaceLatestFixedWeightPoolV1_01VarianceFields>;
};


/** aggregate fields of "laplace.latest_fixed_weight_pool_v1_01" */
export type LaplaceLatestFixedWeightPoolV1_01AggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceLatestFixedWeightPoolV1_01SelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LaplaceLatestFixedWeightPoolV1_01AvgFields = {
  __typename?: 'laplace_latest_fixed_weight_pool_v1_01_avg_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  weight_x?: Maybe<Scalars['Float']>;
  weight_y?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.latest_fixed_weight_pool_v1_01". All fields are combined with a logical 'AND'. */
export type LaplaceLatestFixedWeightPoolV1_01BoolExp = {
  _and?: InputMaybe<Array<LaplaceLatestFixedWeightPoolV1_01BoolExp>>;
  _not?: InputMaybe<LaplaceLatestFixedWeightPoolV1_01BoolExp>;
  _or?: InputMaybe<Array<LaplaceLatestFixedWeightPoolV1_01BoolExp>>;
  balance_x?: InputMaybe<BigintComparisonExp>;
  balance_y?: InputMaybe<BigintComparisonExp>;
  block_height?: InputMaybe<IntComparisonExp>;
  burn_block_time?: InputMaybe<IntComparisonExp>;
  est_pool_token_price?: InputMaybe<BigintComparisonExp>;
  est_token_y_price?: InputMaybe<BigintComparisonExp>;
  fee_rate_x?: InputMaybe<BigintComparisonExp>;
  fee_rate_y?: InputMaybe<BigintComparisonExp>;
  fee_rebate?: InputMaybe<BigintComparisonExp>;
  fee_to_address?: InputMaybe<StringComparisonExp>;
  latest_oracle_resilient?: InputMaybe<BigintComparisonExp>;
  oracle_average?: InputMaybe<BigintComparisonExp>;
  oracle_enabled?: InputMaybe<BooleanComparisonExp>;
  oracle_instant?: InputMaybe<BigintComparisonExp>;
  oracle_resilient?: InputMaybe<BigintComparisonExp>;
  pool_token?: InputMaybe<StringComparisonExp>;
  sync_at?: InputMaybe<TimestamptzComparisonExp>;
  token_x?: InputMaybe<StringComparisonExp>;
  token_y?: InputMaybe<StringComparisonExp>;
  total_supply?: InputMaybe<BigintComparisonExp>;
  weight_x?: InputMaybe<BigintComparisonExp>;
  weight_y?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "laplace.latest_fixed_weight_pool_v1_01" */
export enum LaplaceLatestFixedWeightPoolV1_01Constraint {
  /** unique or primary key constraint on columns "weight_x", "token_y", "token_x", "weight_y" */
  LatestFixedWeightPoolV1_01Pkey = 'latest_fixed_weight_pool_v1_01_pkey'
}

/** input type for incrementing numeric columns in table "laplace.latest_fixed_weight_pool_v1_01" */
export type LaplaceLatestFixedWeightPoolV1_01IncInput = {
  balance_x?: InputMaybe<Scalars['bigint']>;
  balance_y?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  est_pool_token_price?: InputMaybe<Scalars['bigint']>;
  est_token_y_price?: InputMaybe<Scalars['bigint']>;
  fee_rate_x?: InputMaybe<Scalars['bigint']>;
  fee_rate_y?: InputMaybe<Scalars['bigint']>;
  fee_rebate?: InputMaybe<Scalars['bigint']>;
  latest_oracle_resilient?: InputMaybe<Scalars['bigint']>;
  oracle_average?: InputMaybe<Scalars['bigint']>;
  oracle_instant?: InputMaybe<Scalars['bigint']>;
  oracle_resilient?: InputMaybe<Scalars['bigint']>;
  total_supply?: InputMaybe<Scalars['bigint']>;
  weight_x?: InputMaybe<Scalars['bigint']>;
  weight_y?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "laplace.latest_fixed_weight_pool_v1_01" */
export type LaplaceLatestFixedWeightPoolV1_01InsertInput = {
  balance_x?: InputMaybe<Scalars['bigint']>;
  balance_y?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  est_pool_token_price?: InputMaybe<Scalars['bigint']>;
  est_token_y_price?: InputMaybe<Scalars['bigint']>;
  fee_rate_x?: InputMaybe<Scalars['bigint']>;
  fee_rate_y?: InputMaybe<Scalars['bigint']>;
  fee_rebate?: InputMaybe<Scalars['bigint']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  latest_oracle_resilient?: InputMaybe<Scalars['bigint']>;
  oracle_average?: InputMaybe<Scalars['bigint']>;
  oracle_enabled?: InputMaybe<Scalars['Boolean']>;
  oracle_instant?: InputMaybe<Scalars['bigint']>;
  oracle_resilient?: InputMaybe<Scalars['bigint']>;
  pool_token?: InputMaybe<Scalars['String']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  total_supply?: InputMaybe<Scalars['bigint']>;
  weight_x?: InputMaybe<Scalars['bigint']>;
  weight_y?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type LaplaceLatestFixedWeightPoolV1_01MaxFields = {
  __typename?: 'laplace_latest_fixed_weight_pool_v1_01_max_fields';
  balance_x?: Maybe<Scalars['bigint']>;
  balance_y?: Maybe<Scalars['bigint']>;
  block_height?: Maybe<Scalars['Int']>;
  burn_block_time?: Maybe<Scalars['Int']>;
  est_pool_token_price?: Maybe<Scalars['bigint']>;
  est_token_y_price?: Maybe<Scalars['bigint']>;
  fee_rate_x?: Maybe<Scalars['bigint']>;
  fee_rate_y?: Maybe<Scalars['bigint']>;
  fee_rebate?: Maybe<Scalars['bigint']>;
  fee_to_address?: Maybe<Scalars['String']>;
  latest_oracle_resilient?: Maybe<Scalars['bigint']>;
  oracle_average?: Maybe<Scalars['bigint']>;
  oracle_instant?: Maybe<Scalars['bigint']>;
  oracle_resilient?: Maybe<Scalars['bigint']>;
  pool_token?: Maybe<Scalars['String']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_x?: Maybe<Scalars['String']>;
  token_y?: Maybe<Scalars['String']>;
  total_supply?: Maybe<Scalars['bigint']>;
  weight_x?: Maybe<Scalars['bigint']>;
  weight_y?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type LaplaceLatestFixedWeightPoolV1_01MinFields = {
  __typename?: 'laplace_latest_fixed_weight_pool_v1_01_min_fields';
  balance_x?: Maybe<Scalars['bigint']>;
  balance_y?: Maybe<Scalars['bigint']>;
  block_height?: Maybe<Scalars['Int']>;
  burn_block_time?: Maybe<Scalars['Int']>;
  est_pool_token_price?: Maybe<Scalars['bigint']>;
  est_token_y_price?: Maybe<Scalars['bigint']>;
  fee_rate_x?: Maybe<Scalars['bigint']>;
  fee_rate_y?: Maybe<Scalars['bigint']>;
  fee_rebate?: Maybe<Scalars['bigint']>;
  fee_to_address?: Maybe<Scalars['String']>;
  latest_oracle_resilient?: Maybe<Scalars['bigint']>;
  oracle_average?: Maybe<Scalars['bigint']>;
  oracle_instant?: Maybe<Scalars['bigint']>;
  oracle_resilient?: Maybe<Scalars['bigint']>;
  pool_token?: Maybe<Scalars['String']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_x?: Maybe<Scalars['String']>;
  token_y?: Maybe<Scalars['String']>;
  total_supply?: Maybe<Scalars['bigint']>;
  weight_x?: Maybe<Scalars['bigint']>;
  weight_y?: Maybe<Scalars['bigint']>;
};

/** response of any mutation on the table "laplace.latest_fixed_weight_pool_v1_01" */
export type LaplaceLatestFixedWeightPoolV1_01MutationResponse = {
  __typename?: 'laplace_latest_fixed_weight_pool_v1_01_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceLatestFixedWeightPoolV1_01>;
};

/** on_conflict condition type for table "laplace.latest_fixed_weight_pool_v1_01" */
export type LaplaceLatestFixedWeightPoolV1_01OnConflict = {
  constraint: LaplaceLatestFixedWeightPoolV1_01Constraint;
  update_columns?: Array<LaplaceLatestFixedWeightPoolV1_01UpdateColumn>;
  where?: InputMaybe<LaplaceLatestFixedWeightPoolV1_01BoolExp>;
};

/** Ordering options when selecting data from "laplace.latest_fixed_weight_pool_v1_01". */
export type LaplaceLatestFixedWeightPoolV1_01OrderBy = {
  balance_x?: InputMaybe<OrderBy>;
  balance_y?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  burn_block_time?: InputMaybe<OrderBy>;
  est_pool_token_price?: InputMaybe<OrderBy>;
  est_token_y_price?: InputMaybe<OrderBy>;
  fee_rate_x?: InputMaybe<OrderBy>;
  fee_rate_y?: InputMaybe<OrderBy>;
  fee_rebate?: InputMaybe<OrderBy>;
  fee_to_address?: InputMaybe<OrderBy>;
  latest_oracle_resilient?: InputMaybe<OrderBy>;
  oracle_average?: InputMaybe<OrderBy>;
  oracle_enabled?: InputMaybe<OrderBy>;
  oracle_instant?: InputMaybe<OrderBy>;
  oracle_resilient?: InputMaybe<OrderBy>;
  pool_token?: InputMaybe<OrderBy>;
  sync_at?: InputMaybe<OrderBy>;
  token_x?: InputMaybe<OrderBy>;
  token_y?: InputMaybe<OrderBy>;
  total_supply?: InputMaybe<OrderBy>;
  weight_x?: InputMaybe<OrderBy>;
  weight_y?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.latest_fixed_weight_pool_v1_01 */
export type LaplaceLatestFixedWeightPoolV1_01PkColumnsInput = {
  token_x: Scalars['String'];
  token_y: Scalars['String'];
  weight_x: Scalars['bigint'];
  weight_y: Scalars['bigint'];
};

/** select columns of table "laplace.latest_fixed_weight_pool_v1_01" */
export enum LaplaceLatestFixedWeightPoolV1_01SelectColumn {
  /** column name */
  BalanceX = 'balance_x',
  /** column name */
  BalanceY = 'balance_y',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  EstPoolTokenPrice = 'est_pool_token_price',
  /** column name */
  EstTokenYPrice = 'est_token_y_price',
  /** column name */
  FeeRateX = 'fee_rate_x',
  /** column name */
  FeeRateY = 'fee_rate_y',
  /** column name */
  FeeRebate = 'fee_rebate',
  /** column name */
  FeeToAddress = 'fee_to_address',
  /** column name */
  LatestOracleResilient = 'latest_oracle_resilient',
  /** column name */
  OracleAverage = 'oracle_average',
  /** column name */
  OracleEnabled = 'oracle_enabled',
  /** column name */
  OracleInstant = 'oracle_instant',
  /** column name */
  OracleResilient = 'oracle_resilient',
  /** column name */
  PoolToken = 'pool_token',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenX = 'token_x',
  /** column name */
  TokenY = 'token_y',
  /** column name */
  TotalSupply = 'total_supply',
  /** column name */
  WeightX = 'weight_x',
  /** column name */
  WeightY = 'weight_y'
}

/** input type for updating data in table "laplace.latest_fixed_weight_pool_v1_01" */
export type LaplaceLatestFixedWeightPoolV1_01SetInput = {
  balance_x?: InputMaybe<Scalars['bigint']>;
  balance_y?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  est_pool_token_price?: InputMaybe<Scalars['bigint']>;
  est_token_y_price?: InputMaybe<Scalars['bigint']>;
  fee_rate_x?: InputMaybe<Scalars['bigint']>;
  fee_rate_y?: InputMaybe<Scalars['bigint']>;
  fee_rebate?: InputMaybe<Scalars['bigint']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  latest_oracle_resilient?: InputMaybe<Scalars['bigint']>;
  oracle_average?: InputMaybe<Scalars['bigint']>;
  oracle_enabled?: InputMaybe<Scalars['Boolean']>;
  oracle_instant?: InputMaybe<Scalars['bigint']>;
  oracle_resilient?: InputMaybe<Scalars['bigint']>;
  pool_token?: InputMaybe<Scalars['String']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  total_supply?: InputMaybe<Scalars['bigint']>;
  weight_x?: InputMaybe<Scalars['bigint']>;
  weight_y?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type LaplaceLatestFixedWeightPoolV1_01StddevFields = {
  __typename?: 'laplace_latest_fixed_weight_pool_v1_01_stddev_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  weight_x?: Maybe<Scalars['Float']>;
  weight_y?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceLatestFixedWeightPoolV1_01StddevPopFields = {
  __typename?: 'laplace_latest_fixed_weight_pool_v1_01_stddev_pop_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  weight_x?: Maybe<Scalars['Float']>;
  weight_y?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceLatestFixedWeightPoolV1_01StddevSampFields = {
  __typename?: 'laplace_latest_fixed_weight_pool_v1_01_stddev_samp_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  weight_x?: Maybe<Scalars['Float']>;
  weight_y?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_latest_fixed_weight_pool_v1_01" */
export type LaplaceLatestFixedWeightPoolV1_01StreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceLatestFixedWeightPoolV1_01StreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceLatestFixedWeightPoolV1_01StreamCursorValueInput = {
  balance_x?: InputMaybe<Scalars['bigint']>;
  balance_y?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  est_pool_token_price?: InputMaybe<Scalars['bigint']>;
  est_token_y_price?: InputMaybe<Scalars['bigint']>;
  fee_rate_x?: InputMaybe<Scalars['bigint']>;
  fee_rate_y?: InputMaybe<Scalars['bigint']>;
  fee_rebate?: InputMaybe<Scalars['bigint']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  latest_oracle_resilient?: InputMaybe<Scalars['bigint']>;
  oracle_average?: InputMaybe<Scalars['bigint']>;
  oracle_enabled?: InputMaybe<Scalars['Boolean']>;
  oracle_instant?: InputMaybe<Scalars['bigint']>;
  oracle_resilient?: InputMaybe<Scalars['bigint']>;
  pool_token?: InputMaybe<Scalars['String']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  total_supply?: InputMaybe<Scalars['bigint']>;
  weight_x?: InputMaybe<Scalars['bigint']>;
  weight_y?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type LaplaceLatestFixedWeightPoolV1_01SumFields = {
  __typename?: 'laplace_latest_fixed_weight_pool_v1_01_sum_fields';
  balance_x?: Maybe<Scalars['bigint']>;
  balance_y?: Maybe<Scalars['bigint']>;
  block_height?: Maybe<Scalars['Int']>;
  burn_block_time?: Maybe<Scalars['Int']>;
  est_pool_token_price?: Maybe<Scalars['bigint']>;
  est_token_y_price?: Maybe<Scalars['bigint']>;
  fee_rate_x?: Maybe<Scalars['bigint']>;
  fee_rate_y?: Maybe<Scalars['bigint']>;
  fee_rebate?: Maybe<Scalars['bigint']>;
  latest_oracle_resilient?: Maybe<Scalars['bigint']>;
  oracle_average?: Maybe<Scalars['bigint']>;
  oracle_instant?: Maybe<Scalars['bigint']>;
  oracle_resilient?: Maybe<Scalars['bigint']>;
  total_supply?: Maybe<Scalars['bigint']>;
  weight_x?: Maybe<Scalars['bigint']>;
  weight_y?: Maybe<Scalars['bigint']>;
};

/** update columns of table "laplace.latest_fixed_weight_pool_v1_01" */
export enum LaplaceLatestFixedWeightPoolV1_01UpdateColumn {
  /** column name */
  BalanceX = 'balance_x',
  /** column name */
  BalanceY = 'balance_y',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  EstPoolTokenPrice = 'est_pool_token_price',
  /** column name */
  EstTokenYPrice = 'est_token_y_price',
  /** column name */
  FeeRateX = 'fee_rate_x',
  /** column name */
  FeeRateY = 'fee_rate_y',
  /** column name */
  FeeRebate = 'fee_rebate',
  /** column name */
  FeeToAddress = 'fee_to_address',
  /** column name */
  LatestOracleResilient = 'latest_oracle_resilient',
  /** column name */
  OracleAverage = 'oracle_average',
  /** column name */
  OracleEnabled = 'oracle_enabled',
  /** column name */
  OracleInstant = 'oracle_instant',
  /** column name */
  OracleResilient = 'oracle_resilient',
  /** column name */
  PoolToken = 'pool_token',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenX = 'token_x',
  /** column name */
  TokenY = 'token_y',
  /** column name */
  TotalSupply = 'total_supply',
  /** column name */
  WeightX = 'weight_x',
  /** column name */
  WeightY = 'weight_y'
}

export type LaplaceLatestFixedWeightPoolV1_01Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceLatestFixedWeightPoolV1_01IncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceLatestFixedWeightPoolV1_01SetInput>;
  where: LaplaceLatestFixedWeightPoolV1_01BoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceLatestFixedWeightPoolV1_01VarPopFields = {
  __typename?: 'laplace_latest_fixed_weight_pool_v1_01_var_pop_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  weight_x?: Maybe<Scalars['Float']>;
  weight_y?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceLatestFixedWeightPoolV1_01VarSampFields = {
  __typename?: 'laplace_latest_fixed_weight_pool_v1_01_var_samp_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  weight_x?: Maybe<Scalars['Float']>;
  weight_y?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceLatestFixedWeightPoolV1_01VarianceFields = {
  __typename?: 'laplace_latest_fixed_weight_pool_v1_01_variance_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  weight_x?: Maybe<Scalars['Float']>;
  weight_y?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "laplace.latest_pool_stats" */
export type LaplaceLatestPoolStats = {
  __typename?: 'laplace_latest_pool_stats';
  apr_7d: Scalars['numeric'];
  balance_x: Scalars['numeric'];
  balance_y: Scalars['numeric'];
  block_height: Scalars['numeric'];
  burn_block_time: Scalars['numeric'];
  est_pool_token_price: Scalars['bigint'];
  est_token_y_price: Scalars['bigint'];
  fee_rate_x: Scalars['numeric'];
  fee_rate_y: Scalars['numeric'];
  fee_rebate: Scalars['numeric'];
  fee_rebate_7d: Scalars['numeric'];
  fee_rebate_24h: Scalars['numeric'];
  fee_rebate_x_7d: Scalars['numeric'];
  fee_rebate_x_24h: Scalars['numeric'];
  fee_rebate_y_7d: Scalars['numeric'];
  fee_rebate_y_24h: Scalars['numeric'];
  fee_to_address: Scalars['String'];
  latest_oracle_resilient: Scalars['bigint'];
  liquidity: Scalars['numeric'];
  oracle_average: Scalars['bigint'];
  oracle_enabled: Scalars['bigint'];
  oracle_instant: Scalars['bigint'];
  oracle_resilient: Scalars['bigint'];
  pool_token: Scalars['String'];
  sync_at: Scalars['timestamptz'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
  total_supply: Scalars['numeric'];
  volume_7d: Scalars['numeric'];
  volume_24h: Scalars['numeric'];
  volume_x_7d: Scalars['numeric'];
  volume_x_24h: Scalars['numeric'];
  volume_y_7d: Scalars['numeric'];
  volume_y_24h: Scalars['numeric'];
};

/** aggregated selection of "laplace.latest_pool_stats" */
export type LaplaceLatestPoolStatsAggregate = {
  __typename?: 'laplace_latest_pool_stats_aggregate';
  aggregate?: Maybe<LaplaceLatestPoolStatsAggregateFields>;
  nodes: Array<LaplaceLatestPoolStats>;
};

/** aggregate fields of "laplace.latest_pool_stats" */
export type LaplaceLatestPoolStatsAggregateFields = {
  __typename?: 'laplace_latest_pool_stats_aggregate_fields';
  avg?: Maybe<LaplaceLatestPoolStatsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceLatestPoolStatsMaxFields>;
  min?: Maybe<LaplaceLatestPoolStatsMinFields>;
  stddev?: Maybe<LaplaceLatestPoolStatsStddevFields>;
  stddev_pop?: Maybe<LaplaceLatestPoolStatsStddevPopFields>;
  stddev_samp?: Maybe<LaplaceLatestPoolStatsStddevSampFields>;
  sum?: Maybe<LaplaceLatestPoolStatsSumFields>;
  var_pop?: Maybe<LaplaceLatestPoolStatsVarPopFields>;
  var_samp?: Maybe<LaplaceLatestPoolStatsVarSampFields>;
  variance?: Maybe<LaplaceLatestPoolStatsVarianceFields>;
};


/** aggregate fields of "laplace.latest_pool_stats" */
export type LaplaceLatestPoolStatsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceLatestPoolStatsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LaplaceLatestPoolStatsAvgFields = {
  __typename?: 'laplace_latest_pool_stats_avg_fields';
  apr_7d?: Maybe<Scalars['Float']>;
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  fee_rebate_7d?: Maybe<Scalars['Float']>;
  fee_rebate_24h?: Maybe<Scalars['Float']>;
  fee_rebate_x_7d?: Maybe<Scalars['Float']>;
  fee_rebate_x_24h?: Maybe<Scalars['Float']>;
  fee_rebate_y_7d?: Maybe<Scalars['Float']>;
  fee_rebate_y_24h?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  liquidity?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_enabled?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  volume_7d?: Maybe<Scalars['Float']>;
  volume_24h?: Maybe<Scalars['Float']>;
  volume_x_7d?: Maybe<Scalars['Float']>;
  volume_x_24h?: Maybe<Scalars['Float']>;
  volume_y_7d?: Maybe<Scalars['Float']>;
  volume_y_24h?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.latest_pool_stats". All fields are combined with a logical 'AND'. */
export type LaplaceLatestPoolStatsBoolExp = {
  _and?: InputMaybe<Array<LaplaceLatestPoolStatsBoolExp>>;
  _not?: InputMaybe<LaplaceLatestPoolStatsBoolExp>;
  _or?: InputMaybe<Array<LaplaceLatestPoolStatsBoolExp>>;
  apr_7d?: InputMaybe<NumericComparisonExp>;
  balance_x?: InputMaybe<NumericComparisonExp>;
  balance_y?: InputMaybe<NumericComparisonExp>;
  block_height?: InputMaybe<NumericComparisonExp>;
  burn_block_time?: InputMaybe<NumericComparisonExp>;
  est_pool_token_price?: InputMaybe<BigintComparisonExp>;
  est_token_y_price?: InputMaybe<BigintComparisonExp>;
  fee_rate_x?: InputMaybe<NumericComparisonExp>;
  fee_rate_y?: InputMaybe<NumericComparisonExp>;
  fee_rebate?: InputMaybe<NumericComparisonExp>;
  fee_rebate_7d?: InputMaybe<NumericComparisonExp>;
  fee_rebate_24h?: InputMaybe<NumericComparisonExp>;
  fee_rebate_x_7d?: InputMaybe<NumericComparisonExp>;
  fee_rebate_x_24h?: InputMaybe<NumericComparisonExp>;
  fee_rebate_y_7d?: InputMaybe<NumericComparisonExp>;
  fee_rebate_y_24h?: InputMaybe<NumericComparisonExp>;
  fee_to_address?: InputMaybe<StringComparisonExp>;
  latest_oracle_resilient?: InputMaybe<BigintComparisonExp>;
  liquidity?: InputMaybe<NumericComparisonExp>;
  oracle_average?: InputMaybe<BigintComparisonExp>;
  oracle_enabled?: InputMaybe<BigintComparisonExp>;
  oracle_instant?: InputMaybe<BigintComparisonExp>;
  oracle_resilient?: InputMaybe<BigintComparisonExp>;
  pool_token?: InputMaybe<StringComparisonExp>;
  sync_at?: InputMaybe<TimestamptzComparisonExp>;
  token_x?: InputMaybe<StringComparisonExp>;
  token_y?: InputMaybe<StringComparisonExp>;
  total_supply?: InputMaybe<NumericComparisonExp>;
  volume_7d?: InputMaybe<NumericComparisonExp>;
  volume_24h?: InputMaybe<NumericComparisonExp>;
  volume_x_7d?: InputMaybe<NumericComparisonExp>;
  volume_x_24h?: InputMaybe<NumericComparisonExp>;
  volume_y_7d?: InputMaybe<NumericComparisonExp>;
  volume_y_24h?: InputMaybe<NumericComparisonExp>;
};

/** unique or primary key constraints on table "laplace.latest_pool_stats" */
export enum LaplaceLatestPoolStatsConstraint {
  /** unique or primary key constraint on columns "pool_token" */
  LatestPoolStatsPkey = 'latest_pool_stats_pkey'
}

/** input type for incrementing numeric columns in table "laplace.latest_pool_stats" */
export type LaplaceLatestPoolStatsIncInput = {
  apr_7d?: InputMaybe<Scalars['numeric']>;
  balance_x?: InputMaybe<Scalars['numeric']>;
  balance_y?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  est_pool_token_price?: InputMaybe<Scalars['bigint']>;
  est_token_y_price?: InputMaybe<Scalars['bigint']>;
  fee_rate_x?: InputMaybe<Scalars['numeric']>;
  fee_rate_y?: InputMaybe<Scalars['numeric']>;
  fee_rebate?: InputMaybe<Scalars['numeric']>;
  fee_rebate_7d?: InputMaybe<Scalars['numeric']>;
  fee_rebate_24h?: InputMaybe<Scalars['numeric']>;
  fee_rebate_x_7d?: InputMaybe<Scalars['numeric']>;
  fee_rebate_x_24h?: InputMaybe<Scalars['numeric']>;
  fee_rebate_y_7d?: InputMaybe<Scalars['numeric']>;
  fee_rebate_y_24h?: InputMaybe<Scalars['numeric']>;
  latest_oracle_resilient?: InputMaybe<Scalars['bigint']>;
  liquidity?: InputMaybe<Scalars['numeric']>;
  oracle_average?: InputMaybe<Scalars['bigint']>;
  oracle_enabled?: InputMaybe<Scalars['bigint']>;
  oracle_instant?: InputMaybe<Scalars['bigint']>;
  oracle_resilient?: InputMaybe<Scalars['bigint']>;
  total_supply?: InputMaybe<Scalars['numeric']>;
  volume_7d?: InputMaybe<Scalars['numeric']>;
  volume_24h?: InputMaybe<Scalars['numeric']>;
  volume_x_7d?: InputMaybe<Scalars['numeric']>;
  volume_x_24h?: InputMaybe<Scalars['numeric']>;
  volume_y_7d?: InputMaybe<Scalars['numeric']>;
  volume_y_24h?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "laplace.latest_pool_stats" */
export type LaplaceLatestPoolStatsInsertInput = {
  apr_7d?: InputMaybe<Scalars['numeric']>;
  balance_x?: InputMaybe<Scalars['numeric']>;
  balance_y?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  est_pool_token_price?: InputMaybe<Scalars['bigint']>;
  est_token_y_price?: InputMaybe<Scalars['bigint']>;
  fee_rate_x?: InputMaybe<Scalars['numeric']>;
  fee_rate_y?: InputMaybe<Scalars['numeric']>;
  fee_rebate?: InputMaybe<Scalars['numeric']>;
  fee_rebate_7d?: InputMaybe<Scalars['numeric']>;
  fee_rebate_24h?: InputMaybe<Scalars['numeric']>;
  fee_rebate_x_7d?: InputMaybe<Scalars['numeric']>;
  fee_rebate_x_24h?: InputMaybe<Scalars['numeric']>;
  fee_rebate_y_7d?: InputMaybe<Scalars['numeric']>;
  fee_rebate_y_24h?: InputMaybe<Scalars['numeric']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  latest_oracle_resilient?: InputMaybe<Scalars['bigint']>;
  liquidity?: InputMaybe<Scalars['numeric']>;
  oracle_average?: InputMaybe<Scalars['bigint']>;
  oracle_enabled?: InputMaybe<Scalars['bigint']>;
  oracle_instant?: InputMaybe<Scalars['bigint']>;
  oracle_resilient?: InputMaybe<Scalars['bigint']>;
  pool_token?: InputMaybe<Scalars['String']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  total_supply?: InputMaybe<Scalars['numeric']>;
  volume_7d?: InputMaybe<Scalars['numeric']>;
  volume_24h?: InputMaybe<Scalars['numeric']>;
  volume_x_7d?: InputMaybe<Scalars['numeric']>;
  volume_x_24h?: InputMaybe<Scalars['numeric']>;
  volume_y_7d?: InputMaybe<Scalars['numeric']>;
  volume_y_24h?: InputMaybe<Scalars['numeric']>;
};

/** aggregate max on columns */
export type LaplaceLatestPoolStatsMaxFields = {
  __typename?: 'laplace_latest_pool_stats_max_fields';
  apr_7d?: Maybe<Scalars['numeric']>;
  balance_x?: Maybe<Scalars['numeric']>;
  balance_y?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  est_pool_token_price?: Maybe<Scalars['bigint']>;
  est_token_y_price?: Maybe<Scalars['bigint']>;
  fee_rate_x?: Maybe<Scalars['numeric']>;
  fee_rate_y?: Maybe<Scalars['numeric']>;
  fee_rebate?: Maybe<Scalars['numeric']>;
  fee_rebate_7d?: Maybe<Scalars['numeric']>;
  fee_rebate_24h?: Maybe<Scalars['numeric']>;
  fee_rebate_x_7d?: Maybe<Scalars['numeric']>;
  fee_rebate_x_24h?: Maybe<Scalars['numeric']>;
  fee_rebate_y_7d?: Maybe<Scalars['numeric']>;
  fee_rebate_y_24h?: Maybe<Scalars['numeric']>;
  fee_to_address?: Maybe<Scalars['String']>;
  latest_oracle_resilient?: Maybe<Scalars['bigint']>;
  liquidity?: Maybe<Scalars['numeric']>;
  oracle_average?: Maybe<Scalars['bigint']>;
  oracle_enabled?: Maybe<Scalars['bigint']>;
  oracle_instant?: Maybe<Scalars['bigint']>;
  oracle_resilient?: Maybe<Scalars['bigint']>;
  pool_token?: Maybe<Scalars['String']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_x?: Maybe<Scalars['String']>;
  token_y?: Maybe<Scalars['String']>;
  total_supply?: Maybe<Scalars['numeric']>;
  volume_7d?: Maybe<Scalars['numeric']>;
  volume_24h?: Maybe<Scalars['numeric']>;
  volume_x_7d?: Maybe<Scalars['numeric']>;
  volume_x_24h?: Maybe<Scalars['numeric']>;
  volume_y_7d?: Maybe<Scalars['numeric']>;
  volume_y_24h?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type LaplaceLatestPoolStatsMinFields = {
  __typename?: 'laplace_latest_pool_stats_min_fields';
  apr_7d?: Maybe<Scalars['numeric']>;
  balance_x?: Maybe<Scalars['numeric']>;
  balance_y?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  est_pool_token_price?: Maybe<Scalars['bigint']>;
  est_token_y_price?: Maybe<Scalars['bigint']>;
  fee_rate_x?: Maybe<Scalars['numeric']>;
  fee_rate_y?: Maybe<Scalars['numeric']>;
  fee_rebate?: Maybe<Scalars['numeric']>;
  fee_rebate_7d?: Maybe<Scalars['numeric']>;
  fee_rebate_24h?: Maybe<Scalars['numeric']>;
  fee_rebate_x_7d?: Maybe<Scalars['numeric']>;
  fee_rebate_x_24h?: Maybe<Scalars['numeric']>;
  fee_rebate_y_7d?: Maybe<Scalars['numeric']>;
  fee_rebate_y_24h?: Maybe<Scalars['numeric']>;
  fee_to_address?: Maybe<Scalars['String']>;
  latest_oracle_resilient?: Maybe<Scalars['bigint']>;
  liquidity?: Maybe<Scalars['numeric']>;
  oracle_average?: Maybe<Scalars['bigint']>;
  oracle_enabled?: Maybe<Scalars['bigint']>;
  oracle_instant?: Maybe<Scalars['bigint']>;
  oracle_resilient?: Maybe<Scalars['bigint']>;
  pool_token?: Maybe<Scalars['String']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_x?: Maybe<Scalars['String']>;
  token_y?: Maybe<Scalars['String']>;
  total_supply?: Maybe<Scalars['numeric']>;
  volume_7d?: Maybe<Scalars['numeric']>;
  volume_24h?: Maybe<Scalars['numeric']>;
  volume_x_7d?: Maybe<Scalars['numeric']>;
  volume_x_24h?: Maybe<Scalars['numeric']>;
  volume_y_7d?: Maybe<Scalars['numeric']>;
  volume_y_24h?: Maybe<Scalars['numeric']>;
};

/** response of any mutation on the table "laplace.latest_pool_stats" */
export type LaplaceLatestPoolStatsMutationResponse = {
  __typename?: 'laplace_latest_pool_stats_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceLatestPoolStats>;
};

/** on_conflict condition type for table "laplace.latest_pool_stats" */
export type LaplaceLatestPoolStatsOnConflict = {
  constraint: LaplaceLatestPoolStatsConstraint;
  update_columns?: Array<LaplaceLatestPoolStatsUpdateColumn>;
  where?: InputMaybe<LaplaceLatestPoolStatsBoolExp>;
};

/** Ordering options when selecting data from "laplace.latest_pool_stats". */
export type LaplaceLatestPoolStatsOrderBy = {
  apr_7d?: InputMaybe<OrderBy>;
  balance_x?: InputMaybe<OrderBy>;
  balance_y?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  burn_block_time?: InputMaybe<OrderBy>;
  est_pool_token_price?: InputMaybe<OrderBy>;
  est_token_y_price?: InputMaybe<OrderBy>;
  fee_rate_x?: InputMaybe<OrderBy>;
  fee_rate_y?: InputMaybe<OrderBy>;
  fee_rebate?: InputMaybe<OrderBy>;
  fee_rebate_7d?: InputMaybe<OrderBy>;
  fee_rebate_24h?: InputMaybe<OrderBy>;
  fee_rebate_x_7d?: InputMaybe<OrderBy>;
  fee_rebate_x_24h?: InputMaybe<OrderBy>;
  fee_rebate_y_7d?: InputMaybe<OrderBy>;
  fee_rebate_y_24h?: InputMaybe<OrderBy>;
  fee_to_address?: InputMaybe<OrderBy>;
  latest_oracle_resilient?: InputMaybe<OrderBy>;
  liquidity?: InputMaybe<OrderBy>;
  oracle_average?: InputMaybe<OrderBy>;
  oracle_enabled?: InputMaybe<OrderBy>;
  oracle_instant?: InputMaybe<OrderBy>;
  oracle_resilient?: InputMaybe<OrderBy>;
  pool_token?: InputMaybe<OrderBy>;
  sync_at?: InputMaybe<OrderBy>;
  token_x?: InputMaybe<OrderBy>;
  token_y?: InputMaybe<OrderBy>;
  total_supply?: InputMaybe<OrderBy>;
  volume_7d?: InputMaybe<OrderBy>;
  volume_24h?: InputMaybe<OrderBy>;
  volume_x_7d?: InputMaybe<OrderBy>;
  volume_x_24h?: InputMaybe<OrderBy>;
  volume_y_7d?: InputMaybe<OrderBy>;
  volume_y_24h?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.latest_pool_stats */
export type LaplaceLatestPoolStatsPkColumnsInput = {
  pool_token: Scalars['String'];
};

/** select columns of table "laplace.latest_pool_stats" */
export enum LaplaceLatestPoolStatsSelectColumn {
  /** column name */
  Apr_7d = 'apr_7d',
  /** column name */
  BalanceX = 'balance_x',
  /** column name */
  BalanceY = 'balance_y',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  EstPoolTokenPrice = 'est_pool_token_price',
  /** column name */
  EstTokenYPrice = 'est_token_y_price',
  /** column name */
  FeeRateX = 'fee_rate_x',
  /** column name */
  FeeRateY = 'fee_rate_y',
  /** column name */
  FeeRebate = 'fee_rebate',
  /** column name */
  FeeRebate_7d = 'fee_rebate_7d',
  /** column name */
  FeeRebate_24h = 'fee_rebate_24h',
  /** column name */
  FeeRebateX_7d = 'fee_rebate_x_7d',
  /** column name */
  FeeRebateX_24h = 'fee_rebate_x_24h',
  /** column name */
  FeeRebateY_7d = 'fee_rebate_y_7d',
  /** column name */
  FeeRebateY_24h = 'fee_rebate_y_24h',
  /** column name */
  FeeToAddress = 'fee_to_address',
  /** column name */
  LatestOracleResilient = 'latest_oracle_resilient',
  /** column name */
  Liquidity = 'liquidity',
  /** column name */
  OracleAverage = 'oracle_average',
  /** column name */
  OracleEnabled = 'oracle_enabled',
  /** column name */
  OracleInstant = 'oracle_instant',
  /** column name */
  OracleResilient = 'oracle_resilient',
  /** column name */
  PoolToken = 'pool_token',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenX = 'token_x',
  /** column name */
  TokenY = 'token_y',
  /** column name */
  TotalSupply = 'total_supply',
  /** column name */
  Volume_7d = 'volume_7d',
  /** column name */
  Volume_24h = 'volume_24h',
  /** column name */
  VolumeX_7d = 'volume_x_7d',
  /** column name */
  VolumeX_24h = 'volume_x_24h',
  /** column name */
  VolumeY_7d = 'volume_y_7d',
  /** column name */
  VolumeY_24h = 'volume_y_24h'
}

/** input type for updating data in table "laplace.latest_pool_stats" */
export type LaplaceLatestPoolStatsSetInput = {
  apr_7d?: InputMaybe<Scalars['numeric']>;
  balance_x?: InputMaybe<Scalars['numeric']>;
  balance_y?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  est_pool_token_price?: InputMaybe<Scalars['bigint']>;
  est_token_y_price?: InputMaybe<Scalars['bigint']>;
  fee_rate_x?: InputMaybe<Scalars['numeric']>;
  fee_rate_y?: InputMaybe<Scalars['numeric']>;
  fee_rebate?: InputMaybe<Scalars['numeric']>;
  fee_rebate_7d?: InputMaybe<Scalars['numeric']>;
  fee_rebate_24h?: InputMaybe<Scalars['numeric']>;
  fee_rebate_x_7d?: InputMaybe<Scalars['numeric']>;
  fee_rebate_x_24h?: InputMaybe<Scalars['numeric']>;
  fee_rebate_y_7d?: InputMaybe<Scalars['numeric']>;
  fee_rebate_y_24h?: InputMaybe<Scalars['numeric']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  latest_oracle_resilient?: InputMaybe<Scalars['bigint']>;
  liquidity?: InputMaybe<Scalars['numeric']>;
  oracle_average?: InputMaybe<Scalars['bigint']>;
  oracle_enabled?: InputMaybe<Scalars['bigint']>;
  oracle_instant?: InputMaybe<Scalars['bigint']>;
  oracle_resilient?: InputMaybe<Scalars['bigint']>;
  pool_token?: InputMaybe<Scalars['String']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  total_supply?: InputMaybe<Scalars['numeric']>;
  volume_7d?: InputMaybe<Scalars['numeric']>;
  volume_24h?: InputMaybe<Scalars['numeric']>;
  volume_x_7d?: InputMaybe<Scalars['numeric']>;
  volume_x_24h?: InputMaybe<Scalars['numeric']>;
  volume_y_7d?: InputMaybe<Scalars['numeric']>;
  volume_y_24h?: InputMaybe<Scalars['numeric']>;
};

/** aggregate stddev on columns */
export type LaplaceLatestPoolStatsStddevFields = {
  __typename?: 'laplace_latest_pool_stats_stddev_fields';
  apr_7d?: Maybe<Scalars['Float']>;
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  fee_rebate_7d?: Maybe<Scalars['Float']>;
  fee_rebate_24h?: Maybe<Scalars['Float']>;
  fee_rebate_x_7d?: Maybe<Scalars['Float']>;
  fee_rebate_x_24h?: Maybe<Scalars['Float']>;
  fee_rebate_y_7d?: Maybe<Scalars['Float']>;
  fee_rebate_y_24h?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  liquidity?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_enabled?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  volume_7d?: Maybe<Scalars['Float']>;
  volume_24h?: Maybe<Scalars['Float']>;
  volume_x_7d?: Maybe<Scalars['Float']>;
  volume_x_24h?: Maybe<Scalars['Float']>;
  volume_y_7d?: Maybe<Scalars['Float']>;
  volume_y_24h?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceLatestPoolStatsStddevPopFields = {
  __typename?: 'laplace_latest_pool_stats_stddev_pop_fields';
  apr_7d?: Maybe<Scalars['Float']>;
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  fee_rebate_7d?: Maybe<Scalars['Float']>;
  fee_rebate_24h?: Maybe<Scalars['Float']>;
  fee_rebate_x_7d?: Maybe<Scalars['Float']>;
  fee_rebate_x_24h?: Maybe<Scalars['Float']>;
  fee_rebate_y_7d?: Maybe<Scalars['Float']>;
  fee_rebate_y_24h?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  liquidity?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_enabled?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  volume_7d?: Maybe<Scalars['Float']>;
  volume_24h?: Maybe<Scalars['Float']>;
  volume_x_7d?: Maybe<Scalars['Float']>;
  volume_x_24h?: Maybe<Scalars['Float']>;
  volume_y_7d?: Maybe<Scalars['Float']>;
  volume_y_24h?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceLatestPoolStatsStddevSampFields = {
  __typename?: 'laplace_latest_pool_stats_stddev_samp_fields';
  apr_7d?: Maybe<Scalars['Float']>;
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  fee_rebate_7d?: Maybe<Scalars['Float']>;
  fee_rebate_24h?: Maybe<Scalars['Float']>;
  fee_rebate_x_7d?: Maybe<Scalars['Float']>;
  fee_rebate_x_24h?: Maybe<Scalars['Float']>;
  fee_rebate_y_7d?: Maybe<Scalars['Float']>;
  fee_rebate_y_24h?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  liquidity?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_enabled?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  volume_7d?: Maybe<Scalars['Float']>;
  volume_24h?: Maybe<Scalars['Float']>;
  volume_x_7d?: Maybe<Scalars['Float']>;
  volume_x_24h?: Maybe<Scalars['Float']>;
  volume_y_7d?: Maybe<Scalars['Float']>;
  volume_y_24h?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_latest_pool_stats" */
export type LaplaceLatestPoolStatsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceLatestPoolStatsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceLatestPoolStatsStreamCursorValueInput = {
  apr_7d?: InputMaybe<Scalars['numeric']>;
  balance_x?: InputMaybe<Scalars['numeric']>;
  balance_y?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  est_pool_token_price?: InputMaybe<Scalars['bigint']>;
  est_token_y_price?: InputMaybe<Scalars['bigint']>;
  fee_rate_x?: InputMaybe<Scalars['numeric']>;
  fee_rate_y?: InputMaybe<Scalars['numeric']>;
  fee_rebate?: InputMaybe<Scalars['numeric']>;
  fee_rebate_7d?: InputMaybe<Scalars['numeric']>;
  fee_rebate_24h?: InputMaybe<Scalars['numeric']>;
  fee_rebate_x_7d?: InputMaybe<Scalars['numeric']>;
  fee_rebate_x_24h?: InputMaybe<Scalars['numeric']>;
  fee_rebate_y_7d?: InputMaybe<Scalars['numeric']>;
  fee_rebate_y_24h?: InputMaybe<Scalars['numeric']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  latest_oracle_resilient?: InputMaybe<Scalars['bigint']>;
  liquidity?: InputMaybe<Scalars['numeric']>;
  oracle_average?: InputMaybe<Scalars['bigint']>;
  oracle_enabled?: InputMaybe<Scalars['bigint']>;
  oracle_instant?: InputMaybe<Scalars['bigint']>;
  oracle_resilient?: InputMaybe<Scalars['bigint']>;
  pool_token?: InputMaybe<Scalars['String']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  total_supply?: InputMaybe<Scalars['numeric']>;
  volume_7d?: InputMaybe<Scalars['numeric']>;
  volume_24h?: InputMaybe<Scalars['numeric']>;
  volume_x_7d?: InputMaybe<Scalars['numeric']>;
  volume_x_24h?: InputMaybe<Scalars['numeric']>;
  volume_y_7d?: InputMaybe<Scalars['numeric']>;
  volume_y_24h?: InputMaybe<Scalars['numeric']>;
};

/** aggregate sum on columns */
export type LaplaceLatestPoolStatsSumFields = {
  __typename?: 'laplace_latest_pool_stats_sum_fields';
  apr_7d?: Maybe<Scalars['numeric']>;
  balance_x?: Maybe<Scalars['numeric']>;
  balance_y?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  est_pool_token_price?: Maybe<Scalars['bigint']>;
  est_token_y_price?: Maybe<Scalars['bigint']>;
  fee_rate_x?: Maybe<Scalars['numeric']>;
  fee_rate_y?: Maybe<Scalars['numeric']>;
  fee_rebate?: Maybe<Scalars['numeric']>;
  fee_rebate_7d?: Maybe<Scalars['numeric']>;
  fee_rebate_24h?: Maybe<Scalars['numeric']>;
  fee_rebate_x_7d?: Maybe<Scalars['numeric']>;
  fee_rebate_x_24h?: Maybe<Scalars['numeric']>;
  fee_rebate_y_7d?: Maybe<Scalars['numeric']>;
  fee_rebate_y_24h?: Maybe<Scalars['numeric']>;
  latest_oracle_resilient?: Maybe<Scalars['bigint']>;
  liquidity?: Maybe<Scalars['numeric']>;
  oracle_average?: Maybe<Scalars['bigint']>;
  oracle_enabled?: Maybe<Scalars['bigint']>;
  oracle_instant?: Maybe<Scalars['bigint']>;
  oracle_resilient?: Maybe<Scalars['bigint']>;
  total_supply?: Maybe<Scalars['numeric']>;
  volume_7d?: Maybe<Scalars['numeric']>;
  volume_24h?: Maybe<Scalars['numeric']>;
  volume_x_7d?: Maybe<Scalars['numeric']>;
  volume_x_24h?: Maybe<Scalars['numeric']>;
  volume_y_7d?: Maybe<Scalars['numeric']>;
  volume_y_24h?: Maybe<Scalars['numeric']>;
};

/** update columns of table "laplace.latest_pool_stats" */
export enum LaplaceLatestPoolStatsUpdateColumn {
  /** column name */
  Apr_7d = 'apr_7d',
  /** column name */
  BalanceX = 'balance_x',
  /** column name */
  BalanceY = 'balance_y',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  EstPoolTokenPrice = 'est_pool_token_price',
  /** column name */
  EstTokenYPrice = 'est_token_y_price',
  /** column name */
  FeeRateX = 'fee_rate_x',
  /** column name */
  FeeRateY = 'fee_rate_y',
  /** column name */
  FeeRebate = 'fee_rebate',
  /** column name */
  FeeRebate_7d = 'fee_rebate_7d',
  /** column name */
  FeeRebate_24h = 'fee_rebate_24h',
  /** column name */
  FeeRebateX_7d = 'fee_rebate_x_7d',
  /** column name */
  FeeRebateX_24h = 'fee_rebate_x_24h',
  /** column name */
  FeeRebateY_7d = 'fee_rebate_y_7d',
  /** column name */
  FeeRebateY_24h = 'fee_rebate_y_24h',
  /** column name */
  FeeToAddress = 'fee_to_address',
  /** column name */
  LatestOracleResilient = 'latest_oracle_resilient',
  /** column name */
  Liquidity = 'liquidity',
  /** column name */
  OracleAverage = 'oracle_average',
  /** column name */
  OracleEnabled = 'oracle_enabled',
  /** column name */
  OracleInstant = 'oracle_instant',
  /** column name */
  OracleResilient = 'oracle_resilient',
  /** column name */
  PoolToken = 'pool_token',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenX = 'token_x',
  /** column name */
  TokenY = 'token_y',
  /** column name */
  TotalSupply = 'total_supply',
  /** column name */
  Volume_7d = 'volume_7d',
  /** column name */
  Volume_24h = 'volume_24h',
  /** column name */
  VolumeX_7d = 'volume_x_7d',
  /** column name */
  VolumeX_24h = 'volume_x_24h',
  /** column name */
  VolumeY_7d = 'volume_y_7d',
  /** column name */
  VolumeY_24h = 'volume_y_24h'
}

export type LaplaceLatestPoolStatsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceLatestPoolStatsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceLatestPoolStatsSetInput>;
  where: LaplaceLatestPoolStatsBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceLatestPoolStatsVarPopFields = {
  __typename?: 'laplace_latest_pool_stats_var_pop_fields';
  apr_7d?: Maybe<Scalars['Float']>;
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  fee_rebate_7d?: Maybe<Scalars['Float']>;
  fee_rebate_24h?: Maybe<Scalars['Float']>;
  fee_rebate_x_7d?: Maybe<Scalars['Float']>;
  fee_rebate_x_24h?: Maybe<Scalars['Float']>;
  fee_rebate_y_7d?: Maybe<Scalars['Float']>;
  fee_rebate_y_24h?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  liquidity?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_enabled?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  volume_7d?: Maybe<Scalars['Float']>;
  volume_24h?: Maybe<Scalars['Float']>;
  volume_x_7d?: Maybe<Scalars['Float']>;
  volume_x_24h?: Maybe<Scalars['Float']>;
  volume_y_7d?: Maybe<Scalars['Float']>;
  volume_y_24h?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceLatestPoolStatsVarSampFields = {
  __typename?: 'laplace_latest_pool_stats_var_samp_fields';
  apr_7d?: Maybe<Scalars['Float']>;
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  fee_rebate_7d?: Maybe<Scalars['Float']>;
  fee_rebate_24h?: Maybe<Scalars['Float']>;
  fee_rebate_x_7d?: Maybe<Scalars['Float']>;
  fee_rebate_x_24h?: Maybe<Scalars['Float']>;
  fee_rebate_y_7d?: Maybe<Scalars['Float']>;
  fee_rebate_y_24h?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  liquidity?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_enabled?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  volume_7d?: Maybe<Scalars['Float']>;
  volume_24h?: Maybe<Scalars['Float']>;
  volume_x_7d?: Maybe<Scalars['Float']>;
  volume_x_24h?: Maybe<Scalars['Float']>;
  volume_y_7d?: Maybe<Scalars['Float']>;
  volume_y_24h?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceLatestPoolStatsVarianceFields = {
  __typename?: 'laplace_latest_pool_stats_variance_fields';
  apr_7d?: Maybe<Scalars['Float']>;
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  fee_rebate_7d?: Maybe<Scalars['Float']>;
  fee_rebate_24h?: Maybe<Scalars['Float']>;
  fee_rebate_x_7d?: Maybe<Scalars['Float']>;
  fee_rebate_x_24h?: Maybe<Scalars['Float']>;
  fee_rebate_y_7d?: Maybe<Scalars['Float']>;
  fee_rebate_y_24h?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  liquidity?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_enabled?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  volume_7d?: Maybe<Scalars['Float']>;
  volume_24h?: Maybe<Scalars['Float']>;
  volume_x_7d?: Maybe<Scalars['Float']>;
  volume_x_24h?: Maybe<Scalars['Float']>;
  volume_y_7d?: Maybe<Scalars['Float']>;
  volume_y_24h?: Maybe<Scalars['Float']>;
};

/** Contract simple_weight_pool_alex latest-block data */
export type LaplaceLatestSimpleWeightPoolAlex = {
  __typename?: 'laplace_latest_simple_weight_pool_alex';
  balance_x: Scalars['bigint'];
  balance_y: Scalars['bigint'];
  block_height: Scalars['Int'];
  burn_block_time: Scalars['Int'];
  end_block: Scalars['numeric'];
  est_pool_token_price: Scalars['bigint'];
  est_token_y_price: Scalars['bigint'];
  fee_rate_x: Scalars['bigint'];
  fee_rate_y: Scalars['bigint'];
  fee_rebate: Scalars['bigint'];
  fee_to_address: Scalars['String'];
  latest_oracle_resilient: Scalars['bigint'];
  oracle_average: Scalars['bigint'];
  oracle_enabled: Scalars['Boolean'];
  oracle_instant: Scalars['bigint'];
  oracle_resilient: Scalars['bigint'];
  pool_token: Scalars['String'];
  start_block: Scalars['numeric'];
  sync_at: Scalars['timestamptz'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
  total_supply: Scalars['bigint'];
};

/** aggregated selection of "laplace.latest_simple_weight_pool_alex" */
export type LaplaceLatestSimpleWeightPoolAlexAggregate = {
  __typename?: 'laplace_latest_simple_weight_pool_alex_aggregate';
  aggregate?: Maybe<LaplaceLatestSimpleWeightPoolAlexAggregateFields>;
  nodes: Array<LaplaceLatestSimpleWeightPoolAlex>;
};

/** aggregate fields of "laplace.latest_simple_weight_pool_alex" */
export type LaplaceLatestSimpleWeightPoolAlexAggregateFields = {
  __typename?: 'laplace_latest_simple_weight_pool_alex_aggregate_fields';
  avg?: Maybe<LaplaceLatestSimpleWeightPoolAlexAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceLatestSimpleWeightPoolAlexMaxFields>;
  min?: Maybe<LaplaceLatestSimpleWeightPoolAlexMinFields>;
  stddev?: Maybe<LaplaceLatestSimpleWeightPoolAlexStddevFields>;
  stddev_pop?: Maybe<LaplaceLatestSimpleWeightPoolAlexStddevPopFields>;
  stddev_samp?: Maybe<LaplaceLatestSimpleWeightPoolAlexStddevSampFields>;
  sum?: Maybe<LaplaceLatestSimpleWeightPoolAlexSumFields>;
  var_pop?: Maybe<LaplaceLatestSimpleWeightPoolAlexVarPopFields>;
  var_samp?: Maybe<LaplaceLatestSimpleWeightPoolAlexVarSampFields>;
  variance?: Maybe<LaplaceLatestSimpleWeightPoolAlexVarianceFields>;
};


/** aggregate fields of "laplace.latest_simple_weight_pool_alex" */
export type LaplaceLatestSimpleWeightPoolAlexAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceLatestSimpleWeightPoolAlexSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LaplaceLatestSimpleWeightPoolAlexAvgFields = {
  __typename?: 'laplace_latest_simple_weight_pool_alex_avg_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  end_block?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  start_block?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.latest_simple_weight_pool_alex". All fields are combined with a logical 'AND'. */
export type LaplaceLatestSimpleWeightPoolAlexBoolExp = {
  _and?: InputMaybe<Array<LaplaceLatestSimpleWeightPoolAlexBoolExp>>;
  _not?: InputMaybe<LaplaceLatestSimpleWeightPoolAlexBoolExp>;
  _or?: InputMaybe<Array<LaplaceLatestSimpleWeightPoolAlexBoolExp>>;
  balance_x?: InputMaybe<BigintComparisonExp>;
  balance_y?: InputMaybe<BigintComparisonExp>;
  block_height?: InputMaybe<IntComparisonExp>;
  burn_block_time?: InputMaybe<IntComparisonExp>;
  end_block?: InputMaybe<NumericComparisonExp>;
  est_pool_token_price?: InputMaybe<BigintComparisonExp>;
  est_token_y_price?: InputMaybe<BigintComparisonExp>;
  fee_rate_x?: InputMaybe<BigintComparisonExp>;
  fee_rate_y?: InputMaybe<BigintComparisonExp>;
  fee_rebate?: InputMaybe<BigintComparisonExp>;
  fee_to_address?: InputMaybe<StringComparisonExp>;
  latest_oracle_resilient?: InputMaybe<BigintComparisonExp>;
  oracle_average?: InputMaybe<BigintComparisonExp>;
  oracle_enabled?: InputMaybe<BooleanComparisonExp>;
  oracle_instant?: InputMaybe<BigintComparisonExp>;
  oracle_resilient?: InputMaybe<BigintComparisonExp>;
  pool_token?: InputMaybe<StringComparisonExp>;
  start_block?: InputMaybe<NumericComparisonExp>;
  sync_at?: InputMaybe<TimestamptzComparisonExp>;
  token_x?: InputMaybe<StringComparisonExp>;
  token_y?: InputMaybe<StringComparisonExp>;
  total_supply?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "laplace.latest_simple_weight_pool_alex" */
export enum LaplaceLatestSimpleWeightPoolAlexConstraint {
  /** unique or primary key constraint on columns "token_y", "token_x" */
  LatestSimpleWeightPoolAlexPkey = 'latest_simple_weight_pool_alex_pkey'
}

/** input type for incrementing numeric columns in table "laplace.latest_simple_weight_pool_alex" */
export type LaplaceLatestSimpleWeightPoolAlexIncInput = {
  balance_x?: InputMaybe<Scalars['bigint']>;
  balance_y?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  end_block?: InputMaybe<Scalars['numeric']>;
  est_pool_token_price?: InputMaybe<Scalars['bigint']>;
  est_token_y_price?: InputMaybe<Scalars['bigint']>;
  fee_rate_x?: InputMaybe<Scalars['bigint']>;
  fee_rate_y?: InputMaybe<Scalars['bigint']>;
  fee_rebate?: InputMaybe<Scalars['bigint']>;
  latest_oracle_resilient?: InputMaybe<Scalars['bigint']>;
  oracle_average?: InputMaybe<Scalars['bigint']>;
  oracle_instant?: InputMaybe<Scalars['bigint']>;
  oracle_resilient?: InputMaybe<Scalars['bigint']>;
  start_block?: InputMaybe<Scalars['numeric']>;
  total_supply?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "laplace.latest_simple_weight_pool_alex" */
export type LaplaceLatestSimpleWeightPoolAlexInsertInput = {
  balance_x?: InputMaybe<Scalars['bigint']>;
  balance_y?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  end_block?: InputMaybe<Scalars['numeric']>;
  est_pool_token_price?: InputMaybe<Scalars['bigint']>;
  est_token_y_price?: InputMaybe<Scalars['bigint']>;
  fee_rate_x?: InputMaybe<Scalars['bigint']>;
  fee_rate_y?: InputMaybe<Scalars['bigint']>;
  fee_rebate?: InputMaybe<Scalars['bigint']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  latest_oracle_resilient?: InputMaybe<Scalars['bigint']>;
  oracle_average?: InputMaybe<Scalars['bigint']>;
  oracle_enabled?: InputMaybe<Scalars['Boolean']>;
  oracle_instant?: InputMaybe<Scalars['bigint']>;
  oracle_resilient?: InputMaybe<Scalars['bigint']>;
  pool_token?: InputMaybe<Scalars['String']>;
  start_block?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  total_supply?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type LaplaceLatestSimpleWeightPoolAlexMaxFields = {
  __typename?: 'laplace_latest_simple_weight_pool_alex_max_fields';
  balance_x?: Maybe<Scalars['bigint']>;
  balance_y?: Maybe<Scalars['bigint']>;
  block_height?: Maybe<Scalars['Int']>;
  burn_block_time?: Maybe<Scalars['Int']>;
  end_block?: Maybe<Scalars['numeric']>;
  est_pool_token_price?: Maybe<Scalars['bigint']>;
  est_token_y_price?: Maybe<Scalars['bigint']>;
  fee_rate_x?: Maybe<Scalars['bigint']>;
  fee_rate_y?: Maybe<Scalars['bigint']>;
  fee_rebate?: Maybe<Scalars['bigint']>;
  fee_to_address?: Maybe<Scalars['String']>;
  latest_oracle_resilient?: Maybe<Scalars['bigint']>;
  oracle_average?: Maybe<Scalars['bigint']>;
  oracle_instant?: Maybe<Scalars['bigint']>;
  oracle_resilient?: Maybe<Scalars['bigint']>;
  pool_token?: Maybe<Scalars['String']>;
  start_block?: Maybe<Scalars['numeric']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_x?: Maybe<Scalars['String']>;
  token_y?: Maybe<Scalars['String']>;
  total_supply?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type LaplaceLatestSimpleWeightPoolAlexMinFields = {
  __typename?: 'laplace_latest_simple_weight_pool_alex_min_fields';
  balance_x?: Maybe<Scalars['bigint']>;
  balance_y?: Maybe<Scalars['bigint']>;
  block_height?: Maybe<Scalars['Int']>;
  burn_block_time?: Maybe<Scalars['Int']>;
  end_block?: Maybe<Scalars['numeric']>;
  est_pool_token_price?: Maybe<Scalars['bigint']>;
  est_token_y_price?: Maybe<Scalars['bigint']>;
  fee_rate_x?: Maybe<Scalars['bigint']>;
  fee_rate_y?: Maybe<Scalars['bigint']>;
  fee_rebate?: Maybe<Scalars['bigint']>;
  fee_to_address?: Maybe<Scalars['String']>;
  latest_oracle_resilient?: Maybe<Scalars['bigint']>;
  oracle_average?: Maybe<Scalars['bigint']>;
  oracle_instant?: Maybe<Scalars['bigint']>;
  oracle_resilient?: Maybe<Scalars['bigint']>;
  pool_token?: Maybe<Scalars['String']>;
  start_block?: Maybe<Scalars['numeric']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_x?: Maybe<Scalars['String']>;
  token_y?: Maybe<Scalars['String']>;
  total_supply?: Maybe<Scalars['bigint']>;
};

/** response of any mutation on the table "laplace.latest_simple_weight_pool_alex" */
export type LaplaceLatestSimpleWeightPoolAlexMutationResponse = {
  __typename?: 'laplace_latest_simple_weight_pool_alex_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceLatestSimpleWeightPoolAlex>;
};

/** on_conflict condition type for table "laplace.latest_simple_weight_pool_alex" */
export type LaplaceLatestSimpleWeightPoolAlexOnConflict = {
  constraint: LaplaceLatestSimpleWeightPoolAlexConstraint;
  update_columns?: Array<LaplaceLatestSimpleWeightPoolAlexUpdateColumn>;
  where?: InputMaybe<LaplaceLatestSimpleWeightPoolAlexBoolExp>;
};

/** Ordering options when selecting data from "laplace.latest_simple_weight_pool_alex". */
export type LaplaceLatestSimpleWeightPoolAlexOrderBy = {
  balance_x?: InputMaybe<OrderBy>;
  balance_y?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  burn_block_time?: InputMaybe<OrderBy>;
  end_block?: InputMaybe<OrderBy>;
  est_pool_token_price?: InputMaybe<OrderBy>;
  est_token_y_price?: InputMaybe<OrderBy>;
  fee_rate_x?: InputMaybe<OrderBy>;
  fee_rate_y?: InputMaybe<OrderBy>;
  fee_rebate?: InputMaybe<OrderBy>;
  fee_to_address?: InputMaybe<OrderBy>;
  latest_oracle_resilient?: InputMaybe<OrderBy>;
  oracle_average?: InputMaybe<OrderBy>;
  oracle_enabled?: InputMaybe<OrderBy>;
  oracle_instant?: InputMaybe<OrderBy>;
  oracle_resilient?: InputMaybe<OrderBy>;
  pool_token?: InputMaybe<OrderBy>;
  start_block?: InputMaybe<OrderBy>;
  sync_at?: InputMaybe<OrderBy>;
  token_x?: InputMaybe<OrderBy>;
  token_y?: InputMaybe<OrderBy>;
  total_supply?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.latest_simple_weight_pool_alex */
export type LaplaceLatestSimpleWeightPoolAlexPkColumnsInput = {
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};

/** select columns of table "laplace.latest_simple_weight_pool_alex" */
export enum LaplaceLatestSimpleWeightPoolAlexSelectColumn {
  /** column name */
  BalanceX = 'balance_x',
  /** column name */
  BalanceY = 'balance_y',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  EndBlock = 'end_block',
  /** column name */
  EstPoolTokenPrice = 'est_pool_token_price',
  /** column name */
  EstTokenYPrice = 'est_token_y_price',
  /** column name */
  FeeRateX = 'fee_rate_x',
  /** column name */
  FeeRateY = 'fee_rate_y',
  /** column name */
  FeeRebate = 'fee_rebate',
  /** column name */
  FeeToAddress = 'fee_to_address',
  /** column name */
  LatestOracleResilient = 'latest_oracle_resilient',
  /** column name */
  OracleAverage = 'oracle_average',
  /** column name */
  OracleEnabled = 'oracle_enabled',
  /** column name */
  OracleInstant = 'oracle_instant',
  /** column name */
  OracleResilient = 'oracle_resilient',
  /** column name */
  PoolToken = 'pool_token',
  /** column name */
  StartBlock = 'start_block',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenX = 'token_x',
  /** column name */
  TokenY = 'token_y',
  /** column name */
  TotalSupply = 'total_supply'
}

/** input type for updating data in table "laplace.latest_simple_weight_pool_alex" */
export type LaplaceLatestSimpleWeightPoolAlexSetInput = {
  balance_x?: InputMaybe<Scalars['bigint']>;
  balance_y?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  end_block?: InputMaybe<Scalars['numeric']>;
  est_pool_token_price?: InputMaybe<Scalars['bigint']>;
  est_token_y_price?: InputMaybe<Scalars['bigint']>;
  fee_rate_x?: InputMaybe<Scalars['bigint']>;
  fee_rate_y?: InputMaybe<Scalars['bigint']>;
  fee_rebate?: InputMaybe<Scalars['bigint']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  latest_oracle_resilient?: InputMaybe<Scalars['bigint']>;
  oracle_average?: InputMaybe<Scalars['bigint']>;
  oracle_enabled?: InputMaybe<Scalars['Boolean']>;
  oracle_instant?: InputMaybe<Scalars['bigint']>;
  oracle_resilient?: InputMaybe<Scalars['bigint']>;
  pool_token?: InputMaybe<Scalars['String']>;
  start_block?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  total_supply?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type LaplaceLatestSimpleWeightPoolAlexStddevFields = {
  __typename?: 'laplace_latest_simple_weight_pool_alex_stddev_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  end_block?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  start_block?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceLatestSimpleWeightPoolAlexStddevPopFields = {
  __typename?: 'laplace_latest_simple_weight_pool_alex_stddev_pop_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  end_block?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  start_block?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceLatestSimpleWeightPoolAlexStddevSampFields = {
  __typename?: 'laplace_latest_simple_weight_pool_alex_stddev_samp_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  end_block?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  start_block?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_latest_simple_weight_pool_alex" */
export type LaplaceLatestSimpleWeightPoolAlexStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceLatestSimpleWeightPoolAlexStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceLatestSimpleWeightPoolAlexStreamCursorValueInput = {
  balance_x?: InputMaybe<Scalars['bigint']>;
  balance_y?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  end_block?: InputMaybe<Scalars['numeric']>;
  est_pool_token_price?: InputMaybe<Scalars['bigint']>;
  est_token_y_price?: InputMaybe<Scalars['bigint']>;
  fee_rate_x?: InputMaybe<Scalars['bigint']>;
  fee_rate_y?: InputMaybe<Scalars['bigint']>;
  fee_rebate?: InputMaybe<Scalars['bigint']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  latest_oracle_resilient?: InputMaybe<Scalars['bigint']>;
  oracle_average?: InputMaybe<Scalars['bigint']>;
  oracle_enabled?: InputMaybe<Scalars['Boolean']>;
  oracle_instant?: InputMaybe<Scalars['bigint']>;
  oracle_resilient?: InputMaybe<Scalars['bigint']>;
  pool_token?: InputMaybe<Scalars['String']>;
  start_block?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  total_supply?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type LaplaceLatestSimpleWeightPoolAlexSumFields = {
  __typename?: 'laplace_latest_simple_weight_pool_alex_sum_fields';
  balance_x?: Maybe<Scalars['bigint']>;
  balance_y?: Maybe<Scalars['bigint']>;
  block_height?: Maybe<Scalars['Int']>;
  burn_block_time?: Maybe<Scalars['Int']>;
  end_block?: Maybe<Scalars['numeric']>;
  est_pool_token_price?: Maybe<Scalars['bigint']>;
  est_token_y_price?: Maybe<Scalars['bigint']>;
  fee_rate_x?: Maybe<Scalars['bigint']>;
  fee_rate_y?: Maybe<Scalars['bigint']>;
  fee_rebate?: Maybe<Scalars['bigint']>;
  latest_oracle_resilient?: Maybe<Scalars['bigint']>;
  oracle_average?: Maybe<Scalars['bigint']>;
  oracle_instant?: Maybe<Scalars['bigint']>;
  oracle_resilient?: Maybe<Scalars['bigint']>;
  start_block?: Maybe<Scalars['numeric']>;
  total_supply?: Maybe<Scalars['bigint']>;
};

/** update columns of table "laplace.latest_simple_weight_pool_alex" */
export enum LaplaceLatestSimpleWeightPoolAlexUpdateColumn {
  /** column name */
  BalanceX = 'balance_x',
  /** column name */
  BalanceY = 'balance_y',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  EndBlock = 'end_block',
  /** column name */
  EstPoolTokenPrice = 'est_pool_token_price',
  /** column name */
  EstTokenYPrice = 'est_token_y_price',
  /** column name */
  FeeRateX = 'fee_rate_x',
  /** column name */
  FeeRateY = 'fee_rate_y',
  /** column name */
  FeeRebate = 'fee_rebate',
  /** column name */
  FeeToAddress = 'fee_to_address',
  /** column name */
  LatestOracleResilient = 'latest_oracle_resilient',
  /** column name */
  OracleAverage = 'oracle_average',
  /** column name */
  OracleEnabled = 'oracle_enabled',
  /** column name */
  OracleInstant = 'oracle_instant',
  /** column name */
  OracleResilient = 'oracle_resilient',
  /** column name */
  PoolToken = 'pool_token',
  /** column name */
  StartBlock = 'start_block',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenX = 'token_x',
  /** column name */
  TokenY = 'token_y',
  /** column name */
  TotalSupply = 'total_supply'
}

export type LaplaceLatestSimpleWeightPoolAlexUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceLatestSimpleWeightPoolAlexIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceLatestSimpleWeightPoolAlexSetInput>;
  where: LaplaceLatestSimpleWeightPoolAlexBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceLatestSimpleWeightPoolAlexVarPopFields = {
  __typename?: 'laplace_latest_simple_weight_pool_alex_var_pop_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  end_block?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  start_block?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceLatestSimpleWeightPoolAlexVarSampFields = {
  __typename?: 'laplace_latest_simple_weight_pool_alex_var_samp_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  end_block?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  start_block?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceLatestSimpleWeightPoolAlexVarianceFields = {
  __typename?: 'laplace_latest_simple_weight_pool_alex_variance_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  end_block?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  start_block?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
};

/** ALEX latest yield token pool */
export type LaplaceLatestYieldTokenPool = {
  __typename?: 'laplace_latest_yield_token_pool';
  balance_token: Scalars['numeric'];
  balance_virtual: Scalars['numeric'];
  balance_yield_token: Scalars['numeric'];
  block_height: Scalars['numeric'];
  borrow_apr: Scalars['numeric'];
  burn_block_time: Scalars['numeric'];
  deposit_apr: Scalars['numeric'];
  expiry: Scalars['numeric'];
  fee_rate_token: Scalars['numeric'];
  fee_rate_yield_token: Scalars['numeric'];
  fee_rebate: Scalars['numeric'];
  fee_to_address: Scalars['String'];
  listed: Scalars['numeric'];
  max_expiry: Scalars['numeric'];
  min_fee?: Maybe<Scalars['numeric']>;
  oracle_average: Scalars['numeric'];
  oracle_enabled: Scalars['Boolean'];
  oracle_resilient: Scalars['numeric'];
  pool_token: Scalars['String'];
  small_threshold?: Maybe<Scalars['numeric']>;
  sync_at: Scalars['timestamptz'];
  total_supply: Scalars['numeric'];
  underlying_token: Scalars['String'];
  yield_per_token?: Maybe<Scalars['numeric']>;
  yield_token: Scalars['String'];
  yield_token_price: Scalars['numeric'];
};

/** aggregated selection of "laplace.latest_yield_token_pool" */
export type LaplaceLatestYieldTokenPoolAggregate = {
  __typename?: 'laplace_latest_yield_token_pool_aggregate';
  aggregate?: Maybe<LaplaceLatestYieldTokenPoolAggregateFields>;
  nodes: Array<LaplaceLatestYieldTokenPool>;
};

/** aggregate fields of "laplace.latest_yield_token_pool" */
export type LaplaceLatestYieldTokenPoolAggregateFields = {
  __typename?: 'laplace_latest_yield_token_pool_aggregate_fields';
  avg?: Maybe<LaplaceLatestYieldTokenPoolAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceLatestYieldTokenPoolMaxFields>;
  min?: Maybe<LaplaceLatestYieldTokenPoolMinFields>;
  stddev?: Maybe<LaplaceLatestYieldTokenPoolStddevFields>;
  stddev_pop?: Maybe<LaplaceLatestYieldTokenPoolStddevPopFields>;
  stddev_samp?: Maybe<LaplaceLatestYieldTokenPoolStddevSampFields>;
  sum?: Maybe<LaplaceLatestYieldTokenPoolSumFields>;
  var_pop?: Maybe<LaplaceLatestYieldTokenPoolVarPopFields>;
  var_samp?: Maybe<LaplaceLatestYieldTokenPoolVarSampFields>;
  variance?: Maybe<LaplaceLatestYieldTokenPoolVarianceFields>;
};


/** aggregate fields of "laplace.latest_yield_token_pool" */
export type LaplaceLatestYieldTokenPoolAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceLatestYieldTokenPoolSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LaplaceLatestYieldTokenPoolAvgFields = {
  __typename?: 'laplace_latest_yield_token_pool_avg_fields';
  balance_token?: Maybe<Scalars['Float']>;
  balance_virtual?: Maybe<Scalars['Float']>;
  balance_yield_token?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  borrow_apr?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  deposit_apr?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  fee_rate_token?: Maybe<Scalars['Float']>;
  fee_rate_yield_token?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  listed?: Maybe<Scalars['Float']>;
  max_expiry?: Maybe<Scalars['Float']>;
  min_fee?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  small_threshold?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  yield_per_token?: Maybe<Scalars['Float']>;
  yield_token_price?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.latest_yield_token_pool". All fields are combined with a logical 'AND'. */
export type LaplaceLatestYieldTokenPoolBoolExp = {
  _and?: InputMaybe<Array<LaplaceLatestYieldTokenPoolBoolExp>>;
  _not?: InputMaybe<LaplaceLatestYieldTokenPoolBoolExp>;
  _or?: InputMaybe<Array<LaplaceLatestYieldTokenPoolBoolExp>>;
  balance_token?: InputMaybe<NumericComparisonExp>;
  balance_virtual?: InputMaybe<NumericComparisonExp>;
  balance_yield_token?: InputMaybe<NumericComparisonExp>;
  block_height?: InputMaybe<NumericComparisonExp>;
  borrow_apr?: InputMaybe<NumericComparisonExp>;
  burn_block_time?: InputMaybe<NumericComparisonExp>;
  deposit_apr?: InputMaybe<NumericComparisonExp>;
  expiry?: InputMaybe<NumericComparisonExp>;
  fee_rate_token?: InputMaybe<NumericComparisonExp>;
  fee_rate_yield_token?: InputMaybe<NumericComparisonExp>;
  fee_rebate?: InputMaybe<NumericComparisonExp>;
  fee_to_address?: InputMaybe<StringComparisonExp>;
  listed?: InputMaybe<NumericComparisonExp>;
  max_expiry?: InputMaybe<NumericComparisonExp>;
  min_fee?: InputMaybe<NumericComparisonExp>;
  oracle_average?: InputMaybe<NumericComparisonExp>;
  oracle_enabled?: InputMaybe<BooleanComparisonExp>;
  oracle_resilient?: InputMaybe<NumericComparisonExp>;
  pool_token?: InputMaybe<StringComparisonExp>;
  small_threshold?: InputMaybe<NumericComparisonExp>;
  sync_at?: InputMaybe<TimestamptzComparisonExp>;
  total_supply?: InputMaybe<NumericComparisonExp>;
  underlying_token?: InputMaybe<StringComparisonExp>;
  yield_per_token?: InputMaybe<NumericComparisonExp>;
  yield_token?: InputMaybe<StringComparisonExp>;
  yield_token_price?: InputMaybe<NumericComparisonExp>;
};

/** unique or primary key constraints on table "laplace.latest_yield_token_pool" */
export enum LaplaceLatestYieldTokenPoolConstraint {
  /** unique or primary key constraint on columns "expiry", "yield_token" */
  LatestYieldTokenPoolPkey = 'latest_yield_token_pool_pkey'
}

/** input type for incrementing numeric columns in table "laplace.latest_yield_token_pool" */
export type LaplaceLatestYieldTokenPoolIncInput = {
  balance_token?: InputMaybe<Scalars['numeric']>;
  balance_virtual?: InputMaybe<Scalars['numeric']>;
  balance_yield_token?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  borrow_apr?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  deposit_apr?: InputMaybe<Scalars['numeric']>;
  expiry?: InputMaybe<Scalars['numeric']>;
  fee_rate_token?: InputMaybe<Scalars['numeric']>;
  fee_rate_yield_token?: InputMaybe<Scalars['numeric']>;
  fee_rebate?: InputMaybe<Scalars['numeric']>;
  listed?: InputMaybe<Scalars['numeric']>;
  max_expiry?: InputMaybe<Scalars['numeric']>;
  min_fee?: InputMaybe<Scalars['numeric']>;
  oracle_average?: InputMaybe<Scalars['numeric']>;
  oracle_resilient?: InputMaybe<Scalars['numeric']>;
  small_threshold?: InputMaybe<Scalars['numeric']>;
  total_supply?: InputMaybe<Scalars['numeric']>;
  yield_per_token?: InputMaybe<Scalars['numeric']>;
  yield_token_price?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "laplace.latest_yield_token_pool" */
export type LaplaceLatestYieldTokenPoolInsertInput = {
  balance_token?: InputMaybe<Scalars['numeric']>;
  balance_virtual?: InputMaybe<Scalars['numeric']>;
  balance_yield_token?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  borrow_apr?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  deposit_apr?: InputMaybe<Scalars['numeric']>;
  expiry?: InputMaybe<Scalars['numeric']>;
  fee_rate_token?: InputMaybe<Scalars['numeric']>;
  fee_rate_yield_token?: InputMaybe<Scalars['numeric']>;
  fee_rebate?: InputMaybe<Scalars['numeric']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  listed?: InputMaybe<Scalars['numeric']>;
  max_expiry?: InputMaybe<Scalars['numeric']>;
  min_fee?: InputMaybe<Scalars['numeric']>;
  oracle_average?: InputMaybe<Scalars['numeric']>;
  oracle_enabled?: InputMaybe<Scalars['Boolean']>;
  oracle_resilient?: InputMaybe<Scalars['numeric']>;
  pool_token?: InputMaybe<Scalars['String']>;
  small_threshold?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  total_supply?: InputMaybe<Scalars['numeric']>;
  underlying_token?: InputMaybe<Scalars['String']>;
  yield_per_token?: InputMaybe<Scalars['numeric']>;
  yield_token?: InputMaybe<Scalars['String']>;
  yield_token_price?: InputMaybe<Scalars['numeric']>;
};

/** aggregate max on columns */
export type LaplaceLatestYieldTokenPoolMaxFields = {
  __typename?: 'laplace_latest_yield_token_pool_max_fields';
  balance_token?: Maybe<Scalars['numeric']>;
  balance_virtual?: Maybe<Scalars['numeric']>;
  balance_yield_token?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['numeric']>;
  borrow_apr?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  deposit_apr?: Maybe<Scalars['numeric']>;
  expiry?: Maybe<Scalars['numeric']>;
  fee_rate_token?: Maybe<Scalars['numeric']>;
  fee_rate_yield_token?: Maybe<Scalars['numeric']>;
  fee_rebate?: Maybe<Scalars['numeric']>;
  fee_to_address?: Maybe<Scalars['String']>;
  listed?: Maybe<Scalars['numeric']>;
  max_expiry?: Maybe<Scalars['numeric']>;
  min_fee?: Maybe<Scalars['numeric']>;
  oracle_average?: Maybe<Scalars['numeric']>;
  oracle_resilient?: Maybe<Scalars['numeric']>;
  pool_token?: Maybe<Scalars['String']>;
  small_threshold?: Maybe<Scalars['numeric']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  total_supply?: Maybe<Scalars['numeric']>;
  underlying_token?: Maybe<Scalars['String']>;
  yield_per_token?: Maybe<Scalars['numeric']>;
  yield_token?: Maybe<Scalars['String']>;
  yield_token_price?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type LaplaceLatestYieldTokenPoolMinFields = {
  __typename?: 'laplace_latest_yield_token_pool_min_fields';
  balance_token?: Maybe<Scalars['numeric']>;
  balance_virtual?: Maybe<Scalars['numeric']>;
  balance_yield_token?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['numeric']>;
  borrow_apr?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  deposit_apr?: Maybe<Scalars['numeric']>;
  expiry?: Maybe<Scalars['numeric']>;
  fee_rate_token?: Maybe<Scalars['numeric']>;
  fee_rate_yield_token?: Maybe<Scalars['numeric']>;
  fee_rebate?: Maybe<Scalars['numeric']>;
  fee_to_address?: Maybe<Scalars['String']>;
  listed?: Maybe<Scalars['numeric']>;
  max_expiry?: Maybe<Scalars['numeric']>;
  min_fee?: Maybe<Scalars['numeric']>;
  oracle_average?: Maybe<Scalars['numeric']>;
  oracle_resilient?: Maybe<Scalars['numeric']>;
  pool_token?: Maybe<Scalars['String']>;
  small_threshold?: Maybe<Scalars['numeric']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  total_supply?: Maybe<Scalars['numeric']>;
  underlying_token?: Maybe<Scalars['String']>;
  yield_per_token?: Maybe<Scalars['numeric']>;
  yield_token?: Maybe<Scalars['String']>;
  yield_token_price?: Maybe<Scalars['numeric']>;
};

/** response of any mutation on the table "laplace.latest_yield_token_pool" */
export type LaplaceLatestYieldTokenPoolMutationResponse = {
  __typename?: 'laplace_latest_yield_token_pool_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceLatestYieldTokenPool>;
};

/** on_conflict condition type for table "laplace.latest_yield_token_pool" */
export type LaplaceLatestYieldTokenPoolOnConflict = {
  constraint: LaplaceLatestYieldTokenPoolConstraint;
  update_columns?: Array<LaplaceLatestYieldTokenPoolUpdateColumn>;
  where?: InputMaybe<LaplaceLatestYieldTokenPoolBoolExp>;
};

/** Ordering options when selecting data from "laplace.latest_yield_token_pool". */
export type LaplaceLatestYieldTokenPoolOrderBy = {
  balance_token?: InputMaybe<OrderBy>;
  balance_virtual?: InputMaybe<OrderBy>;
  balance_yield_token?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  borrow_apr?: InputMaybe<OrderBy>;
  burn_block_time?: InputMaybe<OrderBy>;
  deposit_apr?: InputMaybe<OrderBy>;
  expiry?: InputMaybe<OrderBy>;
  fee_rate_token?: InputMaybe<OrderBy>;
  fee_rate_yield_token?: InputMaybe<OrderBy>;
  fee_rebate?: InputMaybe<OrderBy>;
  fee_to_address?: InputMaybe<OrderBy>;
  listed?: InputMaybe<OrderBy>;
  max_expiry?: InputMaybe<OrderBy>;
  min_fee?: InputMaybe<OrderBy>;
  oracle_average?: InputMaybe<OrderBy>;
  oracle_enabled?: InputMaybe<OrderBy>;
  oracle_resilient?: InputMaybe<OrderBy>;
  pool_token?: InputMaybe<OrderBy>;
  small_threshold?: InputMaybe<OrderBy>;
  sync_at?: InputMaybe<OrderBy>;
  total_supply?: InputMaybe<OrderBy>;
  underlying_token?: InputMaybe<OrderBy>;
  yield_per_token?: InputMaybe<OrderBy>;
  yield_token?: InputMaybe<OrderBy>;
  yield_token_price?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.latest_yield_token_pool */
export type LaplaceLatestYieldTokenPoolPkColumnsInput = {
  expiry: Scalars['numeric'];
  yield_token: Scalars['String'];
};

/** select columns of table "laplace.latest_yield_token_pool" */
export enum LaplaceLatestYieldTokenPoolSelectColumn {
  /** column name */
  BalanceToken = 'balance_token',
  /** column name */
  BalanceVirtual = 'balance_virtual',
  /** column name */
  BalanceYieldToken = 'balance_yield_token',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BorrowApr = 'borrow_apr',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  DepositApr = 'deposit_apr',
  /** column name */
  Expiry = 'expiry',
  /** column name */
  FeeRateToken = 'fee_rate_token',
  /** column name */
  FeeRateYieldToken = 'fee_rate_yield_token',
  /** column name */
  FeeRebate = 'fee_rebate',
  /** column name */
  FeeToAddress = 'fee_to_address',
  /** column name */
  Listed = 'listed',
  /** column name */
  MaxExpiry = 'max_expiry',
  /** column name */
  MinFee = 'min_fee',
  /** column name */
  OracleAverage = 'oracle_average',
  /** column name */
  OracleEnabled = 'oracle_enabled',
  /** column name */
  OracleResilient = 'oracle_resilient',
  /** column name */
  PoolToken = 'pool_token',
  /** column name */
  SmallThreshold = 'small_threshold',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TotalSupply = 'total_supply',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  YieldPerToken = 'yield_per_token',
  /** column name */
  YieldToken = 'yield_token',
  /** column name */
  YieldTokenPrice = 'yield_token_price'
}

/** input type for updating data in table "laplace.latest_yield_token_pool" */
export type LaplaceLatestYieldTokenPoolSetInput = {
  balance_token?: InputMaybe<Scalars['numeric']>;
  balance_virtual?: InputMaybe<Scalars['numeric']>;
  balance_yield_token?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  borrow_apr?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  deposit_apr?: InputMaybe<Scalars['numeric']>;
  expiry?: InputMaybe<Scalars['numeric']>;
  fee_rate_token?: InputMaybe<Scalars['numeric']>;
  fee_rate_yield_token?: InputMaybe<Scalars['numeric']>;
  fee_rebate?: InputMaybe<Scalars['numeric']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  listed?: InputMaybe<Scalars['numeric']>;
  max_expiry?: InputMaybe<Scalars['numeric']>;
  min_fee?: InputMaybe<Scalars['numeric']>;
  oracle_average?: InputMaybe<Scalars['numeric']>;
  oracle_enabled?: InputMaybe<Scalars['Boolean']>;
  oracle_resilient?: InputMaybe<Scalars['numeric']>;
  pool_token?: InputMaybe<Scalars['String']>;
  small_threshold?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  total_supply?: InputMaybe<Scalars['numeric']>;
  underlying_token?: InputMaybe<Scalars['String']>;
  yield_per_token?: InputMaybe<Scalars['numeric']>;
  yield_token?: InputMaybe<Scalars['String']>;
  yield_token_price?: InputMaybe<Scalars['numeric']>;
};

/** aggregate stddev on columns */
export type LaplaceLatestYieldTokenPoolStddevFields = {
  __typename?: 'laplace_latest_yield_token_pool_stddev_fields';
  balance_token?: Maybe<Scalars['Float']>;
  balance_virtual?: Maybe<Scalars['Float']>;
  balance_yield_token?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  borrow_apr?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  deposit_apr?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  fee_rate_token?: Maybe<Scalars['Float']>;
  fee_rate_yield_token?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  listed?: Maybe<Scalars['Float']>;
  max_expiry?: Maybe<Scalars['Float']>;
  min_fee?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  small_threshold?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  yield_per_token?: Maybe<Scalars['Float']>;
  yield_token_price?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceLatestYieldTokenPoolStddevPopFields = {
  __typename?: 'laplace_latest_yield_token_pool_stddev_pop_fields';
  balance_token?: Maybe<Scalars['Float']>;
  balance_virtual?: Maybe<Scalars['Float']>;
  balance_yield_token?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  borrow_apr?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  deposit_apr?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  fee_rate_token?: Maybe<Scalars['Float']>;
  fee_rate_yield_token?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  listed?: Maybe<Scalars['Float']>;
  max_expiry?: Maybe<Scalars['Float']>;
  min_fee?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  small_threshold?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  yield_per_token?: Maybe<Scalars['Float']>;
  yield_token_price?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceLatestYieldTokenPoolStddevSampFields = {
  __typename?: 'laplace_latest_yield_token_pool_stddev_samp_fields';
  balance_token?: Maybe<Scalars['Float']>;
  balance_virtual?: Maybe<Scalars['Float']>;
  balance_yield_token?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  borrow_apr?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  deposit_apr?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  fee_rate_token?: Maybe<Scalars['Float']>;
  fee_rate_yield_token?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  listed?: Maybe<Scalars['Float']>;
  max_expiry?: Maybe<Scalars['Float']>;
  min_fee?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  small_threshold?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  yield_per_token?: Maybe<Scalars['Float']>;
  yield_token_price?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_latest_yield_token_pool" */
export type LaplaceLatestYieldTokenPoolStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceLatestYieldTokenPoolStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceLatestYieldTokenPoolStreamCursorValueInput = {
  balance_token?: InputMaybe<Scalars['numeric']>;
  balance_virtual?: InputMaybe<Scalars['numeric']>;
  balance_yield_token?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  borrow_apr?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  deposit_apr?: InputMaybe<Scalars['numeric']>;
  expiry?: InputMaybe<Scalars['numeric']>;
  fee_rate_token?: InputMaybe<Scalars['numeric']>;
  fee_rate_yield_token?: InputMaybe<Scalars['numeric']>;
  fee_rebate?: InputMaybe<Scalars['numeric']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  listed?: InputMaybe<Scalars['numeric']>;
  max_expiry?: InputMaybe<Scalars['numeric']>;
  min_fee?: InputMaybe<Scalars['numeric']>;
  oracle_average?: InputMaybe<Scalars['numeric']>;
  oracle_enabled?: InputMaybe<Scalars['Boolean']>;
  oracle_resilient?: InputMaybe<Scalars['numeric']>;
  pool_token?: InputMaybe<Scalars['String']>;
  small_threshold?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  total_supply?: InputMaybe<Scalars['numeric']>;
  underlying_token?: InputMaybe<Scalars['String']>;
  yield_per_token?: InputMaybe<Scalars['numeric']>;
  yield_token?: InputMaybe<Scalars['String']>;
  yield_token_price?: InputMaybe<Scalars['numeric']>;
};

/** aggregate sum on columns */
export type LaplaceLatestYieldTokenPoolSumFields = {
  __typename?: 'laplace_latest_yield_token_pool_sum_fields';
  balance_token?: Maybe<Scalars['numeric']>;
  balance_virtual?: Maybe<Scalars['numeric']>;
  balance_yield_token?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['numeric']>;
  borrow_apr?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  deposit_apr?: Maybe<Scalars['numeric']>;
  expiry?: Maybe<Scalars['numeric']>;
  fee_rate_token?: Maybe<Scalars['numeric']>;
  fee_rate_yield_token?: Maybe<Scalars['numeric']>;
  fee_rebate?: Maybe<Scalars['numeric']>;
  listed?: Maybe<Scalars['numeric']>;
  max_expiry?: Maybe<Scalars['numeric']>;
  min_fee?: Maybe<Scalars['numeric']>;
  oracle_average?: Maybe<Scalars['numeric']>;
  oracle_resilient?: Maybe<Scalars['numeric']>;
  small_threshold?: Maybe<Scalars['numeric']>;
  total_supply?: Maybe<Scalars['numeric']>;
  yield_per_token?: Maybe<Scalars['numeric']>;
  yield_token_price?: Maybe<Scalars['numeric']>;
};

/** update columns of table "laplace.latest_yield_token_pool" */
export enum LaplaceLatestYieldTokenPoolUpdateColumn {
  /** column name */
  BalanceToken = 'balance_token',
  /** column name */
  BalanceVirtual = 'balance_virtual',
  /** column name */
  BalanceYieldToken = 'balance_yield_token',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BorrowApr = 'borrow_apr',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  DepositApr = 'deposit_apr',
  /** column name */
  Expiry = 'expiry',
  /** column name */
  FeeRateToken = 'fee_rate_token',
  /** column name */
  FeeRateYieldToken = 'fee_rate_yield_token',
  /** column name */
  FeeRebate = 'fee_rebate',
  /** column name */
  FeeToAddress = 'fee_to_address',
  /** column name */
  Listed = 'listed',
  /** column name */
  MaxExpiry = 'max_expiry',
  /** column name */
  MinFee = 'min_fee',
  /** column name */
  OracleAverage = 'oracle_average',
  /** column name */
  OracleEnabled = 'oracle_enabled',
  /** column name */
  OracleResilient = 'oracle_resilient',
  /** column name */
  PoolToken = 'pool_token',
  /** column name */
  SmallThreshold = 'small_threshold',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TotalSupply = 'total_supply',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  YieldPerToken = 'yield_per_token',
  /** column name */
  YieldToken = 'yield_token',
  /** column name */
  YieldTokenPrice = 'yield_token_price'
}

export type LaplaceLatestYieldTokenPoolUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceLatestYieldTokenPoolIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceLatestYieldTokenPoolSetInput>;
  where: LaplaceLatestYieldTokenPoolBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceLatestYieldTokenPoolVarPopFields = {
  __typename?: 'laplace_latest_yield_token_pool_var_pop_fields';
  balance_token?: Maybe<Scalars['Float']>;
  balance_virtual?: Maybe<Scalars['Float']>;
  balance_yield_token?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  borrow_apr?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  deposit_apr?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  fee_rate_token?: Maybe<Scalars['Float']>;
  fee_rate_yield_token?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  listed?: Maybe<Scalars['Float']>;
  max_expiry?: Maybe<Scalars['Float']>;
  min_fee?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  small_threshold?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  yield_per_token?: Maybe<Scalars['Float']>;
  yield_token_price?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceLatestYieldTokenPoolVarSampFields = {
  __typename?: 'laplace_latest_yield_token_pool_var_samp_fields';
  balance_token?: Maybe<Scalars['Float']>;
  balance_virtual?: Maybe<Scalars['Float']>;
  balance_yield_token?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  borrow_apr?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  deposit_apr?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  fee_rate_token?: Maybe<Scalars['Float']>;
  fee_rate_yield_token?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  listed?: Maybe<Scalars['Float']>;
  max_expiry?: Maybe<Scalars['Float']>;
  min_fee?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  small_threshold?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  yield_per_token?: Maybe<Scalars['Float']>;
  yield_token_price?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceLatestYieldTokenPoolVarianceFields = {
  __typename?: 'laplace_latest_yield_token_pool_variance_fields';
  balance_token?: Maybe<Scalars['Float']>;
  balance_virtual?: Maybe<Scalars['Float']>;
  balance_yield_token?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  borrow_apr?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  deposit_apr?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  fee_rate_token?: Maybe<Scalars['Float']>;
  fee_rate_yield_token?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  listed?: Maybe<Scalars['Float']>;
  max_expiry?: Maybe<Scalars['Float']>;
  min_fee?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  small_threshold?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  yield_per_token?: Maybe<Scalars['Float']>;
  yield_token_price?: Maybe<Scalars['Float']>;
};

/** ALEX oracle instant price */
export type LaplaceOracleInstantPrice = {
  __typename?: 'laplace_oracle_instant_price';
  block_height: Scalars['numeric'];
  oracle_instant: Scalars['numeric'];
  pool_token: Scalars['String'];
  sync_at: Scalars['timestamptz'];
  token: Scalars['String'];
};

/** aggregated selection of "laplace.oracle_instant_price" */
export type LaplaceOracleInstantPriceAggregate = {
  __typename?: 'laplace_oracle_instant_price_aggregate';
  aggregate?: Maybe<LaplaceOracleInstantPriceAggregateFields>;
  nodes: Array<LaplaceOracleInstantPrice>;
};

/** aggregate fields of "laplace.oracle_instant_price" */
export type LaplaceOracleInstantPriceAggregateFields = {
  __typename?: 'laplace_oracle_instant_price_aggregate_fields';
  avg?: Maybe<LaplaceOracleInstantPriceAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceOracleInstantPriceMaxFields>;
  min?: Maybe<LaplaceOracleInstantPriceMinFields>;
  stddev?: Maybe<LaplaceOracleInstantPriceStddevFields>;
  stddev_pop?: Maybe<LaplaceOracleInstantPriceStddevPopFields>;
  stddev_samp?: Maybe<LaplaceOracleInstantPriceStddevSampFields>;
  sum?: Maybe<LaplaceOracleInstantPriceSumFields>;
  var_pop?: Maybe<LaplaceOracleInstantPriceVarPopFields>;
  var_samp?: Maybe<LaplaceOracleInstantPriceVarSampFields>;
  variance?: Maybe<LaplaceOracleInstantPriceVarianceFields>;
};


/** aggregate fields of "laplace.oracle_instant_price" */
export type LaplaceOracleInstantPriceAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceOracleInstantPriceSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LaplaceOracleInstantPriceAvgFields = {
  __typename?: 'laplace_oracle_instant_price_avg_fields';
  block_height?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.oracle_instant_price". All fields are combined with a logical 'AND'. */
export type LaplaceOracleInstantPriceBoolExp = {
  _and?: InputMaybe<Array<LaplaceOracleInstantPriceBoolExp>>;
  _not?: InputMaybe<LaplaceOracleInstantPriceBoolExp>;
  _or?: InputMaybe<Array<LaplaceOracleInstantPriceBoolExp>>;
  block_height?: InputMaybe<NumericComparisonExp>;
  oracle_instant?: InputMaybe<NumericComparisonExp>;
  pool_token?: InputMaybe<StringComparisonExp>;
  sync_at?: InputMaybe<TimestamptzComparisonExp>;
  token?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "laplace.oracle_instant_price" */
export enum LaplaceOracleInstantPriceConstraint {
  /** unique or primary key constraint on columns "block_height", "pool_token", "token" */
  OracleInstantPricePkey = 'oracle_instant_price_pkey'
}

/** input type for incrementing numeric columns in table "laplace.oracle_instant_price" */
export type LaplaceOracleInstantPriceIncInput = {
  block_height?: InputMaybe<Scalars['numeric']>;
  oracle_instant?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "laplace.oracle_instant_price" */
export type LaplaceOracleInstantPriceInsertInput = {
  block_height?: InputMaybe<Scalars['numeric']>;
  oracle_instant?: InputMaybe<Scalars['numeric']>;
  pool_token?: InputMaybe<Scalars['String']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type LaplaceOracleInstantPriceMaxFields = {
  __typename?: 'laplace_oracle_instant_price_max_fields';
  block_height?: Maybe<Scalars['numeric']>;
  oracle_instant?: Maybe<Scalars['numeric']>;
  pool_token?: Maybe<Scalars['String']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LaplaceOracleInstantPriceMinFields = {
  __typename?: 'laplace_oracle_instant_price_min_fields';
  block_height?: Maybe<Scalars['numeric']>;
  oracle_instant?: Maybe<Scalars['numeric']>;
  pool_token?: Maybe<Scalars['String']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "laplace.oracle_instant_price" */
export type LaplaceOracleInstantPriceMutationResponse = {
  __typename?: 'laplace_oracle_instant_price_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceOracleInstantPrice>;
};

/** on_conflict condition type for table "laplace.oracle_instant_price" */
export type LaplaceOracleInstantPriceOnConflict = {
  constraint: LaplaceOracleInstantPriceConstraint;
  update_columns?: Array<LaplaceOracleInstantPriceUpdateColumn>;
  where?: InputMaybe<LaplaceOracleInstantPriceBoolExp>;
};

/** Ordering options when selecting data from "laplace.oracle_instant_price". */
export type LaplaceOracleInstantPriceOrderBy = {
  block_height?: InputMaybe<OrderBy>;
  oracle_instant?: InputMaybe<OrderBy>;
  pool_token?: InputMaybe<OrderBy>;
  sync_at?: InputMaybe<OrderBy>;
  token?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.oracle_instant_price */
export type LaplaceOracleInstantPricePkColumnsInput = {
  block_height: Scalars['numeric'];
  pool_token: Scalars['String'];
  token: Scalars['String'];
};

/** select columns of table "laplace.oracle_instant_price" */
export enum LaplaceOracleInstantPriceSelectColumn {
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  OracleInstant = 'oracle_instant',
  /** column name */
  PoolToken = 'pool_token',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  Token = 'token'
}

/** input type for updating data in table "laplace.oracle_instant_price" */
export type LaplaceOracleInstantPriceSetInput = {
  block_height?: InputMaybe<Scalars['numeric']>;
  oracle_instant?: InputMaybe<Scalars['numeric']>;
  pool_token?: InputMaybe<Scalars['String']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type LaplaceOracleInstantPriceStddevFields = {
  __typename?: 'laplace_oracle_instant_price_stddev_fields';
  block_height?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceOracleInstantPriceStddevPopFields = {
  __typename?: 'laplace_oracle_instant_price_stddev_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceOracleInstantPriceStddevSampFields = {
  __typename?: 'laplace_oracle_instant_price_stddev_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_oracle_instant_price" */
export type LaplaceOracleInstantPriceStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceOracleInstantPriceStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceOracleInstantPriceStreamCursorValueInput = {
  block_height?: InputMaybe<Scalars['numeric']>;
  oracle_instant?: InputMaybe<Scalars['numeric']>;
  pool_token?: InputMaybe<Scalars['String']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type LaplaceOracleInstantPriceSumFields = {
  __typename?: 'laplace_oracle_instant_price_sum_fields';
  block_height?: Maybe<Scalars['numeric']>;
  oracle_instant?: Maybe<Scalars['numeric']>;
};

/** update columns of table "laplace.oracle_instant_price" */
export enum LaplaceOracleInstantPriceUpdateColumn {
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  OracleInstant = 'oracle_instant',
  /** column name */
  PoolToken = 'pool_token',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  Token = 'token'
}

export type LaplaceOracleInstantPriceUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceOracleInstantPriceIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceOracleInstantPriceSetInput>;
  where: LaplaceOracleInstantPriceBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceOracleInstantPriceVarPopFields = {
  __typename?: 'laplace_oracle_instant_price_var_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceOracleInstantPriceVarSampFields = {
  __typename?: 'laplace_oracle_instant_price_var_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceOracleInstantPriceVarianceFields = {
  __typename?: 'laplace_oracle_instant_price_variance_fields';
  block_height?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
};

/** ALEX oracle resilient price */
export type LaplaceOracleResilientPrice = {
  __typename?: 'laplace_oracle_resilient_price';
  block_height: Scalars['numeric'];
  oracle_resilient: Scalars['numeric'];
  pool_token: Scalars['String'];
  sync_at: Scalars['timestamptz'];
  token: Scalars['String'];
};

/** aggregated selection of "laplace.oracle_resilient_price" */
export type LaplaceOracleResilientPriceAggregate = {
  __typename?: 'laplace_oracle_resilient_price_aggregate';
  aggregate?: Maybe<LaplaceOracleResilientPriceAggregateFields>;
  nodes: Array<LaplaceOracleResilientPrice>;
};

/** aggregate fields of "laplace.oracle_resilient_price" */
export type LaplaceOracleResilientPriceAggregateFields = {
  __typename?: 'laplace_oracle_resilient_price_aggregate_fields';
  avg?: Maybe<LaplaceOracleResilientPriceAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceOracleResilientPriceMaxFields>;
  min?: Maybe<LaplaceOracleResilientPriceMinFields>;
  stddev?: Maybe<LaplaceOracleResilientPriceStddevFields>;
  stddev_pop?: Maybe<LaplaceOracleResilientPriceStddevPopFields>;
  stddev_samp?: Maybe<LaplaceOracleResilientPriceStddevSampFields>;
  sum?: Maybe<LaplaceOracleResilientPriceSumFields>;
  var_pop?: Maybe<LaplaceOracleResilientPriceVarPopFields>;
  var_samp?: Maybe<LaplaceOracleResilientPriceVarSampFields>;
  variance?: Maybe<LaplaceOracleResilientPriceVarianceFields>;
};


/** aggregate fields of "laplace.oracle_resilient_price" */
export type LaplaceOracleResilientPriceAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceOracleResilientPriceSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LaplaceOracleResilientPriceAvgFields = {
  __typename?: 'laplace_oracle_resilient_price_avg_fields';
  block_height?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.oracle_resilient_price". All fields are combined with a logical 'AND'. */
export type LaplaceOracleResilientPriceBoolExp = {
  _and?: InputMaybe<Array<LaplaceOracleResilientPriceBoolExp>>;
  _not?: InputMaybe<LaplaceOracleResilientPriceBoolExp>;
  _or?: InputMaybe<Array<LaplaceOracleResilientPriceBoolExp>>;
  block_height?: InputMaybe<NumericComparisonExp>;
  oracle_resilient?: InputMaybe<NumericComparisonExp>;
  pool_token?: InputMaybe<StringComparisonExp>;
  sync_at?: InputMaybe<TimestamptzComparisonExp>;
  token?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "laplace.oracle_resilient_price" */
export enum LaplaceOracleResilientPriceConstraint {
  /** unique or primary key constraint on columns "block_height", "pool_token", "token" */
  OracleResilientPricePkey = 'oracle_resilient_price_pkey'
}

/** input type for incrementing numeric columns in table "laplace.oracle_resilient_price" */
export type LaplaceOracleResilientPriceIncInput = {
  block_height?: InputMaybe<Scalars['numeric']>;
  oracle_resilient?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "laplace.oracle_resilient_price" */
export type LaplaceOracleResilientPriceInsertInput = {
  block_height?: InputMaybe<Scalars['numeric']>;
  oracle_resilient?: InputMaybe<Scalars['numeric']>;
  pool_token?: InputMaybe<Scalars['String']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type LaplaceOracleResilientPriceMaxFields = {
  __typename?: 'laplace_oracle_resilient_price_max_fields';
  block_height?: Maybe<Scalars['numeric']>;
  oracle_resilient?: Maybe<Scalars['numeric']>;
  pool_token?: Maybe<Scalars['String']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LaplaceOracleResilientPriceMinFields = {
  __typename?: 'laplace_oracle_resilient_price_min_fields';
  block_height?: Maybe<Scalars['numeric']>;
  oracle_resilient?: Maybe<Scalars['numeric']>;
  pool_token?: Maybe<Scalars['String']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "laplace.oracle_resilient_price" */
export type LaplaceOracleResilientPriceMutationResponse = {
  __typename?: 'laplace_oracle_resilient_price_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceOracleResilientPrice>;
};

/** on_conflict condition type for table "laplace.oracle_resilient_price" */
export type LaplaceOracleResilientPriceOnConflict = {
  constraint: LaplaceOracleResilientPriceConstraint;
  update_columns?: Array<LaplaceOracleResilientPriceUpdateColumn>;
  where?: InputMaybe<LaplaceOracleResilientPriceBoolExp>;
};

/** Ordering options when selecting data from "laplace.oracle_resilient_price". */
export type LaplaceOracleResilientPriceOrderBy = {
  block_height?: InputMaybe<OrderBy>;
  oracle_resilient?: InputMaybe<OrderBy>;
  pool_token?: InputMaybe<OrderBy>;
  sync_at?: InputMaybe<OrderBy>;
  token?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.oracle_resilient_price */
export type LaplaceOracleResilientPricePkColumnsInput = {
  block_height: Scalars['numeric'];
  pool_token: Scalars['String'];
  token: Scalars['String'];
};

/** select columns of table "laplace.oracle_resilient_price" */
export enum LaplaceOracleResilientPriceSelectColumn {
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  OracleResilient = 'oracle_resilient',
  /** column name */
  PoolToken = 'pool_token',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  Token = 'token'
}

/** input type for updating data in table "laplace.oracle_resilient_price" */
export type LaplaceOracleResilientPriceSetInput = {
  block_height?: InputMaybe<Scalars['numeric']>;
  oracle_resilient?: InputMaybe<Scalars['numeric']>;
  pool_token?: InputMaybe<Scalars['String']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type LaplaceOracleResilientPriceStddevFields = {
  __typename?: 'laplace_oracle_resilient_price_stddev_fields';
  block_height?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceOracleResilientPriceStddevPopFields = {
  __typename?: 'laplace_oracle_resilient_price_stddev_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceOracleResilientPriceStddevSampFields = {
  __typename?: 'laplace_oracle_resilient_price_stddev_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_oracle_resilient_price" */
export type LaplaceOracleResilientPriceStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceOracleResilientPriceStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceOracleResilientPriceStreamCursorValueInput = {
  block_height?: InputMaybe<Scalars['numeric']>;
  oracle_resilient?: InputMaybe<Scalars['numeric']>;
  pool_token?: InputMaybe<Scalars['String']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type LaplaceOracleResilientPriceSumFields = {
  __typename?: 'laplace_oracle_resilient_price_sum_fields';
  block_height?: Maybe<Scalars['numeric']>;
  oracle_resilient?: Maybe<Scalars['numeric']>;
};

/** update columns of table "laplace.oracle_resilient_price" */
export enum LaplaceOracleResilientPriceUpdateColumn {
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  OracleResilient = 'oracle_resilient',
  /** column name */
  PoolToken = 'pool_token',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  Token = 'token'
}

export type LaplaceOracleResilientPriceUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceOracleResilientPriceIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceOracleResilientPriceSetInput>;
  where: LaplaceOracleResilientPriceBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceOracleResilientPriceVarPopFields = {
  __typename?: 'laplace_oracle_resilient_price_var_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceOracleResilientPriceVarSampFields = {
  __typename?: 'laplace_oracle_resilient_price_var_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceOracleResilientPriceVarianceFields = {
  __typename?: 'laplace_oracle_resilient_price_variance_fields';
  block_height?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "laplace.oracle_token_price" */
export type LaplaceOracleTokenPrice = {
  __typename?: 'laplace_oracle_token_price';
  avg_price_usd?: Maybe<Scalars['float8']>;
  token?: Maybe<Scalars['String']>;
};

/** aggregated selection of "laplace.oracle_token_price" */
export type LaplaceOracleTokenPriceAggregate = {
  __typename?: 'laplace_oracle_token_price_aggregate';
  aggregate?: Maybe<LaplaceOracleTokenPriceAggregateFields>;
  nodes: Array<LaplaceOracleTokenPrice>;
};

/** aggregate fields of "laplace.oracle_token_price" */
export type LaplaceOracleTokenPriceAggregateFields = {
  __typename?: 'laplace_oracle_token_price_aggregate_fields';
  avg?: Maybe<LaplaceOracleTokenPriceAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceOracleTokenPriceMaxFields>;
  min?: Maybe<LaplaceOracleTokenPriceMinFields>;
  stddev?: Maybe<LaplaceOracleTokenPriceStddevFields>;
  stddev_pop?: Maybe<LaplaceOracleTokenPriceStddevPopFields>;
  stddev_samp?: Maybe<LaplaceOracleTokenPriceStddevSampFields>;
  sum?: Maybe<LaplaceOracleTokenPriceSumFields>;
  var_pop?: Maybe<LaplaceOracleTokenPriceVarPopFields>;
  var_samp?: Maybe<LaplaceOracleTokenPriceVarSampFields>;
  variance?: Maybe<LaplaceOracleTokenPriceVarianceFields>;
};


/** aggregate fields of "laplace.oracle_token_price" */
export type LaplaceOracleTokenPriceAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceOracleTokenPriceSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LaplaceOracleTokenPriceAvgFields = {
  __typename?: 'laplace_oracle_token_price_avg_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.oracle_token_price". All fields are combined with a logical 'AND'. */
export type LaplaceOracleTokenPriceBoolExp = {
  _and?: InputMaybe<Array<LaplaceOracleTokenPriceBoolExp>>;
  _not?: InputMaybe<LaplaceOracleTokenPriceBoolExp>;
  _or?: InputMaybe<Array<LaplaceOracleTokenPriceBoolExp>>;
  avg_price_usd?: InputMaybe<Float8ComparisonExp>;
  token?: InputMaybe<StringComparisonExp>;
};

/** aggregate max on columns */
export type LaplaceOracleTokenPriceMaxFields = {
  __typename?: 'laplace_oracle_token_price_max_fields';
  avg_price_usd?: Maybe<Scalars['float8']>;
  token?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LaplaceOracleTokenPriceMinFields = {
  __typename?: 'laplace_oracle_token_price_min_fields';
  avg_price_usd?: Maybe<Scalars['float8']>;
  token?: Maybe<Scalars['String']>;
};

/** Ordering options when selecting data from "laplace.oracle_token_price". */
export type LaplaceOracleTokenPriceOrderBy = {
  avg_price_usd?: InputMaybe<OrderBy>;
  token?: InputMaybe<OrderBy>;
};

/** columns and relationships of "laplace.oracle_token_price_resilient" */
export type LaplaceOracleTokenPriceResilient = {
  __typename?: 'laplace_oracle_token_price_resilient';
  avg_price_usd?: Maybe<Scalars['float8']>;
  token?: Maybe<Scalars['String']>;
};

/** aggregated selection of "laplace.oracle_token_price_resilient" */
export type LaplaceOracleTokenPriceResilientAggregate = {
  __typename?: 'laplace_oracle_token_price_resilient_aggregate';
  aggregate?: Maybe<LaplaceOracleTokenPriceResilientAggregateFields>;
  nodes: Array<LaplaceOracleTokenPriceResilient>;
};

/** aggregate fields of "laplace.oracle_token_price_resilient" */
export type LaplaceOracleTokenPriceResilientAggregateFields = {
  __typename?: 'laplace_oracle_token_price_resilient_aggregate_fields';
  avg?: Maybe<LaplaceOracleTokenPriceResilientAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceOracleTokenPriceResilientMaxFields>;
  min?: Maybe<LaplaceOracleTokenPriceResilientMinFields>;
  stddev?: Maybe<LaplaceOracleTokenPriceResilientStddevFields>;
  stddev_pop?: Maybe<LaplaceOracleTokenPriceResilientStddevPopFields>;
  stddev_samp?: Maybe<LaplaceOracleTokenPriceResilientStddevSampFields>;
  sum?: Maybe<LaplaceOracleTokenPriceResilientSumFields>;
  var_pop?: Maybe<LaplaceOracleTokenPriceResilientVarPopFields>;
  var_samp?: Maybe<LaplaceOracleTokenPriceResilientVarSampFields>;
  variance?: Maybe<LaplaceOracleTokenPriceResilientVarianceFields>;
};


/** aggregate fields of "laplace.oracle_token_price_resilient" */
export type LaplaceOracleTokenPriceResilientAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceOracleTokenPriceResilientSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LaplaceOracleTokenPriceResilientAvgFields = {
  __typename?: 'laplace_oracle_token_price_resilient_avg_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.oracle_token_price_resilient". All fields are combined with a logical 'AND'. */
export type LaplaceOracleTokenPriceResilientBoolExp = {
  _and?: InputMaybe<Array<LaplaceOracleTokenPriceResilientBoolExp>>;
  _not?: InputMaybe<LaplaceOracleTokenPriceResilientBoolExp>;
  _or?: InputMaybe<Array<LaplaceOracleTokenPriceResilientBoolExp>>;
  avg_price_usd?: InputMaybe<Float8ComparisonExp>;
  token?: InputMaybe<StringComparisonExp>;
};

/** aggregate max on columns */
export type LaplaceOracleTokenPriceResilientMaxFields = {
  __typename?: 'laplace_oracle_token_price_resilient_max_fields';
  avg_price_usd?: Maybe<Scalars['float8']>;
  token?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LaplaceOracleTokenPriceResilientMinFields = {
  __typename?: 'laplace_oracle_token_price_resilient_min_fields';
  avg_price_usd?: Maybe<Scalars['float8']>;
  token?: Maybe<Scalars['String']>;
};

/** Ordering options when selecting data from "laplace.oracle_token_price_resilient". */
export type LaplaceOracleTokenPriceResilientOrderBy = {
  avg_price_usd?: InputMaybe<OrderBy>;
  token?: InputMaybe<OrderBy>;
};

/** select columns of table "laplace.oracle_token_price_resilient" */
export enum LaplaceOracleTokenPriceResilientSelectColumn {
  /** column name */
  AvgPriceUsd = 'avg_price_usd',
  /** column name */
  Token = 'token'
}

/** aggregate stddev on columns */
export type LaplaceOracleTokenPriceResilientStddevFields = {
  __typename?: 'laplace_oracle_token_price_resilient_stddev_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceOracleTokenPriceResilientStddevPopFields = {
  __typename?: 'laplace_oracle_token_price_resilient_stddev_pop_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceOracleTokenPriceResilientStddevSampFields = {
  __typename?: 'laplace_oracle_token_price_resilient_stddev_samp_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_oracle_token_price_resilient" */
export type LaplaceOracleTokenPriceResilientStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceOracleTokenPriceResilientStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceOracleTokenPriceResilientStreamCursorValueInput = {
  avg_price_usd?: InputMaybe<Scalars['float8']>;
  token?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type LaplaceOracleTokenPriceResilientSumFields = {
  __typename?: 'laplace_oracle_token_price_resilient_sum_fields';
  avg_price_usd?: Maybe<Scalars['float8']>;
};

/** aggregate var_pop on columns */
export type LaplaceOracleTokenPriceResilientVarPopFields = {
  __typename?: 'laplace_oracle_token_price_resilient_var_pop_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceOracleTokenPriceResilientVarSampFields = {
  __typename?: 'laplace_oracle_token_price_resilient_var_samp_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceOracleTokenPriceResilientVarianceFields = {
  __typename?: 'laplace_oracle_token_price_resilient_variance_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** select columns of table "laplace.oracle_token_price" */
export enum LaplaceOracleTokenPriceSelectColumn {
  /** column name */
  AvgPriceUsd = 'avg_price_usd',
  /** column name */
  Token = 'token'
}

/** aggregate stddev on columns */
export type LaplaceOracleTokenPriceStddevFields = {
  __typename?: 'laplace_oracle_token_price_stddev_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceOracleTokenPriceStddevPopFields = {
  __typename?: 'laplace_oracle_token_price_stddev_pop_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceOracleTokenPriceStddevSampFields = {
  __typename?: 'laplace_oracle_token_price_stddev_samp_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_oracle_token_price" */
export type LaplaceOracleTokenPriceStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceOracleTokenPriceStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceOracleTokenPriceStreamCursorValueInput = {
  avg_price_usd?: InputMaybe<Scalars['float8']>;
  token?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type LaplaceOracleTokenPriceSumFields = {
  __typename?: 'laplace_oracle_token_price_sum_fields';
  avg_price_usd?: Maybe<Scalars['float8']>;
};

/** aggregate var_pop on columns */
export type LaplaceOracleTokenPriceVarPopFields = {
  __typename?: 'laplace_oracle_token_price_var_pop_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceOracleTokenPriceVarSampFields = {
  __typename?: 'laplace_oracle_token_price_var_samp_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceOracleTokenPriceVarianceFields = {
  __typename?: 'laplace_oracle_token_price_variance_fields';
  avg_price_usd?: Maybe<Scalars['Float']>;
};

/** ALEX pool status  */
export type LaplacePoolStats = {
  __typename?: 'laplace_pool_stats';
  apr_7d: Scalars['numeric'];
  balance_x: Scalars['numeric'];
  balance_y: Scalars['numeric'];
  block_height: Scalars['numeric'];
  burn_block_time: Scalars['numeric'];
  est_pool_token_price: Scalars['bigint'];
  est_token_y_price: Scalars['bigint'];
  fee_rate_x: Scalars['numeric'];
  fee_rate_y: Scalars['numeric'];
  fee_rebate: Scalars['numeric'];
  fee_rebate_7d: Scalars['numeric'];
  fee_rebate_24h: Scalars['numeric'];
  fee_rebate_x_7d: Scalars['numeric'];
  fee_rebate_x_24h: Scalars['numeric'];
  fee_rebate_y_7d: Scalars['numeric'];
  fee_rebate_y_24h: Scalars['numeric'];
  fee_to_address: Scalars['String'];
  latest_oracle_resilient: Scalars['bigint'];
  liquidity: Scalars['numeric'];
  oracle_average: Scalars['bigint'];
  oracle_enabled: Scalars['bigint'];
  oracle_instant: Scalars['bigint'];
  oracle_resilient: Scalars['bigint'];
  pool_token: Scalars['String'];
  sync_at: Scalars['timestamptz'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
  total_supply: Scalars['numeric'];
  volume_7d: Scalars['numeric'];
  volume_24h: Scalars['numeric'];
  volume_x_7d: Scalars['numeric'];
  volume_x_24h: Scalars['numeric'];
  volume_y_7d: Scalars['numeric'];
  volume_y_24h: Scalars['numeric'];
};

/** aggregated selection of "laplace.pool_stats" */
export type LaplacePoolStatsAggregate = {
  __typename?: 'laplace_pool_stats_aggregate';
  aggregate?: Maybe<LaplacePoolStatsAggregateFields>;
  nodes: Array<LaplacePoolStats>;
};

/** aggregate fields of "laplace.pool_stats" */
export type LaplacePoolStatsAggregateFields = {
  __typename?: 'laplace_pool_stats_aggregate_fields';
  avg?: Maybe<LaplacePoolStatsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplacePoolStatsMaxFields>;
  min?: Maybe<LaplacePoolStatsMinFields>;
  stddev?: Maybe<LaplacePoolStatsStddevFields>;
  stddev_pop?: Maybe<LaplacePoolStatsStddevPopFields>;
  stddev_samp?: Maybe<LaplacePoolStatsStddevSampFields>;
  sum?: Maybe<LaplacePoolStatsSumFields>;
  var_pop?: Maybe<LaplacePoolStatsVarPopFields>;
  var_samp?: Maybe<LaplacePoolStatsVarSampFields>;
  variance?: Maybe<LaplacePoolStatsVarianceFields>;
};


/** aggregate fields of "laplace.pool_stats" */
export type LaplacePoolStatsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplacePoolStatsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LaplacePoolStatsAvgFields = {
  __typename?: 'laplace_pool_stats_avg_fields';
  apr_7d?: Maybe<Scalars['Float']>;
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  fee_rebate_7d?: Maybe<Scalars['Float']>;
  fee_rebate_24h?: Maybe<Scalars['Float']>;
  fee_rebate_x_7d?: Maybe<Scalars['Float']>;
  fee_rebate_x_24h?: Maybe<Scalars['Float']>;
  fee_rebate_y_7d?: Maybe<Scalars['Float']>;
  fee_rebate_y_24h?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  liquidity?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_enabled?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  volume_7d?: Maybe<Scalars['Float']>;
  volume_24h?: Maybe<Scalars['Float']>;
  volume_x_7d?: Maybe<Scalars['Float']>;
  volume_x_24h?: Maybe<Scalars['Float']>;
  volume_y_7d?: Maybe<Scalars['Float']>;
  volume_y_24h?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.pool_stats". All fields are combined with a logical 'AND'. */
export type LaplacePoolStatsBoolExp = {
  _and?: InputMaybe<Array<LaplacePoolStatsBoolExp>>;
  _not?: InputMaybe<LaplacePoolStatsBoolExp>;
  _or?: InputMaybe<Array<LaplacePoolStatsBoolExp>>;
  apr_7d?: InputMaybe<NumericComparisonExp>;
  balance_x?: InputMaybe<NumericComparisonExp>;
  balance_y?: InputMaybe<NumericComparisonExp>;
  block_height?: InputMaybe<NumericComparisonExp>;
  burn_block_time?: InputMaybe<NumericComparisonExp>;
  est_pool_token_price?: InputMaybe<BigintComparisonExp>;
  est_token_y_price?: InputMaybe<BigintComparisonExp>;
  fee_rate_x?: InputMaybe<NumericComparisonExp>;
  fee_rate_y?: InputMaybe<NumericComparisonExp>;
  fee_rebate?: InputMaybe<NumericComparisonExp>;
  fee_rebate_7d?: InputMaybe<NumericComparisonExp>;
  fee_rebate_24h?: InputMaybe<NumericComparisonExp>;
  fee_rebate_x_7d?: InputMaybe<NumericComparisonExp>;
  fee_rebate_x_24h?: InputMaybe<NumericComparisonExp>;
  fee_rebate_y_7d?: InputMaybe<NumericComparisonExp>;
  fee_rebate_y_24h?: InputMaybe<NumericComparisonExp>;
  fee_to_address?: InputMaybe<StringComparisonExp>;
  latest_oracle_resilient?: InputMaybe<BigintComparisonExp>;
  liquidity?: InputMaybe<NumericComparisonExp>;
  oracle_average?: InputMaybe<BigintComparisonExp>;
  oracle_enabled?: InputMaybe<BigintComparisonExp>;
  oracle_instant?: InputMaybe<BigintComparisonExp>;
  oracle_resilient?: InputMaybe<BigintComparisonExp>;
  pool_token?: InputMaybe<StringComparisonExp>;
  sync_at?: InputMaybe<TimestamptzComparisonExp>;
  token_x?: InputMaybe<StringComparisonExp>;
  token_y?: InputMaybe<StringComparisonExp>;
  total_supply?: InputMaybe<NumericComparisonExp>;
  volume_7d?: InputMaybe<NumericComparisonExp>;
  volume_24h?: InputMaybe<NumericComparisonExp>;
  volume_x_7d?: InputMaybe<NumericComparisonExp>;
  volume_x_24h?: InputMaybe<NumericComparisonExp>;
  volume_y_7d?: InputMaybe<NumericComparisonExp>;
  volume_y_24h?: InputMaybe<NumericComparisonExp>;
};

/** unique or primary key constraints on table "laplace.pool_stats" */
export enum LaplacePoolStatsConstraint {
  /** unique or primary key constraint on columns "block_height", "pool_token" */
  PoolStatsPkey = 'pool_stats_pkey'
}

/** input type for incrementing numeric columns in table "laplace.pool_stats" */
export type LaplacePoolStatsIncInput = {
  apr_7d?: InputMaybe<Scalars['numeric']>;
  balance_x?: InputMaybe<Scalars['numeric']>;
  balance_y?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  est_pool_token_price?: InputMaybe<Scalars['bigint']>;
  est_token_y_price?: InputMaybe<Scalars['bigint']>;
  fee_rate_x?: InputMaybe<Scalars['numeric']>;
  fee_rate_y?: InputMaybe<Scalars['numeric']>;
  fee_rebate?: InputMaybe<Scalars['numeric']>;
  fee_rebate_7d?: InputMaybe<Scalars['numeric']>;
  fee_rebate_24h?: InputMaybe<Scalars['numeric']>;
  fee_rebate_x_7d?: InputMaybe<Scalars['numeric']>;
  fee_rebate_x_24h?: InputMaybe<Scalars['numeric']>;
  fee_rebate_y_7d?: InputMaybe<Scalars['numeric']>;
  fee_rebate_y_24h?: InputMaybe<Scalars['numeric']>;
  latest_oracle_resilient?: InputMaybe<Scalars['bigint']>;
  liquidity?: InputMaybe<Scalars['numeric']>;
  oracle_average?: InputMaybe<Scalars['bigint']>;
  oracle_enabled?: InputMaybe<Scalars['bigint']>;
  oracle_instant?: InputMaybe<Scalars['bigint']>;
  oracle_resilient?: InputMaybe<Scalars['bigint']>;
  total_supply?: InputMaybe<Scalars['numeric']>;
  volume_7d?: InputMaybe<Scalars['numeric']>;
  volume_24h?: InputMaybe<Scalars['numeric']>;
  volume_x_7d?: InputMaybe<Scalars['numeric']>;
  volume_x_24h?: InputMaybe<Scalars['numeric']>;
  volume_y_7d?: InputMaybe<Scalars['numeric']>;
  volume_y_24h?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "laplace.pool_stats" */
export type LaplacePoolStatsInsertInput = {
  apr_7d?: InputMaybe<Scalars['numeric']>;
  balance_x?: InputMaybe<Scalars['numeric']>;
  balance_y?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  est_pool_token_price?: InputMaybe<Scalars['bigint']>;
  est_token_y_price?: InputMaybe<Scalars['bigint']>;
  fee_rate_x?: InputMaybe<Scalars['numeric']>;
  fee_rate_y?: InputMaybe<Scalars['numeric']>;
  fee_rebate?: InputMaybe<Scalars['numeric']>;
  fee_rebate_7d?: InputMaybe<Scalars['numeric']>;
  fee_rebate_24h?: InputMaybe<Scalars['numeric']>;
  fee_rebate_x_7d?: InputMaybe<Scalars['numeric']>;
  fee_rebate_x_24h?: InputMaybe<Scalars['numeric']>;
  fee_rebate_y_7d?: InputMaybe<Scalars['numeric']>;
  fee_rebate_y_24h?: InputMaybe<Scalars['numeric']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  latest_oracle_resilient?: InputMaybe<Scalars['bigint']>;
  liquidity?: InputMaybe<Scalars['numeric']>;
  oracle_average?: InputMaybe<Scalars['bigint']>;
  oracle_enabled?: InputMaybe<Scalars['bigint']>;
  oracle_instant?: InputMaybe<Scalars['bigint']>;
  oracle_resilient?: InputMaybe<Scalars['bigint']>;
  pool_token?: InputMaybe<Scalars['String']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  total_supply?: InputMaybe<Scalars['numeric']>;
  volume_7d?: InputMaybe<Scalars['numeric']>;
  volume_24h?: InputMaybe<Scalars['numeric']>;
  volume_x_7d?: InputMaybe<Scalars['numeric']>;
  volume_x_24h?: InputMaybe<Scalars['numeric']>;
  volume_y_7d?: InputMaybe<Scalars['numeric']>;
  volume_y_24h?: InputMaybe<Scalars['numeric']>;
};

/** aggregate max on columns */
export type LaplacePoolStatsMaxFields = {
  __typename?: 'laplace_pool_stats_max_fields';
  apr_7d?: Maybe<Scalars['numeric']>;
  balance_x?: Maybe<Scalars['numeric']>;
  balance_y?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  est_pool_token_price?: Maybe<Scalars['bigint']>;
  est_token_y_price?: Maybe<Scalars['bigint']>;
  fee_rate_x?: Maybe<Scalars['numeric']>;
  fee_rate_y?: Maybe<Scalars['numeric']>;
  fee_rebate?: Maybe<Scalars['numeric']>;
  fee_rebate_7d?: Maybe<Scalars['numeric']>;
  fee_rebate_24h?: Maybe<Scalars['numeric']>;
  fee_rebate_x_7d?: Maybe<Scalars['numeric']>;
  fee_rebate_x_24h?: Maybe<Scalars['numeric']>;
  fee_rebate_y_7d?: Maybe<Scalars['numeric']>;
  fee_rebate_y_24h?: Maybe<Scalars['numeric']>;
  fee_to_address?: Maybe<Scalars['String']>;
  latest_oracle_resilient?: Maybe<Scalars['bigint']>;
  liquidity?: Maybe<Scalars['numeric']>;
  oracle_average?: Maybe<Scalars['bigint']>;
  oracle_enabled?: Maybe<Scalars['bigint']>;
  oracle_instant?: Maybe<Scalars['bigint']>;
  oracle_resilient?: Maybe<Scalars['bigint']>;
  pool_token?: Maybe<Scalars['String']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_x?: Maybe<Scalars['String']>;
  token_y?: Maybe<Scalars['String']>;
  total_supply?: Maybe<Scalars['numeric']>;
  volume_7d?: Maybe<Scalars['numeric']>;
  volume_24h?: Maybe<Scalars['numeric']>;
  volume_x_7d?: Maybe<Scalars['numeric']>;
  volume_x_24h?: Maybe<Scalars['numeric']>;
  volume_y_7d?: Maybe<Scalars['numeric']>;
  volume_y_24h?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type LaplacePoolStatsMinFields = {
  __typename?: 'laplace_pool_stats_min_fields';
  apr_7d?: Maybe<Scalars['numeric']>;
  balance_x?: Maybe<Scalars['numeric']>;
  balance_y?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  est_pool_token_price?: Maybe<Scalars['bigint']>;
  est_token_y_price?: Maybe<Scalars['bigint']>;
  fee_rate_x?: Maybe<Scalars['numeric']>;
  fee_rate_y?: Maybe<Scalars['numeric']>;
  fee_rebate?: Maybe<Scalars['numeric']>;
  fee_rebate_7d?: Maybe<Scalars['numeric']>;
  fee_rebate_24h?: Maybe<Scalars['numeric']>;
  fee_rebate_x_7d?: Maybe<Scalars['numeric']>;
  fee_rebate_x_24h?: Maybe<Scalars['numeric']>;
  fee_rebate_y_7d?: Maybe<Scalars['numeric']>;
  fee_rebate_y_24h?: Maybe<Scalars['numeric']>;
  fee_to_address?: Maybe<Scalars['String']>;
  latest_oracle_resilient?: Maybe<Scalars['bigint']>;
  liquidity?: Maybe<Scalars['numeric']>;
  oracle_average?: Maybe<Scalars['bigint']>;
  oracle_enabled?: Maybe<Scalars['bigint']>;
  oracle_instant?: Maybe<Scalars['bigint']>;
  oracle_resilient?: Maybe<Scalars['bigint']>;
  pool_token?: Maybe<Scalars['String']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_x?: Maybe<Scalars['String']>;
  token_y?: Maybe<Scalars['String']>;
  total_supply?: Maybe<Scalars['numeric']>;
  volume_7d?: Maybe<Scalars['numeric']>;
  volume_24h?: Maybe<Scalars['numeric']>;
  volume_x_7d?: Maybe<Scalars['numeric']>;
  volume_x_24h?: Maybe<Scalars['numeric']>;
  volume_y_7d?: Maybe<Scalars['numeric']>;
  volume_y_24h?: Maybe<Scalars['numeric']>;
};

/** response of any mutation on the table "laplace.pool_stats" */
export type LaplacePoolStatsMutationResponse = {
  __typename?: 'laplace_pool_stats_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplacePoolStats>;
};

/** on_conflict condition type for table "laplace.pool_stats" */
export type LaplacePoolStatsOnConflict = {
  constraint: LaplacePoolStatsConstraint;
  update_columns?: Array<LaplacePoolStatsUpdateColumn>;
  where?: InputMaybe<LaplacePoolStatsBoolExp>;
};

/** Ordering options when selecting data from "laplace.pool_stats". */
export type LaplacePoolStatsOrderBy = {
  apr_7d?: InputMaybe<OrderBy>;
  balance_x?: InputMaybe<OrderBy>;
  balance_y?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  burn_block_time?: InputMaybe<OrderBy>;
  est_pool_token_price?: InputMaybe<OrderBy>;
  est_token_y_price?: InputMaybe<OrderBy>;
  fee_rate_x?: InputMaybe<OrderBy>;
  fee_rate_y?: InputMaybe<OrderBy>;
  fee_rebate?: InputMaybe<OrderBy>;
  fee_rebate_7d?: InputMaybe<OrderBy>;
  fee_rebate_24h?: InputMaybe<OrderBy>;
  fee_rebate_x_7d?: InputMaybe<OrderBy>;
  fee_rebate_x_24h?: InputMaybe<OrderBy>;
  fee_rebate_y_7d?: InputMaybe<OrderBy>;
  fee_rebate_y_24h?: InputMaybe<OrderBy>;
  fee_to_address?: InputMaybe<OrderBy>;
  latest_oracle_resilient?: InputMaybe<OrderBy>;
  liquidity?: InputMaybe<OrderBy>;
  oracle_average?: InputMaybe<OrderBy>;
  oracle_enabled?: InputMaybe<OrderBy>;
  oracle_instant?: InputMaybe<OrderBy>;
  oracle_resilient?: InputMaybe<OrderBy>;
  pool_token?: InputMaybe<OrderBy>;
  sync_at?: InputMaybe<OrderBy>;
  token_x?: InputMaybe<OrderBy>;
  token_y?: InputMaybe<OrderBy>;
  total_supply?: InputMaybe<OrderBy>;
  volume_7d?: InputMaybe<OrderBy>;
  volume_24h?: InputMaybe<OrderBy>;
  volume_x_7d?: InputMaybe<OrderBy>;
  volume_x_24h?: InputMaybe<OrderBy>;
  volume_y_7d?: InputMaybe<OrderBy>;
  volume_y_24h?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.pool_stats */
export type LaplacePoolStatsPkColumnsInput = {
  block_height: Scalars['numeric'];
  pool_token: Scalars['String'];
};

/** select columns of table "laplace.pool_stats" */
export enum LaplacePoolStatsSelectColumn {
  /** column name */
  Apr_7d = 'apr_7d',
  /** column name */
  BalanceX = 'balance_x',
  /** column name */
  BalanceY = 'balance_y',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  EstPoolTokenPrice = 'est_pool_token_price',
  /** column name */
  EstTokenYPrice = 'est_token_y_price',
  /** column name */
  FeeRateX = 'fee_rate_x',
  /** column name */
  FeeRateY = 'fee_rate_y',
  /** column name */
  FeeRebate = 'fee_rebate',
  /** column name */
  FeeRebate_7d = 'fee_rebate_7d',
  /** column name */
  FeeRebate_24h = 'fee_rebate_24h',
  /** column name */
  FeeRebateX_7d = 'fee_rebate_x_7d',
  /** column name */
  FeeRebateX_24h = 'fee_rebate_x_24h',
  /** column name */
  FeeRebateY_7d = 'fee_rebate_y_7d',
  /** column name */
  FeeRebateY_24h = 'fee_rebate_y_24h',
  /** column name */
  FeeToAddress = 'fee_to_address',
  /** column name */
  LatestOracleResilient = 'latest_oracle_resilient',
  /** column name */
  Liquidity = 'liquidity',
  /** column name */
  OracleAverage = 'oracle_average',
  /** column name */
  OracleEnabled = 'oracle_enabled',
  /** column name */
  OracleInstant = 'oracle_instant',
  /** column name */
  OracleResilient = 'oracle_resilient',
  /** column name */
  PoolToken = 'pool_token',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenX = 'token_x',
  /** column name */
  TokenY = 'token_y',
  /** column name */
  TotalSupply = 'total_supply',
  /** column name */
  Volume_7d = 'volume_7d',
  /** column name */
  Volume_24h = 'volume_24h',
  /** column name */
  VolumeX_7d = 'volume_x_7d',
  /** column name */
  VolumeX_24h = 'volume_x_24h',
  /** column name */
  VolumeY_7d = 'volume_y_7d',
  /** column name */
  VolumeY_24h = 'volume_y_24h'
}

/** input type for updating data in table "laplace.pool_stats" */
export type LaplacePoolStatsSetInput = {
  apr_7d?: InputMaybe<Scalars['numeric']>;
  balance_x?: InputMaybe<Scalars['numeric']>;
  balance_y?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  est_pool_token_price?: InputMaybe<Scalars['bigint']>;
  est_token_y_price?: InputMaybe<Scalars['bigint']>;
  fee_rate_x?: InputMaybe<Scalars['numeric']>;
  fee_rate_y?: InputMaybe<Scalars['numeric']>;
  fee_rebate?: InputMaybe<Scalars['numeric']>;
  fee_rebate_7d?: InputMaybe<Scalars['numeric']>;
  fee_rebate_24h?: InputMaybe<Scalars['numeric']>;
  fee_rebate_x_7d?: InputMaybe<Scalars['numeric']>;
  fee_rebate_x_24h?: InputMaybe<Scalars['numeric']>;
  fee_rebate_y_7d?: InputMaybe<Scalars['numeric']>;
  fee_rebate_y_24h?: InputMaybe<Scalars['numeric']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  latest_oracle_resilient?: InputMaybe<Scalars['bigint']>;
  liquidity?: InputMaybe<Scalars['numeric']>;
  oracle_average?: InputMaybe<Scalars['bigint']>;
  oracle_enabled?: InputMaybe<Scalars['bigint']>;
  oracle_instant?: InputMaybe<Scalars['bigint']>;
  oracle_resilient?: InputMaybe<Scalars['bigint']>;
  pool_token?: InputMaybe<Scalars['String']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  total_supply?: InputMaybe<Scalars['numeric']>;
  volume_7d?: InputMaybe<Scalars['numeric']>;
  volume_24h?: InputMaybe<Scalars['numeric']>;
  volume_x_7d?: InputMaybe<Scalars['numeric']>;
  volume_x_24h?: InputMaybe<Scalars['numeric']>;
  volume_y_7d?: InputMaybe<Scalars['numeric']>;
  volume_y_24h?: InputMaybe<Scalars['numeric']>;
};

/** aggregate stddev on columns */
export type LaplacePoolStatsStddevFields = {
  __typename?: 'laplace_pool_stats_stddev_fields';
  apr_7d?: Maybe<Scalars['Float']>;
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  fee_rebate_7d?: Maybe<Scalars['Float']>;
  fee_rebate_24h?: Maybe<Scalars['Float']>;
  fee_rebate_x_7d?: Maybe<Scalars['Float']>;
  fee_rebate_x_24h?: Maybe<Scalars['Float']>;
  fee_rebate_y_7d?: Maybe<Scalars['Float']>;
  fee_rebate_y_24h?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  liquidity?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_enabled?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  volume_7d?: Maybe<Scalars['Float']>;
  volume_24h?: Maybe<Scalars['Float']>;
  volume_x_7d?: Maybe<Scalars['Float']>;
  volume_x_24h?: Maybe<Scalars['Float']>;
  volume_y_7d?: Maybe<Scalars['Float']>;
  volume_y_24h?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplacePoolStatsStddevPopFields = {
  __typename?: 'laplace_pool_stats_stddev_pop_fields';
  apr_7d?: Maybe<Scalars['Float']>;
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  fee_rebate_7d?: Maybe<Scalars['Float']>;
  fee_rebate_24h?: Maybe<Scalars['Float']>;
  fee_rebate_x_7d?: Maybe<Scalars['Float']>;
  fee_rebate_x_24h?: Maybe<Scalars['Float']>;
  fee_rebate_y_7d?: Maybe<Scalars['Float']>;
  fee_rebate_y_24h?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  liquidity?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_enabled?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  volume_7d?: Maybe<Scalars['Float']>;
  volume_24h?: Maybe<Scalars['Float']>;
  volume_x_7d?: Maybe<Scalars['Float']>;
  volume_x_24h?: Maybe<Scalars['Float']>;
  volume_y_7d?: Maybe<Scalars['Float']>;
  volume_y_24h?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplacePoolStatsStddevSampFields = {
  __typename?: 'laplace_pool_stats_stddev_samp_fields';
  apr_7d?: Maybe<Scalars['Float']>;
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  fee_rebate_7d?: Maybe<Scalars['Float']>;
  fee_rebate_24h?: Maybe<Scalars['Float']>;
  fee_rebate_x_7d?: Maybe<Scalars['Float']>;
  fee_rebate_x_24h?: Maybe<Scalars['Float']>;
  fee_rebate_y_7d?: Maybe<Scalars['Float']>;
  fee_rebate_y_24h?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  liquidity?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_enabled?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  volume_7d?: Maybe<Scalars['Float']>;
  volume_24h?: Maybe<Scalars['Float']>;
  volume_x_7d?: Maybe<Scalars['Float']>;
  volume_x_24h?: Maybe<Scalars['Float']>;
  volume_y_7d?: Maybe<Scalars['Float']>;
  volume_y_24h?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_pool_stats" */
export type LaplacePoolStatsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplacePoolStatsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplacePoolStatsStreamCursorValueInput = {
  apr_7d?: InputMaybe<Scalars['numeric']>;
  balance_x?: InputMaybe<Scalars['numeric']>;
  balance_y?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  est_pool_token_price?: InputMaybe<Scalars['bigint']>;
  est_token_y_price?: InputMaybe<Scalars['bigint']>;
  fee_rate_x?: InputMaybe<Scalars['numeric']>;
  fee_rate_y?: InputMaybe<Scalars['numeric']>;
  fee_rebate?: InputMaybe<Scalars['numeric']>;
  fee_rebate_7d?: InputMaybe<Scalars['numeric']>;
  fee_rebate_24h?: InputMaybe<Scalars['numeric']>;
  fee_rebate_x_7d?: InputMaybe<Scalars['numeric']>;
  fee_rebate_x_24h?: InputMaybe<Scalars['numeric']>;
  fee_rebate_y_7d?: InputMaybe<Scalars['numeric']>;
  fee_rebate_y_24h?: InputMaybe<Scalars['numeric']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  latest_oracle_resilient?: InputMaybe<Scalars['bigint']>;
  liquidity?: InputMaybe<Scalars['numeric']>;
  oracle_average?: InputMaybe<Scalars['bigint']>;
  oracle_enabled?: InputMaybe<Scalars['bigint']>;
  oracle_instant?: InputMaybe<Scalars['bigint']>;
  oracle_resilient?: InputMaybe<Scalars['bigint']>;
  pool_token?: InputMaybe<Scalars['String']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  total_supply?: InputMaybe<Scalars['numeric']>;
  volume_7d?: InputMaybe<Scalars['numeric']>;
  volume_24h?: InputMaybe<Scalars['numeric']>;
  volume_x_7d?: InputMaybe<Scalars['numeric']>;
  volume_x_24h?: InputMaybe<Scalars['numeric']>;
  volume_y_7d?: InputMaybe<Scalars['numeric']>;
  volume_y_24h?: InputMaybe<Scalars['numeric']>;
};

/** aggregate sum on columns */
export type LaplacePoolStatsSumFields = {
  __typename?: 'laplace_pool_stats_sum_fields';
  apr_7d?: Maybe<Scalars['numeric']>;
  balance_x?: Maybe<Scalars['numeric']>;
  balance_y?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  est_pool_token_price?: Maybe<Scalars['bigint']>;
  est_token_y_price?: Maybe<Scalars['bigint']>;
  fee_rate_x?: Maybe<Scalars['numeric']>;
  fee_rate_y?: Maybe<Scalars['numeric']>;
  fee_rebate?: Maybe<Scalars['numeric']>;
  fee_rebate_7d?: Maybe<Scalars['numeric']>;
  fee_rebate_24h?: Maybe<Scalars['numeric']>;
  fee_rebate_x_7d?: Maybe<Scalars['numeric']>;
  fee_rebate_x_24h?: Maybe<Scalars['numeric']>;
  fee_rebate_y_7d?: Maybe<Scalars['numeric']>;
  fee_rebate_y_24h?: Maybe<Scalars['numeric']>;
  latest_oracle_resilient?: Maybe<Scalars['bigint']>;
  liquidity?: Maybe<Scalars['numeric']>;
  oracle_average?: Maybe<Scalars['bigint']>;
  oracle_enabled?: Maybe<Scalars['bigint']>;
  oracle_instant?: Maybe<Scalars['bigint']>;
  oracle_resilient?: Maybe<Scalars['bigint']>;
  total_supply?: Maybe<Scalars['numeric']>;
  volume_7d?: Maybe<Scalars['numeric']>;
  volume_24h?: Maybe<Scalars['numeric']>;
  volume_x_7d?: Maybe<Scalars['numeric']>;
  volume_x_24h?: Maybe<Scalars['numeric']>;
  volume_y_7d?: Maybe<Scalars['numeric']>;
  volume_y_24h?: Maybe<Scalars['numeric']>;
};

/** update columns of table "laplace.pool_stats" */
export enum LaplacePoolStatsUpdateColumn {
  /** column name */
  Apr_7d = 'apr_7d',
  /** column name */
  BalanceX = 'balance_x',
  /** column name */
  BalanceY = 'balance_y',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  EstPoolTokenPrice = 'est_pool_token_price',
  /** column name */
  EstTokenYPrice = 'est_token_y_price',
  /** column name */
  FeeRateX = 'fee_rate_x',
  /** column name */
  FeeRateY = 'fee_rate_y',
  /** column name */
  FeeRebate = 'fee_rebate',
  /** column name */
  FeeRebate_7d = 'fee_rebate_7d',
  /** column name */
  FeeRebate_24h = 'fee_rebate_24h',
  /** column name */
  FeeRebateX_7d = 'fee_rebate_x_7d',
  /** column name */
  FeeRebateX_24h = 'fee_rebate_x_24h',
  /** column name */
  FeeRebateY_7d = 'fee_rebate_y_7d',
  /** column name */
  FeeRebateY_24h = 'fee_rebate_y_24h',
  /** column name */
  FeeToAddress = 'fee_to_address',
  /** column name */
  LatestOracleResilient = 'latest_oracle_resilient',
  /** column name */
  Liquidity = 'liquidity',
  /** column name */
  OracleAverage = 'oracle_average',
  /** column name */
  OracleEnabled = 'oracle_enabled',
  /** column name */
  OracleInstant = 'oracle_instant',
  /** column name */
  OracleResilient = 'oracle_resilient',
  /** column name */
  PoolToken = 'pool_token',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenX = 'token_x',
  /** column name */
  TokenY = 'token_y',
  /** column name */
  TotalSupply = 'total_supply',
  /** column name */
  Volume_7d = 'volume_7d',
  /** column name */
  Volume_24h = 'volume_24h',
  /** column name */
  VolumeX_7d = 'volume_x_7d',
  /** column name */
  VolumeX_24h = 'volume_x_24h',
  /** column name */
  VolumeY_7d = 'volume_y_7d',
  /** column name */
  VolumeY_24h = 'volume_y_24h'
}

export type LaplacePoolStatsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplacePoolStatsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplacePoolStatsSetInput>;
  where: LaplacePoolStatsBoolExp;
};

/** aggregate var_pop on columns */
export type LaplacePoolStatsVarPopFields = {
  __typename?: 'laplace_pool_stats_var_pop_fields';
  apr_7d?: Maybe<Scalars['Float']>;
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  fee_rebate_7d?: Maybe<Scalars['Float']>;
  fee_rebate_24h?: Maybe<Scalars['Float']>;
  fee_rebate_x_7d?: Maybe<Scalars['Float']>;
  fee_rebate_x_24h?: Maybe<Scalars['Float']>;
  fee_rebate_y_7d?: Maybe<Scalars['Float']>;
  fee_rebate_y_24h?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  liquidity?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_enabled?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  volume_7d?: Maybe<Scalars['Float']>;
  volume_24h?: Maybe<Scalars['Float']>;
  volume_x_7d?: Maybe<Scalars['Float']>;
  volume_x_24h?: Maybe<Scalars['Float']>;
  volume_y_7d?: Maybe<Scalars['Float']>;
  volume_y_24h?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplacePoolStatsVarSampFields = {
  __typename?: 'laplace_pool_stats_var_samp_fields';
  apr_7d?: Maybe<Scalars['Float']>;
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  fee_rebate_7d?: Maybe<Scalars['Float']>;
  fee_rebate_24h?: Maybe<Scalars['Float']>;
  fee_rebate_x_7d?: Maybe<Scalars['Float']>;
  fee_rebate_x_24h?: Maybe<Scalars['Float']>;
  fee_rebate_y_7d?: Maybe<Scalars['Float']>;
  fee_rebate_y_24h?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  liquidity?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_enabled?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  volume_7d?: Maybe<Scalars['Float']>;
  volume_24h?: Maybe<Scalars['Float']>;
  volume_x_7d?: Maybe<Scalars['Float']>;
  volume_x_24h?: Maybe<Scalars['Float']>;
  volume_y_7d?: Maybe<Scalars['Float']>;
  volume_y_24h?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplacePoolStatsVarianceFields = {
  __typename?: 'laplace_pool_stats_variance_fields';
  apr_7d?: Maybe<Scalars['Float']>;
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  fee_rebate_7d?: Maybe<Scalars['Float']>;
  fee_rebate_24h?: Maybe<Scalars['Float']>;
  fee_rebate_x_7d?: Maybe<Scalars['Float']>;
  fee_rebate_x_24h?: Maybe<Scalars['Float']>;
  fee_rebate_y_7d?: Maybe<Scalars['Float']>;
  fee_rebate_y_24h?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  liquidity?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_enabled?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  volume_7d?: Maybe<Scalars['Float']>;
  volume_24h?: Maybe<Scalars['Float']>;
  volume_x_7d?: Maybe<Scalars['Float']>;
  volume_x_24h?: Maybe<Scalars['Float']>;
  volume_y_7d?: Maybe<Scalars['Float']>;
  volume_y_24h?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "laplace.reward_cycle_stats" */
export type LaplaceRewardCycleStats = {
  __typename?: 'laplace_reward_cycle_stats';
  block_height: Scalars['bigint'];
  cycle: Scalars['bigint'];
  payload: Scalars['jsonb'];
  token: Scalars['String'];
};


/** columns and relationships of "laplace.reward_cycle_stats" */
export type LaplaceRewardCycleStatsPayloadArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "laplace.reward_cycle_stats" */
export type LaplaceRewardCycleStatsAggregate = {
  __typename?: 'laplace_reward_cycle_stats_aggregate';
  aggregate?: Maybe<LaplaceRewardCycleStatsAggregateFields>;
  nodes: Array<LaplaceRewardCycleStats>;
};

/** aggregate fields of "laplace.reward_cycle_stats" */
export type LaplaceRewardCycleStatsAggregateFields = {
  __typename?: 'laplace_reward_cycle_stats_aggregate_fields';
  avg?: Maybe<LaplaceRewardCycleStatsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceRewardCycleStatsMaxFields>;
  min?: Maybe<LaplaceRewardCycleStatsMinFields>;
  stddev?: Maybe<LaplaceRewardCycleStatsStddevFields>;
  stddev_pop?: Maybe<LaplaceRewardCycleStatsStddevPopFields>;
  stddev_samp?: Maybe<LaplaceRewardCycleStatsStddevSampFields>;
  sum?: Maybe<LaplaceRewardCycleStatsSumFields>;
  var_pop?: Maybe<LaplaceRewardCycleStatsVarPopFields>;
  var_samp?: Maybe<LaplaceRewardCycleStatsVarSampFields>;
  variance?: Maybe<LaplaceRewardCycleStatsVarianceFields>;
};


/** aggregate fields of "laplace.reward_cycle_stats" */
export type LaplaceRewardCycleStatsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceRewardCycleStatsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type LaplaceRewardCycleStatsAppendInput = {
  payload?: InputMaybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type LaplaceRewardCycleStatsAvgFields = {
  __typename?: 'laplace_reward_cycle_stats_avg_fields';
  block_height?: Maybe<Scalars['Float']>;
  cycle?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.reward_cycle_stats". All fields are combined with a logical 'AND'. */
export type LaplaceRewardCycleStatsBoolExp = {
  _and?: InputMaybe<Array<LaplaceRewardCycleStatsBoolExp>>;
  _not?: InputMaybe<LaplaceRewardCycleStatsBoolExp>;
  _or?: InputMaybe<Array<LaplaceRewardCycleStatsBoolExp>>;
  block_height?: InputMaybe<BigintComparisonExp>;
  cycle?: InputMaybe<BigintComparisonExp>;
  payload?: InputMaybe<JsonbComparisonExp>;
  token?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "laplace.reward_cycle_stats" */
export enum LaplaceRewardCycleStatsConstraint {
  /** unique or primary key constraint on columns "block_height", "token" */
  RewardCycleStatsPkey = 'reward_cycle_stats_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type LaplaceRewardCycleStatsDeleteAtPathInput = {
  payload?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type LaplaceRewardCycleStatsDeleteElemInput = {
  payload?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type LaplaceRewardCycleStatsDeleteKeyInput = {
  payload?: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "laplace.reward_cycle_stats" */
export type LaplaceRewardCycleStatsIncInput = {
  block_height?: InputMaybe<Scalars['bigint']>;
  cycle?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "laplace.reward_cycle_stats" */
export type LaplaceRewardCycleStatsInsertInput = {
  block_height?: InputMaybe<Scalars['bigint']>;
  cycle?: InputMaybe<Scalars['bigint']>;
  payload?: InputMaybe<Scalars['jsonb']>;
  token?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type LaplaceRewardCycleStatsMaxFields = {
  __typename?: 'laplace_reward_cycle_stats_max_fields';
  block_height?: Maybe<Scalars['bigint']>;
  cycle?: Maybe<Scalars['bigint']>;
  token?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LaplaceRewardCycleStatsMinFields = {
  __typename?: 'laplace_reward_cycle_stats_min_fields';
  block_height?: Maybe<Scalars['bigint']>;
  cycle?: Maybe<Scalars['bigint']>;
  token?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "laplace.reward_cycle_stats" */
export type LaplaceRewardCycleStatsMutationResponse = {
  __typename?: 'laplace_reward_cycle_stats_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceRewardCycleStats>;
};

/** on_conflict condition type for table "laplace.reward_cycle_stats" */
export type LaplaceRewardCycleStatsOnConflict = {
  constraint: LaplaceRewardCycleStatsConstraint;
  update_columns?: Array<LaplaceRewardCycleStatsUpdateColumn>;
  where?: InputMaybe<LaplaceRewardCycleStatsBoolExp>;
};

/** Ordering options when selecting data from "laplace.reward_cycle_stats". */
export type LaplaceRewardCycleStatsOrderBy = {
  block_height?: InputMaybe<OrderBy>;
  cycle?: InputMaybe<OrderBy>;
  payload?: InputMaybe<OrderBy>;
  token?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.reward_cycle_stats */
export type LaplaceRewardCycleStatsPkColumnsInput = {
  block_height: Scalars['bigint'];
  token: Scalars['String'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type LaplaceRewardCycleStatsPrependInput = {
  payload?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "laplace.reward_cycle_stats" */
export enum LaplaceRewardCycleStatsSelectColumn {
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  Cycle = 'cycle',
  /** column name */
  Payload = 'payload',
  /** column name */
  Token = 'token'
}

/** input type for updating data in table "laplace.reward_cycle_stats" */
export type LaplaceRewardCycleStatsSetInput = {
  block_height?: InputMaybe<Scalars['bigint']>;
  cycle?: InputMaybe<Scalars['bigint']>;
  payload?: InputMaybe<Scalars['jsonb']>;
  token?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type LaplaceRewardCycleStatsStddevFields = {
  __typename?: 'laplace_reward_cycle_stats_stddev_fields';
  block_height?: Maybe<Scalars['Float']>;
  cycle?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceRewardCycleStatsStddevPopFields = {
  __typename?: 'laplace_reward_cycle_stats_stddev_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  cycle?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceRewardCycleStatsStddevSampFields = {
  __typename?: 'laplace_reward_cycle_stats_stddev_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  cycle?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_reward_cycle_stats" */
export type LaplaceRewardCycleStatsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceRewardCycleStatsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceRewardCycleStatsStreamCursorValueInput = {
  block_height?: InputMaybe<Scalars['bigint']>;
  cycle?: InputMaybe<Scalars['bigint']>;
  payload?: InputMaybe<Scalars['jsonb']>;
  token?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type LaplaceRewardCycleStatsSumFields = {
  __typename?: 'laplace_reward_cycle_stats_sum_fields';
  block_height?: Maybe<Scalars['bigint']>;
  cycle?: Maybe<Scalars['bigint']>;
};

/** update columns of table "laplace.reward_cycle_stats" */
export enum LaplaceRewardCycleStatsUpdateColumn {
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  Cycle = 'cycle',
  /** column name */
  Payload = 'payload',
  /** column name */
  Token = 'token'
}

export type LaplaceRewardCycleStatsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<LaplaceRewardCycleStatsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<LaplaceRewardCycleStatsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<LaplaceRewardCycleStatsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<LaplaceRewardCycleStatsDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceRewardCycleStatsIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<LaplaceRewardCycleStatsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceRewardCycleStatsSetInput>;
  where: LaplaceRewardCycleStatsBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceRewardCycleStatsVarPopFields = {
  __typename?: 'laplace_reward_cycle_stats_var_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  cycle?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceRewardCycleStatsVarSampFields = {
  __typename?: 'laplace_reward_cycle_stats_var_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  cycle?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceRewardCycleStatsVarianceFields = {
  __typename?: 'laplace_reward_cycle_stats_variance_fields';
  block_height?: Maybe<Scalars['Float']>;
  cycle?: Maybe<Scalars['Float']>;
};

/** Contract simple_weight_pool_alex per-block data */
export type LaplaceSimpleWeightPoolAlex = {
  __typename?: 'laplace_simple_weight_pool_alex';
  balance_x: Scalars['bigint'];
  balance_y: Scalars['bigint'];
  block_height: Scalars['Int'];
  burn_block_time: Scalars['Int'];
  end_block: Scalars['numeric'];
  est_pool_token_price: Scalars['bigint'];
  est_token_y_price: Scalars['bigint'];
  fee_rate_x: Scalars['bigint'];
  fee_rate_y: Scalars['bigint'];
  fee_rebate: Scalars['bigint'];
  fee_to_address: Scalars['String'];
  latest_oracle_resilient: Scalars['bigint'];
  oracle_average: Scalars['bigint'];
  oracle_enabled: Scalars['Boolean'];
  oracle_instant: Scalars['bigint'];
  oracle_resilient: Scalars['bigint'];
  pool_token: Scalars['String'];
  start_block: Scalars['numeric'];
  sync_at: Scalars['timestamptz'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
  total_supply: Scalars['bigint'];
};

/** aggregated selection of "laplace.simple_weight_pool_alex" */
export type LaplaceSimpleWeightPoolAlexAggregate = {
  __typename?: 'laplace_simple_weight_pool_alex_aggregate';
  aggregate?: Maybe<LaplaceSimpleWeightPoolAlexAggregateFields>;
  nodes: Array<LaplaceSimpleWeightPoolAlex>;
};

/** aggregate fields of "laplace.simple_weight_pool_alex" */
export type LaplaceSimpleWeightPoolAlexAggregateFields = {
  __typename?: 'laplace_simple_weight_pool_alex_aggregate_fields';
  avg?: Maybe<LaplaceSimpleWeightPoolAlexAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceSimpleWeightPoolAlexMaxFields>;
  min?: Maybe<LaplaceSimpleWeightPoolAlexMinFields>;
  stddev?: Maybe<LaplaceSimpleWeightPoolAlexStddevFields>;
  stddev_pop?: Maybe<LaplaceSimpleWeightPoolAlexStddevPopFields>;
  stddev_samp?: Maybe<LaplaceSimpleWeightPoolAlexStddevSampFields>;
  sum?: Maybe<LaplaceSimpleWeightPoolAlexSumFields>;
  var_pop?: Maybe<LaplaceSimpleWeightPoolAlexVarPopFields>;
  var_samp?: Maybe<LaplaceSimpleWeightPoolAlexVarSampFields>;
  variance?: Maybe<LaplaceSimpleWeightPoolAlexVarianceFields>;
};


/** aggregate fields of "laplace.simple_weight_pool_alex" */
export type LaplaceSimpleWeightPoolAlexAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceSimpleWeightPoolAlexSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LaplaceSimpleWeightPoolAlexAvgFields = {
  __typename?: 'laplace_simple_weight_pool_alex_avg_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  end_block?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  start_block?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.simple_weight_pool_alex". All fields are combined with a logical 'AND'. */
export type LaplaceSimpleWeightPoolAlexBoolExp = {
  _and?: InputMaybe<Array<LaplaceSimpleWeightPoolAlexBoolExp>>;
  _not?: InputMaybe<LaplaceSimpleWeightPoolAlexBoolExp>;
  _or?: InputMaybe<Array<LaplaceSimpleWeightPoolAlexBoolExp>>;
  balance_x?: InputMaybe<BigintComparisonExp>;
  balance_y?: InputMaybe<BigintComparisonExp>;
  block_height?: InputMaybe<IntComparisonExp>;
  burn_block_time?: InputMaybe<IntComparisonExp>;
  end_block?: InputMaybe<NumericComparisonExp>;
  est_pool_token_price?: InputMaybe<BigintComparisonExp>;
  est_token_y_price?: InputMaybe<BigintComparisonExp>;
  fee_rate_x?: InputMaybe<BigintComparisonExp>;
  fee_rate_y?: InputMaybe<BigintComparisonExp>;
  fee_rebate?: InputMaybe<BigintComparisonExp>;
  fee_to_address?: InputMaybe<StringComparisonExp>;
  latest_oracle_resilient?: InputMaybe<BigintComparisonExp>;
  oracle_average?: InputMaybe<BigintComparisonExp>;
  oracle_enabled?: InputMaybe<BooleanComparisonExp>;
  oracle_instant?: InputMaybe<BigintComparisonExp>;
  oracle_resilient?: InputMaybe<BigintComparisonExp>;
  pool_token?: InputMaybe<StringComparisonExp>;
  start_block?: InputMaybe<NumericComparisonExp>;
  sync_at?: InputMaybe<TimestamptzComparisonExp>;
  token_x?: InputMaybe<StringComparisonExp>;
  token_y?: InputMaybe<StringComparisonExp>;
  total_supply?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "laplace.simple_weight_pool_alex" */
export enum LaplaceSimpleWeightPoolAlexConstraint {
  /** unique or primary key constraint on columns "block_height", "token_y", "token_x" */
  SimpleWeightPoolAlexPkey = 'simple_weight_pool_alex_pkey'
}

/** input type for incrementing numeric columns in table "laplace.simple_weight_pool_alex" */
export type LaplaceSimpleWeightPoolAlexIncInput = {
  balance_x?: InputMaybe<Scalars['bigint']>;
  balance_y?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  end_block?: InputMaybe<Scalars['numeric']>;
  est_pool_token_price?: InputMaybe<Scalars['bigint']>;
  est_token_y_price?: InputMaybe<Scalars['bigint']>;
  fee_rate_x?: InputMaybe<Scalars['bigint']>;
  fee_rate_y?: InputMaybe<Scalars['bigint']>;
  fee_rebate?: InputMaybe<Scalars['bigint']>;
  latest_oracle_resilient?: InputMaybe<Scalars['bigint']>;
  oracle_average?: InputMaybe<Scalars['bigint']>;
  oracle_instant?: InputMaybe<Scalars['bigint']>;
  oracle_resilient?: InputMaybe<Scalars['bigint']>;
  start_block?: InputMaybe<Scalars['numeric']>;
  total_supply?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "laplace.simple_weight_pool_alex" */
export type LaplaceSimpleWeightPoolAlexInsertInput = {
  balance_x?: InputMaybe<Scalars['bigint']>;
  balance_y?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  end_block?: InputMaybe<Scalars['numeric']>;
  est_pool_token_price?: InputMaybe<Scalars['bigint']>;
  est_token_y_price?: InputMaybe<Scalars['bigint']>;
  fee_rate_x?: InputMaybe<Scalars['bigint']>;
  fee_rate_y?: InputMaybe<Scalars['bigint']>;
  fee_rebate?: InputMaybe<Scalars['bigint']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  latest_oracle_resilient?: InputMaybe<Scalars['bigint']>;
  oracle_average?: InputMaybe<Scalars['bigint']>;
  oracle_enabled?: InputMaybe<Scalars['Boolean']>;
  oracle_instant?: InputMaybe<Scalars['bigint']>;
  oracle_resilient?: InputMaybe<Scalars['bigint']>;
  pool_token?: InputMaybe<Scalars['String']>;
  start_block?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  total_supply?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type LaplaceSimpleWeightPoolAlexMaxFields = {
  __typename?: 'laplace_simple_weight_pool_alex_max_fields';
  balance_x?: Maybe<Scalars['bigint']>;
  balance_y?: Maybe<Scalars['bigint']>;
  block_height?: Maybe<Scalars['Int']>;
  burn_block_time?: Maybe<Scalars['Int']>;
  end_block?: Maybe<Scalars['numeric']>;
  est_pool_token_price?: Maybe<Scalars['bigint']>;
  est_token_y_price?: Maybe<Scalars['bigint']>;
  fee_rate_x?: Maybe<Scalars['bigint']>;
  fee_rate_y?: Maybe<Scalars['bigint']>;
  fee_rebate?: Maybe<Scalars['bigint']>;
  fee_to_address?: Maybe<Scalars['String']>;
  latest_oracle_resilient?: Maybe<Scalars['bigint']>;
  oracle_average?: Maybe<Scalars['bigint']>;
  oracle_instant?: Maybe<Scalars['bigint']>;
  oracle_resilient?: Maybe<Scalars['bigint']>;
  pool_token?: Maybe<Scalars['String']>;
  start_block?: Maybe<Scalars['numeric']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_x?: Maybe<Scalars['String']>;
  token_y?: Maybe<Scalars['String']>;
  total_supply?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type LaplaceSimpleWeightPoolAlexMinFields = {
  __typename?: 'laplace_simple_weight_pool_alex_min_fields';
  balance_x?: Maybe<Scalars['bigint']>;
  balance_y?: Maybe<Scalars['bigint']>;
  block_height?: Maybe<Scalars['Int']>;
  burn_block_time?: Maybe<Scalars['Int']>;
  end_block?: Maybe<Scalars['numeric']>;
  est_pool_token_price?: Maybe<Scalars['bigint']>;
  est_token_y_price?: Maybe<Scalars['bigint']>;
  fee_rate_x?: Maybe<Scalars['bigint']>;
  fee_rate_y?: Maybe<Scalars['bigint']>;
  fee_rebate?: Maybe<Scalars['bigint']>;
  fee_to_address?: Maybe<Scalars['String']>;
  latest_oracle_resilient?: Maybe<Scalars['bigint']>;
  oracle_average?: Maybe<Scalars['bigint']>;
  oracle_instant?: Maybe<Scalars['bigint']>;
  oracle_resilient?: Maybe<Scalars['bigint']>;
  pool_token?: Maybe<Scalars['String']>;
  start_block?: Maybe<Scalars['numeric']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token_x?: Maybe<Scalars['String']>;
  token_y?: Maybe<Scalars['String']>;
  total_supply?: Maybe<Scalars['bigint']>;
};

/** response of any mutation on the table "laplace.simple_weight_pool_alex" */
export type LaplaceSimpleWeightPoolAlexMutationResponse = {
  __typename?: 'laplace_simple_weight_pool_alex_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceSimpleWeightPoolAlex>;
};

/** on_conflict condition type for table "laplace.simple_weight_pool_alex" */
export type LaplaceSimpleWeightPoolAlexOnConflict = {
  constraint: LaplaceSimpleWeightPoolAlexConstraint;
  update_columns?: Array<LaplaceSimpleWeightPoolAlexUpdateColumn>;
  where?: InputMaybe<LaplaceSimpleWeightPoolAlexBoolExp>;
};

/** Ordering options when selecting data from "laplace.simple_weight_pool_alex". */
export type LaplaceSimpleWeightPoolAlexOrderBy = {
  balance_x?: InputMaybe<OrderBy>;
  balance_y?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  burn_block_time?: InputMaybe<OrderBy>;
  end_block?: InputMaybe<OrderBy>;
  est_pool_token_price?: InputMaybe<OrderBy>;
  est_token_y_price?: InputMaybe<OrderBy>;
  fee_rate_x?: InputMaybe<OrderBy>;
  fee_rate_y?: InputMaybe<OrderBy>;
  fee_rebate?: InputMaybe<OrderBy>;
  fee_to_address?: InputMaybe<OrderBy>;
  latest_oracle_resilient?: InputMaybe<OrderBy>;
  oracle_average?: InputMaybe<OrderBy>;
  oracle_enabled?: InputMaybe<OrderBy>;
  oracle_instant?: InputMaybe<OrderBy>;
  oracle_resilient?: InputMaybe<OrderBy>;
  pool_token?: InputMaybe<OrderBy>;
  start_block?: InputMaybe<OrderBy>;
  sync_at?: InputMaybe<OrderBy>;
  token_x?: InputMaybe<OrderBy>;
  token_y?: InputMaybe<OrderBy>;
  total_supply?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.simple_weight_pool_alex */
export type LaplaceSimpleWeightPoolAlexPkColumnsInput = {
  block_height: Scalars['Int'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};

/** select columns of table "laplace.simple_weight_pool_alex" */
export enum LaplaceSimpleWeightPoolAlexSelectColumn {
  /** column name */
  BalanceX = 'balance_x',
  /** column name */
  BalanceY = 'balance_y',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  EndBlock = 'end_block',
  /** column name */
  EstPoolTokenPrice = 'est_pool_token_price',
  /** column name */
  EstTokenYPrice = 'est_token_y_price',
  /** column name */
  FeeRateX = 'fee_rate_x',
  /** column name */
  FeeRateY = 'fee_rate_y',
  /** column name */
  FeeRebate = 'fee_rebate',
  /** column name */
  FeeToAddress = 'fee_to_address',
  /** column name */
  LatestOracleResilient = 'latest_oracle_resilient',
  /** column name */
  OracleAverage = 'oracle_average',
  /** column name */
  OracleEnabled = 'oracle_enabled',
  /** column name */
  OracleInstant = 'oracle_instant',
  /** column name */
  OracleResilient = 'oracle_resilient',
  /** column name */
  PoolToken = 'pool_token',
  /** column name */
  StartBlock = 'start_block',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenX = 'token_x',
  /** column name */
  TokenY = 'token_y',
  /** column name */
  TotalSupply = 'total_supply'
}

/** input type for updating data in table "laplace.simple_weight_pool_alex" */
export type LaplaceSimpleWeightPoolAlexSetInput = {
  balance_x?: InputMaybe<Scalars['bigint']>;
  balance_y?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  end_block?: InputMaybe<Scalars['numeric']>;
  est_pool_token_price?: InputMaybe<Scalars['bigint']>;
  est_token_y_price?: InputMaybe<Scalars['bigint']>;
  fee_rate_x?: InputMaybe<Scalars['bigint']>;
  fee_rate_y?: InputMaybe<Scalars['bigint']>;
  fee_rebate?: InputMaybe<Scalars['bigint']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  latest_oracle_resilient?: InputMaybe<Scalars['bigint']>;
  oracle_average?: InputMaybe<Scalars['bigint']>;
  oracle_enabled?: InputMaybe<Scalars['Boolean']>;
  oracle_instant?: InputMaybe<Scalars['bigint']>;
  oracle_resilient?: InputMaybe<Scalars['bigint']>;
  pool_token?: InputMaybe<Scalars['String']>;
  start_block?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  total_supply?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type LaplaceSimpleWeightPoolAlexStddevFields = {
  __typename?: 'laplace_simple_weight_pool_alex_stddev_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  end_block?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  start_block?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceSimpleWeightPoolAlexStddevPopFields = {
  __typename?: 'laplace_simple_weight_pool_alex_stddev_pop_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  end_block?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  start_block?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceSimpleWeightPoolAlexStddevSampFields = {
  __typename?: 'laplace_simple_weight_pool_alex_stddev_samp_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  end_block?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  start_block?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_simple_weight_pool_alex" */
export type LaplaceSimpleWeightPoolAlexStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceSimpleWeightPoolAlexStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceSimpleWeightPoolAlexStreamCursorValueInput = {
  balance_x?: InputMaybe<Scalars['bigint']>;
  balance_y?: InputMaybe<Scalars['bigint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  end_block?: InputMaybe<Scalars['numeric']>;
  est_pool_token_price?: InputMaybe<Scalars['bigint']>;
  est_token_y_price?: InputMaybe<Scalars['bigint']>;
  fee_rate_x?: InputMaybe<Scalars['bigint']>;
  fee_rate_y?: InputMaybe<Scalars['bigint']>;
  fee_rebate?: InputMaybe<Scalars['bigint']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  latest_oracle_resilient?: InputMaybe<Scalars['bigint']>;
  oracle_average?: InputMaybe<Scalars['bigint']>;
  oracle_enabled?: InputMaybe<Scalars['Boolean']>;
  oracle_instant?: InputMaybe<Scalars['bigint']>;
  oracle_resilient?: InputMaybe<Scalars['bigint']>;
  pool_token?: InputMaybe<Scalars['String']>;
  start_block?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_y?: InputMaybe<Scalars['String']>;
  total_supply?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type LaplaceSimpleWeightPoolAlexSumFields = {
  __typename?: 'laplace_simple_weight_pool_alex_sum_fields';
  balance_x?: Maybe<Scalars['bigint']>;
  balance_y?: Maybe<Scalars['bigint']>;
  block_height?: Maybe<Scalars['Int']>;
  burn_block_time?: Maybe<Scalars['Int']>;
  end_block?: Maybe<Scalars['numeric']>;
  est_pool_token_price?: Maybe<Scalars['bigint']>;
  est_token_y_price?: Maybe<Scalars['bigint']>;
  fee_rate_x?: Maybe<Scalars['bigint']>;
  fee_rate_y?: Maybe<Scalars['bigint']>;
  fee_rebate?: Maybe<Scalars['bigint']>;
  latest_oracle_resilient?: Maybe<Scalars['bigint']>;
  oracle_average?: Maybe<Scalars['bigint']>;
  oracle_instant?: Maybe<Scalars['bigint']>;
  oracle_resilient?: Maybe<Scalars['bigint']>;
  start_block?: Maybe<Scalars['numeric']>;
  total_supply?: Maybe<Scalars['bigint']>;
};

/** update columns of table "laplace.simple_weight_pool_alex" */
export enum LaplaceSimpleWeightPoolAlexUpdateColumn {
  /** column name */
  BalanceX = 'balance_x',
  /** column name */
  BalanceY = 'balance_y',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  EndBlock = 'end_block',
  /** column name */
  EstPoolTokenPrice = 'est_pool_token_price',
  /** column name */
  EstTokenYPrice = 'est_token_y_price',
  /** column name */
  FeeRateX = 'fee_rate_x',
  /** column name */
  FeeRateY = 'fee_rate_y',
  /** column name */
  FeeRebate = 'fee_rebate',
  /** column name */
  FeeToAddress = 'fee_to_address',
  /** column name */
  LatestOracleResilient = 'latest_oracle_resilient',
  /** column name */
  OracleAverage = 'oracle_average',
  /** column name */
  OracleEnabled = 'oracle_enabled',
  /** column name */
  OracleInstant = 'oracle_instant',
  /** column name */
  OracleResilient = 'oracle_resilient',
  /** column name */
  PoolToken = 'pool_token',
  /** column name */
  StartBlock = 'start_block',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TokenX = 'token_x',
  /** column name */
  TokenY = 'token_y',
  /** column name */
  TotalSupply = 'total_supply'
}

export type LaplaceSimpleWeightPoolAlexUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceSimpleWeightPoolAlexIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceSimpleWeightPoolAlexSetInput>;
  where: LaplaceSimpleWeightPoolAlexBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceSimpleWeightPoolAlexVarPopFields = {
  __typename?: 'laplace_simple_weight_pool_alex_var_pop_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  end_block?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  start_block?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceSimpleWeightPoolAlexVarSampFields = {
  __typename?: 'laplace_simple_weight_pool_alex_var_samp_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  end_block?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  start_block?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceSimpleWeightPoolAlexVarianceFields = {
  __typename?: 'laplace_simple_weight_pool_alex_variance_fields';
  balance_x?: Maybe<Scalars['Float']>;
  balance_y?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  end_block?: Maybe<Scalars['Float']>;
  est_pool_token_price?: Maybe<Scalars['Float']>;
  est_token_y_price?: Maybe<Scalars['Float']>;
  fee_rate_x?: Maybe<Scalars['Float']>;
  fee_rate_y?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  latest_oracle_resilient?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_instant?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  start_block?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "laplace.stacks_blockchain_events" */
export type LaplaceStacksBlockchainEvents = {
  __typename?: 'laplace_stacks_blockchain_events';
  event_path?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  payload?: Maybe<Scalars['jsonb']>;
};


/** columns and relationships of "laplace.stacks_blockchain_events" */
export type LaplaceStacksBlockchainEventsPayloadArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "laplace.stacks_blockchain_events" */
export type LaplaceStacksBlockchainEventsAggregate = {
  __typename?: 'laplace_stacks_blockchain_events_aggregate';
  aggregate?: Maybe<LaplaceStacksBlockchainEventsAggregateFields>;
  nodes: Array<LaplaceStacksBlockchainEvents>;
};

/** aggregate fields of "laplace.stacks_blockchain_events" */
export type LaplaceStacksBlockchainEventsAggregateFields = {
  __typename?: 'laplace_stacks_blockchain_events_aggregate_fields';
  avg?: Maybe<LaplaceStacksBlockchainEventsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceStacksBlockchainEventsMaxFields>;
  min?: Maybe<LaplaceStacksBlockchainEventsMinFields>;
  stddev?: Maybe<LaplaceStacksBlockchainEventsStddevFields>;
  stddev_pop?: Maybe<LaplaceStacksBlockchainEventsStddevPopFields>;
  stddev_samp?: Maybe<LaplaceStacksBlockchainEventsStddevSampFields>;
  sum?: Maybe<LaplaceStacksBlockchainEventsSumFields>;
  var_pop?: Maybe<LaplaceStacksBlockchainEventsVarPopFields>;
  var_samp?: Maybe<LaplaceStacksBlockchainEventsVarSampFields>;
  variance?: Maybe<LaplaceStacksBlockchainEventsVarianceFields>;
};


/** aggregate fields of "laplace.stacks_blockchain_events" */
export type LaplaceStacksBlockchainEventsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceStacksBlockchainEventsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type LaplaceStacksBlockchainEventsAppendInput = {
  payload?: InputMaybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type LaplaceStacksBlockchainEventsAvgFields = {
  __typename?: 'laplace_stacks_blockchain_events_avg_fields';
  id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.stacks_blockchain_events". All fields are combined with a logical 'AND'. */
export type LaplaceStacksBlockchainEventsBoolExp = {
  _and?: InputMaybe<Array<LaplaceStacksBlockchainEventsBoolExp>>;
  _not?: InputMaybe<LaplaceStacksBlockchainEventsBoolExp>;
  _or?: InputMaybe<Array<LaplaceStacksBlockchainEventsBoolExp>>;
  event_path?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  payload?: InputMaybe<JsonbComparisonExp>;
};

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type LaplaceStacksBlockchainEventsDeleteAtPathInput = {
  payload?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type LaplaceStacksBlockchainEventsDeleteElemInput = {
  payload?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type LaplaceStacksBlockchainEventsDeleteKeyInput = {
  payload?: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "laplace.stacks_blockchain_events" */
export type LaplaceStacksBlockchainEventsIncInput = {
  id?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "laplace.stacks_blockchain_events" */
export type LaplaceStacksBlockchainEventsInsertInput = {
  event_path?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['Int']>;
  payload?: InputMaybe<Scalars['jsonb']>;
};

/** aggregate max on columns */
export type LaplaceStacksBlockchainEventsMaxFields = {
  __typename?: 'laplace_stacks_blockchain_events_max_fields';
  event_path?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type LaplaceStacksBlockchainEventsMinFields = {
  __typename?: 'laplace_stacks_blockchain_events_min_fields';
  event_path?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "laplace.stacks_blockchain_events" */
export type LaplaceStacksBlockchainEventsMutationResponse = {
  __typename?: 'laplace_stacks_blockchain_events_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceStacksBlockchainEvents>;
};

/** Ordering options when selecting data from "laplace.stacks_blockchain_events". */
export type LaplaceStacksBlockchainEventsOrderBy = {
  event_path?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  payload?: InputMaybe<OrderBy>;
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type LaplaceStacksBlockchainEventsPrependInput = {
  payload?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "laplace.stacks_blockchain_events" */
export enum LaplaceStacksBlockchainEventsSelectColumn {
  /** column name */
  EventPath = 'event_path',
  /** column name */
  Id = 'id',
  /** column name */
  Payload = 'payload'
}

/** input type for updating data in table "laplace.stacks_blockchain_events" */
export type LaplaceStacksBlockchainEventsSetInput = {
  event_path?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['Int']>;
  payload?: InputMaybe<Scalars['jsonb']>;
};

/** aggregate stddev on columns */
export type LaplaceStacksBlockchainEventsStddevFields = {
  __typename?: 'laplace_stacks_blockchain_events_stddev_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceStacksBlockchainEventsStddevPopFields = {
  __typename?: 'laplace_stacks_blockchain_events_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceStacksBlockchainEventsStddevSampFields = {
  __typename?: 'laplace_stacks_blockchain_events_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_stacks_blockchain_events" */
export type LaplaceStacksBlockchainEventsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceStacksBlockchainEventsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceStacksBlockchainEventsStreamCursorValueInput = {
  event_path?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['Int']>;
  payload?: InputMaybe<Scalars['jsonb']>;
};

/** aggregate sum on columns */
export type LaplaceStacksBlockchainEventsSumFields = {
  __typename?: 'laplace_stacks_blockchain_events_sum_fields';
  id?: Maybe<Scalars['Int']>;
};

export type LaplaceStacksBlockchainEventsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<LaplaceStacksBlockchainEventsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<LaplaceStacksBlockchainEventsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<LaplaceStacksBlockchainEventsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<LaplaceStacksBlockchainEventsDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceStacksBlockchainEventsIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<LaplaceStacksBlockchainEventsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceStacksBlockchainEventsSetInput>;
  where: LaplaceStacksBlockchainEventsBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceStacksBlockchainEventsVarPopFields = {
  __typename?: 'laplace_stacks_blockchain_events_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceStacksBlockchainEventsVarSampFields = {
  __typename?: 'laplace_stacks_blockchain_events_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceStacksBlockchainEventsVarianceFields = {
  __typename?: 'laplace_stacks_blockchain_events_variance_fields';
  id?: Maybe<Scalars['Float']>;
};

/** ALEX swap records */
export type LaplaceSwapRecords = {
  __typename?: 'laplace_swap_records';
  block_height: Scalars['numeric'];
  burn_block_time: Scalars['numeric'];
  contract_id: Scalars['String'];
  event_index: Scalars['numeric'];
  function_name: Scalars['String'];
  pool_action: Scalars['String'];
  pool_token_deployer_address: Scalars['String'];
  pool_token_name: Scalars['String'];
  sender_address?: Maybe<Scalars['String']>;
  token_x: Scalars['String'];
  token_x_amount: Scalars['bigint'];
  token_x_fee: Scalars['bigint'];
  token_x_fee_rebate: Scalars['bigint'];
  token_y: Scalars['String'];
  token_y_amount: Scalars['bigint'];
  token_y_fee: Scalars['bigint'];
  token_y_fee_rebate: Scalars['bigint'];
  tx_id: Scalars['String'];
  tx_index: Scalars['numeric'];
};

/** aggregated selection of "laplace.swap_records" */
export type LaplaceSwapRecordsAggregate = {
  __typename?: 'laplace_swap_records_aggregate';
  aggregate?: Maybe<LaplaceSwapRecordsAggregateFields>;
  nodes: Array<LaplaceSwapRecords>;
};

/** aggregate fields of "laplace.swap_records" */
export type LaplaceSwapRecordsAggregateFields = {
  __typename?: 'laplace_swap_records_aggregate_fields';
  avg?: Maybe<LaplaceSwapRecordsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceSwapRecordsMaxFields>;
  min?: Maybe<LaplaceSwapRecordsMinFields>;
  stddev?: Maybe<LaplaceSwapRecordsStddevFields>;
  stddev_pop?: Maybe<LaplaceSwapRecordsStddevPopFields>;
  stddev_samp?: Maybe<LaplaceSwapRecordsStddevSampFields>;
  sum?: Maybe<LaplaceSwapRecordsSumFields>;
  var_pop?: Maybe<LaplaceSwapRecordsVarPopFields>;
  var_samp?: Maybe<LaplaceSwapRecordsVarSampFields>;
  variance?: Maybe<LaplaceSwapRecordsVarianceFields>;
};


/** aggregate fields of "laplace.swap_records" */
export type LaplaceSwapRecordsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceSwapRecordsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LaplaceSwapRecordsAvgFields = {
  __typename?: 'laplace_swap_records_avg_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  event_index?: Maybe<Scalars['Float']>;
  token_x_amount?: Maybe<Scalars['Float']>;
  token_x_fee?: Maybe<Scalars['Float']>;
  token_x_fee_rebate?: Maybe<Scalars['Float']>;
  token_y_amount?: Maybe<Scalars['Float']>;
  token_y_fee?: Maybe<Scalars['Float']>;
  token_y_fee_rebate?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.swap_records". All fields are combined with a logical 'AND'. */
export type LaplaceSwapRecordsBoolExp = {
  _and?: InputMaybe<Array<LaplaceSwapRecordsBoolExp>>;
  _not?: InputMaybe<LaplaceSwapRecordsBoolExp>;
  _or?: InputMaybe<Array<LaplaceSwapRecordsBoolExp>>;
  block_height?: InputMaybe<NumericComparisonExp>;
  burn_block_time?: InputMaybe<NumericComparisonExp>;
  contract_id?: InputMaybe<StringComparisonExp>;
  event_index?: InputMaybe<NumericComparisonExp>;
  function_name?: InputMaybe<StringComparisonExp>;
  pool_action?: InputMaybe<StringComparisonExp>;
  pool_token_deployer_address?: InputMaybe<StringComparisonExp>;
  pool_token_name?: InputMaybe<StringComparisonExp>;
  sender_address?: InputMaybe<StringComparisonExp>;
  token_x?: InputMaybe<StringComparisonExp>;
  token_x_amount?: InputMaybe<BigintComparisonExp>;
  token_x_fee?: InputMaybe<BigintComparisonExp>;
  token_x_fee_rebate?: InputMaybe<BigintComparisonExp>;
  token_y?: InputMaybe<StringComparisonExp>;
  token_y_amount?: InputMaybe<BigintComparisonExp>;
  token_y_fee?: InputMaybe<BigintComparisonExp>;
  token_y_fee_rebate?: InputMaybe<BigintComparisonExp>;
  tx_id?: InputMaybe<StringComparisonExp>;
  tx_index?: InputMaybe<NumericComparisonExp>;
};

/** unique or primary key constraints on table "laplace.swap_records" */
export enum LaplaceSwapRecordsConstraint {
  /** unique or primary key constraint on columns "event_index", "tx_id" */
  SwapRecordsPkey = 'swap_records_pkey'
}

/** input type for incrementing numeric columns in table "laplace.swap_records" */
export type LaplaceSwapRecordsIncInput = {
  block_height?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  event_index?: InputMaybe<Scalars['numeric']>;
  token_x_amount?: InputMaybe<Scalars['bigint']>;
  token_x_fee?: InputMaybe<Scalars['bigint']>;
  token_x_fee_rebate?: InputMaybe<Scalars['bigint']>;
  token_y_amount?: InputMaybe<Scalars['bigint']>;
  token_y_fee?: InputMaybe<Scalars['bigint']>;
  token_y_fee_rebate?: InputMaybe<Scalars['bigint']>;
  tx_index?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "laplace.swap_records" */
export type LaplaceSwapRecordsInsertInput = {
  block_height?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  contract_id?: InputMaybe<Scalars['String']>;
  event_index?: InputMaybe<Scalars['numeric']>;
  function_name?: InputMaybe<Scalars['String']>;
  pool_action?: InputMaybe<Scalars['String']>;
  pool_token_deployer_address?: InputMaybe<Scalars['String']>;
  pool_token_name?: InputMaybe<Scalars['String']>;
  sender_address?: InputMaybe<Scalars['String']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_x_amount?: InputMaybe<Scalars['bigint']>;
  token_x_fee?: InputMaybe<Scalars['bigint']>;
  token_x_fee_rebate?: InputMaybe<Scalars['bigint']>;
  token_y?: InputMaybe<Scalars['String']>;
  token_y_amount?: InputMaybe<Scalars['bigint']>;
  token_y_fee?: InputMaybe<Scalars['bigint']>;
  token_y_fee_rebate?: InputMaybe<Scalars['bigint']>;
  tx_id?: InputMaybe<Scalars['String']>;
  tx_index?: InputMaybe<Scalars['numeric']>;
};

/** aggregate max on columns */
export type LaplaceSwapRecordsMaxFields = {
  __typename?: 'laplace_swap_records_max_fields';
  block_height?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  contract_id?: Maybe<Scalars['String']>;
  event_index?: Maybe<Scalars['numeric']>;
  function_name?: Maybe<Scalars['String']>;
  pool_action?: Maybe<Scalars['String']>;
  pool_token_deployer_address?: Maybe<Scalars['String']>;
  pool_token_name?: Maybe<Scalars['String']>;
  sender_address?: Maybe<Scalars['String']>;
  token_x?: Maybe<Scalars['String']>;
  token_x_amount?: Maybe<Scalars['bigint']>;
  token_x_fee?: Maybe<Scalars['bigint']>;
  token_x_fee_rebate?: Maybe<Scalars['bigint']>;
  token_y?: Maybe<Scalars['String']>;
  token_y_amount?: Maybe<Scalars['bigint']>;
  token_y_fee?: Maybe<Scalars['bigint']>;
  token_y_fee_rebate?: Maybe<Scalars['bigint']>;
  tx_id?: Maybe<Scalars['String']>;
  tx_index?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type LaplaceSwapRecordsMinFields = {
  __typename?: 'laplace_swap_records_min_fields';
  block_height?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  contract_id?: Maybe<Scalars['String']>;
  event_index?: Maybe<Scalars['numeric']>;
  function_name?: Maybe<Scalars['String']>;
  pool_action?: Maybe<Scalars['String']>;
  pool_token_deployer_address?: Maybe<Scalars['String']>;
  pool_token_name?: Maybe<Scalars['String']>;
  sender_address?: Maybe<Scalars['String']>;
  token_x?: Maybe<Scalars['String']>;
  token_x_amount?: Maybe<Scalars['bigint']>;
  token_x_fee?: Maybe<Scalars['bigint']>;
  token_x_fee_rebate?: Maybe<Scalars['bigint']>;
  token_y?: Maybe<Scalars['String']>;
  token_y_amount?: Maybe<Scalars['bigint']>;
  token_y_fee?: Maybe<Scalars['bigint']>;
  token_y_fee_rebate?: Maybe<Scalars['bigint']>;
  tx_id?: Maybe<Scalars['String']>;
  tx_index?: Maybe<Scalars['numeric']>;
};

/** response of any mutation on the table "laplace.swap_records" */
export type LaplaceSwapRecordsMutationResponse = {
  __typename?: 'laplace_swap_records_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceSwapRecords>;
};

/** on_conflict condition type for table "laplace.swap_records" */
export type LaplaceSwapRecordsOnConflict = {
  constraint: LaplaceSwapRecordsConstraint;
  update_columns?: Array<LaplaceSwapRecordsUpdateColumn>;
  where?: InputMaybe<LaplaceSwapRecordsBoolExp>;
};

/** Ordering options when selecting data from "laplace.swap_records". */
export type LaplaceSwapRecordsOrderBy = {
  block_height?: InputMaybe<OrderBy>;
  burn_block_time?: InputMaybe<OrderBy>;
  contract_id?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  function_name?: InputMaybe<OrderBy>;
  pool_action?: InputMaybe<OrderBy>;
  pool_token_deployer_address?: InputMaybe<OrderBy>;
  pool_token_name?: InputMaybe<OrderBy>;
  sender_address?: InputMaybe<OrderBy>;
  token_x?: InputMaybe<OrderBy>;
  token_x_amount?: InputMaybe<OrderBy>;
  token_x_fee?: InputMaybe<OrderBy>;
  token_x_fee_rebate?: InputMaybe<OrderBy>;
  token_y?: InputMaybe<OrderBy>;
  token_y_amount?: InputMaybe<OrderBy>;
  token_y_fee?: InputMaybe<OrderBy>;
  token_y_fee_rebate?: InputMaybe<OrderBy>;
  tx_id?: InputMaybe<OrderBy>;
  tx_index?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.swap_records */
export type LaplaceSwapRecordsPkColumnsInput = {
  event_index: Scalars['numeric'];
  tx_id: Scalars['String'];
};

/** select columns of table "laplace.swap_records" */
export enum LaplaceSwapRecordsSelectColumn {
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  ContractId = 'contract_id',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  FunctionName = 'function_name',
  /** column name */
  PoolAction = 'pool_action',
  /** column name */
  PoolTokenDeployerAddress = 'pool_token_deployer_address',
  /** column name */
  PoolTokenName = 'pool_token_name',
  /** column name */
  SenderAddress = 'sender_address',
  /** column name */
  TokenX = 'token_x',
  /** column name */
  TokenXAmount = 'token_x_amount',
  /** column name */
  TokenXFee = 'token_x_fee',
  /** column name */
  TokenXFeeRebate = 'token_x_fee_rebate',
  /** column name */
  TokenY = 'token_y',
  /** column name */
  TokenYAmount = 'token_y_amount',
  /** column name */
  TokenYFee = 'token_y_fee',
  /** column name */
  TokenYFeeRebate = 'token_y_fee_rebate',
  /** column name */
  TxId = 'tx_id',
  /** column name */
  TxIndex = 'tx_index'
}

/** input type for updating data in table "laplace.swap_records" */
export type LaplaceSwapRecordsSetInput = {
  block_height?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  contract_id?: InputMaybe<Scalars['String']>;
  event_index?: InputMaybe<Scalars['numeric']>;
  function_name?: InputMaybe<Scalars['String']>;
  pool_action?: InputMaybe<Scalars['String']>;
  pool_token_deployer_address?: InputMaybe<Scalars['String']>;
  pool_token_name?: InputMaybe<Scalars['String']>;
  sender_address?: InputMaybe<Scalars['String']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_x_amount?: InputMaybe<Scalars['bigint']>;
  token_x_fee?: InputMaybe<Scalars['bigint']>;
  token_x_fee_rebate?: InputMaybe<Scalars['bigint']>;
  token_y?: InputMaybe<Scalars['String']>;
  token_y_amount?: InputMaybe<Scalars['bigint']>;
  token_y_fee?: InputMaybe<Scalars['bigint']>;
  token_y_fee_rebate?: InputMaybe<Scalars['bigint']>;
  tx_id?: InputMaybe<Scalars['String']>;
  tx_index?: InputMaybe<Scalars['numeric']>;
};

/** aggregate stddev on columns */
export type LaplaceSwapRecordsStddevFields = {
  __typename?: 'laplace_swap_records_stddev_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  event_index?: Maybe<Scalars['Float']>;
  token_x_amount?: Maybe<Scalars['Float']>;
  token_x_fee?: Maybe<Scalars['Float']>;
  token_x_fee_rebate?: Maybe<Scalars['Float']>;
  token_y_amount?: Maybe<Scalars['Float']>;
  token_y_fee?: Maybe<Scalars['Float']>;
  token_y_fee_rebate?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceSwapRecordsStddevPopFields = {
  __typename?: 'laplace_swap_records_stddev_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  event_index?: Maybe<Scalars['Float']>;
  token_x_amount?: Maybe<Scalars['Float']>;
  token_x_fee?: Maybe<Scalars['Float']>;
  token_x_fee_rebate?: Maybe<Scalars['Float']>;
  token_y_amount?: Maybe<Scalars['Float']>;
  token_y_fee?: Maybe<Scalars['Float']>;
  token_y_fee_rebate?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceSwapRecordsStddevSampFields = {
  __typename?: 'laplace_swap_records_stddev_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  event_index?: Maybe<Scalars['Float']>;
  token_x_amount?: Maybe<Scalars['Float']>;
  token_x_fee?: Maybe<Scalars['Float']>;
  token_x_fee_rebate?: Maybe<Scalars['Float']>;
  token_y_amount?: Maybe<Scalars['Float']>;
  token_y_fee?: Maybe<Scalars['Float']>;
  token_y_fee_rebate?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_swap_records" */
export type LaplaceSwapRecordsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceSwapRecordsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceSwapRecordsStreamCursorValueInput = {
  block_height?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  contract_id?: InputMaybe<Scalars['String']>;
  event_index?: InputMaybe<Scalars['numeric']>;
  function_name?: InputMaybe<Scalars['String']>;
  pool_action?: InputMaybe<Scalars['String']>;
  pool_token_deployer_address?: InputMaybe<Scalars['String']>;
  pool_token_name?: InputMaybe<Scalars['String']>;
  sender_address?: InputMaybe<Scalars['String']>;
  token_x?: InputMaybe<Scalars['String']>;
  token_x_amount?: InputMaybe<Scalars['bigint']>;
  token_x_fee?: InputMaybe<Scalars['bigint']>;
  token_x_fee_rebate?: InputMaybe<Scalars['bigint']>;
  token_y?: InputMaybe<Scalars['String']>;
  token_y_amount?: InputMaybe<Scalars['bigint']>;
  token_y_fee?: InputMaybe<Scalars['bigint']>;
  token_y_fee_rebate?: InputMaybe<Scalars['bigint']>;
  tx_id?: InputMaybe<Scalars['String']>;
  tx_index?: InputMaybe<Scalars['numeric']>;
};

/** aggregate sum on columns */
export type LaplaceSwapRecordsSumFields = {
  __typename?: 'laplace_swap_records_sum_fields';
  block_height?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  event_index?: Maybe<Scalars['numeric']>;
  token_x_amount?: Maybe<Scalars['bigint']>;
  token_x_fee?: Maybe<Scalars['bigint']>;
  token_x_fee_rebate?: Maybe<Scalars['bigint']>;
  token_y_amount?: Maybe<Scalars['bigint']>;
  token_y_fee?: Maybe<Scalars['bigint']>;
  token_y_fee_rebate?: Maybe<Scalars['bigint']>;
  tx_index?: Maybe<Scalars['numeric']>;
};

/** update columns of table "laplace.swap_records" */
export enum LaplaceSwapRecordsUpdateColumn {
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  ContractId = 'contract_id',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  FunctionName = 'function_name',
  /** column name */
  PoolAction = 'pool_action',
  /** column name */
  PoolTokenDeployerAddress = 'pool_token_deployer_address',
  /** column name */
  PoolTokenName = 'pool_token_name',
  /** column name */
  SenderAddress = 'sender_address',
  /** column name */
  TokenX = 'token_x',
  /** column name */
  TokenXAmount = 'token_x_amount',
  /** column name */
  TokenXFee = 'token_x_fee',
  /** column name */
  TokenXFeeRebate = 'token_x_fee_rebate',
  /** column name */
  TokenY = 'token_y',
  /** column name */
  TokenYAmount = 'token_y_amount',
  /** column name */
  TokenYFee = 'token_y_fee',
  /** column name */
  TokenYFeeRebate = 'token_y_fee_rebate',
  /** column name */
  TxId = 'tx_id',
  /** column name */
  TxIndex = 'tx_index'
}

export type LaplaceSwapRecordsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceSwapRecordsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceSwapRecordsSetInput>;
  where: LaplaceSwapRecordsBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceSwapRecordsVarPopFields = {
  __typename?: 'laplace_swap_records_var_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  event_index?: Maybe<Scalars['Float']>;
  token_x_amount?: Maybe<Scalars['Float']>;
  token_x_fee?: Maybe<Scalars['Float']>;
  token_x_fee_rebate?: Maybe<Scalars['Float']>;
  token_y_amount?: Maybe<Scalars['Float']>;
  token_y_fee?: Maybe<Scalars['Float']>;
  token_y_fee_rebate?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceSwapRecordsVarSampFields = {
  __typename?: 'laplace_swap_records_var_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  event_index?: Maybe<Scalars['Float']>;
  token_x_amount?: Maybe<Scalars['Float']>;
  token_x_fee?: Maybe<Scalars['Float']>;
  token_x_fee_rebate?: Maybe<Scalars['Float']>;
  token_y_amount?: Maybe<Scalars['Float']>;
  token_y_fee?: Maybe<Scalars['Float']>;
  token_y_fee_rebate?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceSwapRecordsVarianceFields = {
  __typename?: 'laplace_swap_records_variance_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  event_index?: Maybe<Scalars['Float']>;
  token_x_amount?: Maybe<Scalars['Float']>;
  token_x_fee?: Maybe<Scalars['Float']>;
  token_x_fee_rebate?: Maybe<Scalars['Float']>;
  token_y_amount?: Maybe<Scalars['Float']>;
  token_y_fee?: Maybe<Scalars['Float']>;
  token_y_fee_rebate?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "laplace.sync_status" */
export type LaplaceSyncStatus = {
  __typename?: 'laplace_sync_status';
  key: Scalars['String'];
  value: Scalars['String'];
};

/** aggregated selection of "laplace.sync_status" */
export type LaplaceSyncStatusAggregate = {
  __typename?: 'laplace_sync_status_aggregate';
  aggregate?: Maybe<LaplaceSyncStatusAggregateFields>;
  nodes: Array<LaplaceSyncStatus>;
};

/** aggregate fields of "laplace.sync_status" */
export type LaplaceSyncStatusAggregateFields = {
  __typename?: 'laplace_sync_status_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<LaplaceSyncStatusMaxFields>;
  min?: Maybe<LaplaceSyncStatusMinFields>;
};


/** aggregate fields of "laplace.sync_status" */
export type LaplaceSyncStatusAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceSyncStatusSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "laplace.sync_status". All fields are combined with a logical 'AND'. */
export type LaplaceSyncStatusBoolExp = {
  _and?: InputMaybe<Array<LaplaceSyncStatusBoolExp>>;
  _not?: InputMaybe<LaplaceSyncStatusBoolExp>;
  _or?: InputMaybe<Array<LaplaceSyncStatusBoolExp>>;
  key?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "laplace.sync_status" */
export enum LaplaceSyncStatusConstraint {
  /** unique or primary key constraint on columns "key" */
  SyncStatusPk = 'sync_status_pk'
}

/** input type for inserting data into table "laplace.sync_status" */
export type LaplaceSyncStatusInsertInput = {
  key?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type LaplaceSyncStatusMaxFields = {
  __typename?: 'laplace_sync_status_max_fields';
  key?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LaplaceSyncStatusMinFields = {
  __typename?: 'laplace_sync_status_min_fields';
  key?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "laplace.sync_status" */
export type LaplaceSyncStatusMutationResponse = {
  __typename?: 'laplace_sync_status_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceSyncStatus>;
};

/** on_conflict condition type for table "laplace.sync_status" */
export type LaplaceSyncStatusOnConflict = {
  constraint: LaplaceSyncStatusConstraint;
  update_columns?: Array<LaplaceSyncStatusUpdateColumn>;
  where?: InputMaybe<LaplaceSyncStatusBoolExp>;
};

/** Ordering options when selecting data from "laplace.sync_status". */
export type LaplaceSyncStatusOrderBy = {
  key?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.sync_status */
export type LaplaceSyncStatusPkColumnsInput = {
  key: Scalars['String'];
};

/** select columns of table "laplace.sync_status" */
export enum LaplaceSyncStatusSelectColumn {
  /** column name */
  Key = 'key',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "laplace.sync_status" */
export type LaplaceSyncStatusSetInput = {
  key?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "laplace_sync_status" */
export type LaplaceSyncStatusStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceSyncStatusStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceSyncStatusStreamCursorValueInput = {
  key?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "laplace.sync_status" */
export enum LaplaceSyncStatusUpdateColumn {
  /** column name */
  Key = 'key',
  /** column name */
  Value = 'value'
}

export type LaplaceSyncStatusUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceSyncStatusSetInput>;
  where: LaplaceSyncStatusBoolExp;
};

/** blocks synced by block pollers */
export type LaplaceSyncedBlocks = {
  __typename?: 'laplace_synced_blocks';
  block_hash: Scalars['bytea'];
  block_height: Scalars['Int'];
  burn_block_hash: Scalars['bytea'];
  burn_block_height: Scalars['Int'];
  burn_block_time: Scalars['Int'];
  index_block_hash: Scalars['bytea'];
  miner_txid: Scalars['bytea'];
  parent_block_hash: Scalars['bytea'];
  parent_index_block_hash: Scalars['bytea'];
  parent_microblock_hash: Scalars['bytea'];
  parent_microblock_sequence: Scalars['Int'];
};

/** aggregated selection of "laplace.synced_blocks" */
export type LaplaceSyncedBlocksAggregate = {
  __typename?: 'laplace_synced_blocks_aggregate';
  aggregate?: Maybe<LaplaceSyncedBlocksAggregateFields>;
  nodes: Array<LaplaceSyncedBlocks>;
};

/** aggregate fields of "laplace.synced_blocks" */
export type LaplaceSyncedBlocksAggregateFields = {
  __typename?: 'laplace_synced_blocks_aggregate_fields';
  avg?: Maybe<LaplaceSyncedBlocksAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceSyncedBlocksMaxFields>;
  min?: Maybe<LaplaceSyncedBlocksMinFields>;
  stddev?: Maybe<LaplaceSyncedBlocksStddevFields>;
  stddev_pop?: Maybe<LaplaceSyncedBlocksStddevPopFields>;
  stddev_samp?: Maybe<LaplaceSyncedBlocksStddevSampFields>;
  sum?: Maybe<LaplaceSyncedBlocksSumFields>;
  var_pop?: Maybe<LaplaceSyncedBlocksVarPopFields>;
  var_samp?: Maybe<LaplaceSyncedBlocksVarSampFields>;
  variance?: Maybe<LaplaceSyncedBlocksVarianceFields>;
};


/** aggregate fields of "laplace.synced_blocks" */
export type LaplaceSyncedBlocksAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceSyncedBlocksSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LaplaceSyncedBlocksAvgFields = {
  __typename?: 'laplace_synced_blocks_avg_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  parent_microblock_sequence?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.synced_blocks". All fields are combined with a logical 'AND'. */
export type LaplaceSyncedBlocksBoolExp = {
  _and?: InputMaybe<Array<LaplaceSyncedBlocksBoolExp>>;
  _not?: InputMaybe<LaplaceSyncedBlocksBoolExp>;
  _or?: InputMaybe<Array<LaplaceSyncedBlocksBoolExp>>;
  block_hash?: InputMaybe<ByteaComparisonExp>;
  block_height?: InputMaybe<IntComparisonExp>;
  burn_block_hash?: InputMaybe<ByteaComparisonExp>;
  burn_block_height?: InputMaybe<IntComparisonExp>;
  burn_block_time?: InputMaybe<IntComparisonExp>;
  index_block_hash?: InputMaybe<ByteaComparisonExp>;
  miner_txid?: InputMaybe<ByteaComparisonExp>;
  parent_block_hash?: InputMaybe<ByteaComparisonExp>;
  parent_index_block_hash?: InputMaybe<ByteaComparisonExp>;
  parent_microblock_hash?: InputMaybe<ByteaComparisonExp>;
  parent_microblock_sequence?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "laplace.synced_blocks" */
export enum LaplaceSyncedBlocksConstraint {
  /** unique or primary key constraint on columns "block_height" */
  SyncedBlocksPkey = 'synced_blocks_pkey'
}

/** input type for incrementing numeric columns in table "laplace.synced_blocks" */
export type LaplaceSyncedBlocksIncInput = {
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  parent_microblock_sequence?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "laplace.synced_blocks" */
export type LaplaceSyncedBlocksInsertInput = {
  block_hash?: InputMaybe<Scalars['bytea']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_hash?: InputMaybe<Scalars['bytea']>;
  burn_block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  index_block_hash?: InputMaybe<Scalars['bytea']>;
  miner_txid?: InputMaybe<Scalars['bytea']>;
  parent_block_hash?: InputMaybe<Scalars['bytea']>;
  parent_index_block_hash?: InputMaybe<Scalars['bytea']>;
  parent_microblock_hash?: InputMaybe<Scalars['bytea']>;
  parent_microblock_sequence?: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type LaplaceSyncedBlocksMaxFields = {
  __typename?: 'laplace_synced_blocks_max_fields';
  block_height?: Maybe<Scalars['Int']>;
  burn_block_height?: Maybe<Scalars['Int']>;
  burn_block_time?: Maybe<Scalars['Int']>;
  parent_microblock_sequence?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type LaplaceSyncedBlocksMinFields = {
  __typename?: 'laplace_synced_blocks_min_fields';
  block_height?: Maybe<Scalars['Int']>;
  burn_block_height?: Maybe<Scalars['Int']>;
  burn_block_time?: Maybe<Scalars['Int']>;
  parent_microblock_sequence?: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "laplace.synced_blocks" */
export type LaplaceSyncedBlocksMutationResponse = {
  __typename?: 'laplace_synced_blocks_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceSyncedBlocks>;
};

/** on_conflict condition type for table "laplace.synced_blocks" */
export type LaplaceSyncedBlocksOnConflict = {
  constraint: LaplaceSyncedBlocksConstraint;
  update_columns?: Array<LaplaceSyncedBlocksUpdateColumn>;
  where?: InputMaybe<LaplaceSyncedBlocksBoolExp>;
};

/** Ordering options when selecting data from "laplace.synced_blocks". */
export type LaplaceSyncedBlocksOrderBy = {
  block_hash?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  burn_block_hash?: InputMaybe<OrderBy>;
  burn_block_height?: InputMaybe<OrderBy>;
  burn_block_time?: InputMaybe<OrderBy>;
  index_block_hash?: InputMaybe<OrderBy>;
  miner_txid?: InputMaybe<OrderBy>;
  parent_block_hash?: InputMaybe<OrderBy>;
  parent_index_block_hash?: InputMaybe<OrderBy>;
  parent_microblock_hash?: InputMaybe<OrderBy>;
  parent_microblock_sequence?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.synced_blocks */
export type LaplaceSyncedBlocksPkColumnsInput = {
  block_height: Scalars['Int'];
};

/** select columns of table "laplace.synced_blocks" */
export enum LaplaceSyncedBlocksSelectColumn {
  /** column name */
  BlockHash = 'block_hash',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockHash = 'burn_block_hash',
  /** column name */
  BurnBlockHeight = 'burn_block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  IndexBlockHash = 'index_block_hash',
  /** column name */
  MinerTxid = 'miner_txid',
  /** column name */
  ParentBlockHash = 'parent_block_hash',
  /** column name */
  ParentIndexBlockHash = 'parent_index_block_hash',
  /** column name */
  ParentMicroblockHash = 'parent_microblock_hash',
  /** column name */
  ParentMicroblockSequence = 'parent_microblock_sequence'
}

/** input type for updating data in table "laplace.synced_blocks" */
export type LaplaceSyncedBlocksSetInput = {
  block_hash?: InputMaybe<Scalars['bytea']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_hash?: InputMaybe<Scalars['bytea']>;
  burn_block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  index_block_hash?: InputMaybe<Scalars['bytea']>;
  miner_txid?: InputMaybe<Scalars['bytea']>;
  parent_block_hash?: InputMaybe<Scalars['bytea']>;
  parent_index_block_hash?: InputMaybe<Scalars['bytea']>;
  parent_microblock_hash?: InputMaybe<Scalars['bytea']>;
  parent_microblock_sequence?: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type LaplaceSyncedBlocksStddevFields = {
  __typename?: 'laplace_synced_blocks_stddev_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  parent_microblock_sequence?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceSyncedBlocksStddevPopFields = {
  __typename?: 'laplace_synced_blocks_stddev_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  parent_microblock_sequence?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceSyncedBlocksStddevSampFields = {
  __typename?: 'laplace_synced_blocks_stddev_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  parent_microblock_sequence?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_synced_blocks" */
export type LaplaceSyncedBlocksStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceSyncedBlocksStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceSyncedBlocksStreamCursorValueInput = {
  block_hash?: InputMaybe<Scalars['bytea']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_hash?: InputMaybe<Scalars['bytea']>;
  burn_block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  index_block_hash?: InputMaybe<Scalars['bytea']>;
  miner_txid?: InputMaybe<Scalars['bytea']>;
  parent_block_hash?: InputMaybe<Scalars['bytea']>;
  parent_index_block_hash?: InputMaybe<Scalars['bytea']>;
  parent_microblock_hash?: InputMaybe<Scalars['bytea']>;
  parent_microblock_sequence?: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type LaplaceSyncedBlocksSumFields = {
  __typename?: 'laplace_synced_blocks_sum_fields';
  block_height?: Maybe<Scalars['Int']>;
  burn_block_height?: Maybe<Scalars['Int']>;
  burn_block_time?: Maybe<Scalars['Int']>;
  parent_microblock_sequence?: Maybe<Scalars['Int']>;
};

/** update columns of table "laplace.synced_blocks" */
export enum LaplaceSyncedBlocksUpdateColumn {
  /** column name */
  BlockHash = 'block_hash',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockHash = 'burn_block_hash',
  /** column name */
  BurnBlockHeight = 'burn_block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  IndexBlockHash = 'index_block_hash',
  /** column name */
  MinerTxid = 'miner_txid',
  /** column name */
  ParentBlockHash = 'parent_block_hash',
  /** column name */
  ParentIndexBlockHash = 'parent_index_block_hash',
  /** column name */
  ParentMicroblockHash = 'parent_microblock_hash',
  /** column name */
  ParentMicroblockSequence = 'parent_microblock_sequence'
}

export type LaplaceSyncedBlocksUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceSyncedBlocksIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceSyncedBlocksSetInput>;
  where: LaplaceSyncedBlocksBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceSyncedBlocksVarPopFields = {
  __typename?: 'laplace_synced_blocks_var_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  parent_microblock_sequence?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceSyncedBlocksVarSampFields = {
  __typename?: 'laplace_synced_blocks_var_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  parent_microblock_sequence?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceSyncedBlocksVarianceFields = {
  __typename?: 'laplace_synced_blocks_variance_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  parent_microblock_sequence?: Maybe<Scalars['Float']>;
};

/** ALEX token stats using read-only call */
export type LaplaceTokenStats = {
  __typename?: 'laplace_token_stats';
  block_height: Scalars['numeric'];
  decimals: Scalars['numeric'];
  token_name: Scalars['String'];
  total_supply: Scalars['numeric'];
};

/** aggregated selection of "laplace.token_stats" */
export type LaplaceTokenStatsAggregate = {
  __typename?: 'laplace_token_stats_aggregate';
  aggregate?: Maybe<LaplaceTokenStatsAggregateFields>;
  nodes: Array<LaplaceTokenStats>;
};

/** aggregate fields of "laplace.token_stats" */
export type LaplaceTokenStatsAggregateFields = {
  __typename?: 'laplace_token_stats_aggregate_fields';
  avg?: Maybe<LaplaceTokenStatsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceTokenStatsMaxFields>;
  min?: Maybe<LaplaceTokenStatsMinFields>;
  stddev?: Maybe<LaplaceTokenStatsStddevFields>;
  stddev_pop?: Maybe<LaplaceTokenStatsStddevPopFields>;
  stddev_samp?: Maybe<LaplaceTokenStatsStddevSampFields>;
  sum?: Maybe<LaplaceTokenStatsSumFields>;
  var_pop?: Maybe<LaplaceTokenStatsVarPopFields>;
  var_samp?: Maybe<LaplaceTokenStatsVarSampFields>;
  variance?: Maybe<LaplaceTokenStatsVarianceFields>;
};


/** aggregate fields of "laplace.token_stats" */
export type LaplaceTokenStatsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceTokenStatsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LaplaceTokenStatsAvgFields = {
  __typename?: 'laplace_token_stats_avg_fields';
  block_height?: Maybe<Scalars['Float']>;
  decimals?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.token_stats". All fields are combined with a logical 'AND'. */
export type LaplaceTokenStatsBoolExp = {
  _and?: InputMaybe<Array<LaplaceTokenStatsBoolExp>>;
  _not?: InputMaybe<LaplaceTokenStatsBoolExp>;
  _or?: InputMaybe<Array<LaplaceTokenStatsBoolExp>>;
  block_height?: InputMaybe<NumericComparisonExp>;
  decimals?: InputMaybe<NumericComparisonExp>;
  token_name?: InputMaybe<StringComparisonExp>;
  total_supply?: InputMaybe<NumericComparisonExp>;
};

/** unique or primary key constraints on table "laplace.token_stats" */
export enum LaplaceTokenStatsConstraint {
  /** unique or primary key constraint on columns "token_name" */
  TokenStatsPkey = 'token_stats_pkey'
}

/** input type for incrementing numeric columns in table "laplace.token_stats" */
export type LaplaceTokenStatsIncInput = {
  block_height?: InputMaybe<Scalars['numeric']>;
  decimals?: InputMaybe<Scalars['numeric']>;
  total_supply?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "laplace.token_stats" */
export type LaplaceTokenStatsInsertInput = {
  block_height?: InputMaybe<Scalars['numeric']>;
  decimals?: InputMaybe<Scalars['numeric']>;
  token_name?: InputMaybe<Scalars['String']>;
  total_supply?: InputMaybe<Scalars['numeric']>;
};

/** aggregate max on columns */
export type LaplaceTokenStatsMaxFields = {
  __typename?: 'laplace_token_stats_max_fields';
  block_height?: Maybe<Scalars['numeric']>;
  decimals?: Maybe<Scalars['numeric']>;
  token_name?: Maybe<Scalars['String']>;
  total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type LaplaceTokenStatsMinFields = {
  __typename?: 'laplace_token_stats_min_fields';
  block_height?: Maybe<Scalars['numeric']>;
  decimals?: Maybe<Scalars['numeric']>;
  token_name?: Maybe<Scalars['String']>;
  total_supply?: Maybe<Scalars['numeric']>;
};

/** response of any mutation on the table "laplace.token_stats" */
export type LaplaceTokenStatsMutationResponse = {
  __typename?: 'laplace_token_stats_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceTokenStats>;
};

/** on_conflict condition type for table "laplace.token_stats" */
export type LaplaceTokenStatsOnConflict = {
  constraint: LaplaceTokenStatsConstraint;
  update_columns?: Array<LaplaceTokenStatsUpdateColumn>;
  where?: InputMaybe<LaplaceTokenStatsBoolExp>;
};

/** Ordering options when selecting data from "laplace.token_stats". */
export type LaplaceTokenStatsOrderBy = {
  block_height?: InputMaybe<OrderBy>;
  decimals?: InputMaybe<OrderBy>;
  token_name?: InputMaybe<OrderBy>;
  total_supply?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.token_stats */
export type LaplaceTokenStatsPkColumnsInput = {
  token_name: Scalars['String'];
};

/** select columns of table "laplace.token_stats" */
export enum LaplaceTokenStatsSelectColumn {
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  Decimals = 'decimals',
  /** column name */
  TokenName = 'token_name',
  /** column name */
  TotalSupply = 'total_supply'
}

/** input type for updating data in table "laplace.token_stats" */
export type LaplaceTokenStatsSetInput = {
  block_height?: InputMaybe<Scalars['numeric']>;
  decimals?: InputMaybe<Scalars['numeric']>;
  token_name?: InputMaybe<Scalars['String']>;
  total_supply?: InputMaybe<Scalars['numeric']>;
};

/** aggregate stddev on columns */
export type LaplaceTokenStatsStddevFields = {
  __typename?: 'laplace_token_stats_stddev_fields';
  block_height?: Maybe<Scalars['Float']>;
  decimals?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceTokenStatsStddevPopFields = {
  __typename?: 'laplace_token_stats_stddev_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  decimals?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceTokenStatsStddevSampFields = {
  __typename?: 'laplace_token_stats_stddev_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  decimals?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_token_stats" */
export type LaplaceTokenStatsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceTokenStatsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceTokenStatsStreamCursorValueInput = {
  block_height?: InputMaybe<Scalars['numeric']>;
  decimals?: InputMaybe<Scalars['numeric']>;
  token_name?: InputMaybe<Scalars['String']>;
  total_supply?: InputMaybe<Scalars['numeric']>;
};

/** aggregate sum on columns */
export type LaplaceTokenStatsSumFields = {
  __typename?: 'laplace_token_stats_sum_fields';
  block_height?: Maybe<Scalars['numeric']>;
  decimals?: Maybe<Scalars['numeric']>;
  total_supply?: Maybe<Scalars['numeric']>;
};

/** update columns of table "laplace.token_stats" */
export enum LaplaceTokenStatsUpdateColumn {
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  Decimals = 'decimals',
  /** column name */
  TokenName = 'token_name',
  /** column name */
  TotalSupply = 'total_supply'
}

export type LaplaceTokenStatsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceTokenStatsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceTokenStatsSetInput>;
  where: LaplaceTokenStatsBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceTokenStatsVarPopFields = {
  __typename?: 'laplace_token_stats_var_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  decimals?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceTokenStatsVarSampFields = {
  __typename?: 'laplace_token_stats_var_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  decimals?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceTokenStatsVarianceFields = {
  __typename?: 'laplace_token_stats_variance_fields';
  block_height?: Maybe<Scalars['Float']>;
  decimals?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
};

/** ALEX token tvl */
export type LaplaceTokenTvl = {
  __typename?: 'laplace_token_tvl';
  block_height: Scalars['numeric'];
  burn_block_time: Scalars['numeric'];
  sync_at: Scalars['timestamptz'];
  token: Scalars['String'];
  tvl: Scalars['numeric'];
};

/** aggregated selection of "laplace.token_tvl" */
export type LaplaceTokenTvlAggregate = {
  __typename?: 'laplace_token_tvl_aggregate';
  aggregate?: Maybe<LaplaceTokenTvlAggregateFields>;
  nodes: Array<LaplaceTokenTvl>;
};

/** aggregate fields of "laplace.token_tvl" */
export type LaplaceTokenTvlAggregateFields = {
  __typename?: 'laplace_token_tvl_aggregate_fields';
  avg?: Maybe<LaplaceTokenTvlAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceTokenTvlMaxFields>;
  min?: Maybe<LaplaceTokenTvlMinFields>;
  stddev?: Maybe<LaplaceTokenTvlStddevFields>;
  stddev_pop?: Maybe<LaplaceTokenTvlStddevPopFields>;
  stddev_samp?: Maybe<LaplaceTokenTvlStddevSampFields>;
  sum?: Maybe<LaplaceTokenTvlSumFields>;
  var_pop?: Maybe<LaplaceTokenTvlVarPopFields>;
  var_samp?: Maybe<LaplaceTokenTvlVarSampFields>;
  variance?: Maybe<LaplaceTokenTvlVarianceFields>;
};


/** aggregate fields of "laplace.token_tvl" */
export type LaplaceTokenTvlAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceTokenTvlSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LaplaceTokenTvlAvgFields = {
  __typename?: 'laplace_token_tvl_avg_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  tvl?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.token_tvl". All fields are combined with a logical 'AND'. */
export type LaplaceTokenTvlBoolExp = {
  _and?: InputMaybe<Array<LaplaceTokenTvlBoolExp>>;
  _not?: InputMaybe<LaplaceTokenTvlBoolExp>;
  _or?: InputMaybe<Array<LaplaceTokenTvlBoolExp>>;
  block_height?: InputMaybe<NumericComparisonExp>;
  burn_block_time?: InputMaybe<NumericComparisonExp>;
  sync_at?: InputMaybe<TimestamptzComparisonExp>;
  token?: InputMaybe<StringComparisonExp>;
  tvl?: InputMaybe<NumericComparisonExp>;
};

/** unique or primary key constraints on table "laplace.token_tvl" */
export enum LaplaceTokenTvlConstraint {
  /** unique or primary key constraint on columns "block_height", "token" */
  TokenTvlPkey = 'token_tvl_pkey'
}

/** input type for incrementing numeric columns in table "laplace.token_tvl" */
export type LaplaceTokenTvlIncInput = {
  block_height?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  tvl?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "laplace.token_tvl" */
export type LaplaceTokenTvlInsertInput = {
  block_height?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token?: InputMaybe<Scalars['String']>;
  tvl?: InputMaybe<Scalars['numeric']>;
};

/** aggregate max on columns */
export type LaplaceTokenTvlMaxFields = {
  __typename?: 'laplace_token_tvl_max_fields';
  block_height?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token?: Maybe<Scalars['String']>;
  tvl?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type LaplaceTokenTvlMinFields = {
  __typename?: 'laplace_token_tvl_min_fields';
  block_height?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  token?: Maybe<Scalars['String']>;
  tvl?: Maybe<Scalars['numeric']>;
};

/** response of any mutation on the table "laplace.token_tvl" */
export type LaplaceTokenTvlMutationResponse = {
  __typename?: 'laplace_token_tvl_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceTokenTvl>;
};

/** on_conflict condition type for table "laplace.token_tvl" */
export type LaplaceTokenTvlOnConflict = {
  constraint: LaplaceTokenTvlConstraint;
  update_columns?: Array<LaplaceTokenTvlUpdateColumn>;
  where?: InputMaybe<LaplaceTokenTvlBoolExp>;
};

/** Ordering options when selecting data from "laplace.token_tvl". */
export type LaplaceTokenTvlOrderBy = {
  block_height?: InputMaybe<OrderBy>;
  burn_block_time?: InputMaybe<OrderBy>;
  sync_at?: InputMaybe<OrderBy>;
  token?: InputMaybe<OrderBy>;
  tvl?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.token_tvl */
export type LaplaceTokenTvlPkColumnsInput = {
  block_height: Scalars['numeric'];
  token: Scalars['String'];
};

/** select columns of table "laplace.token_tvl" */
export enum LaplaceTokenTvlSelectColumn {
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  Token = 'token',
  /** column name */
  Tvl = 'tvl'
}

/** input type for updating data in table "laplace.token_tvl" */
export type LaplaceTokenTvlSetInput = {
  block_height?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token?: InputMaybe<Scalars['String']>;
  tvl?: InputMaybe<Scalars['numeric']>;
};

/** aggregate stddev on columns */
export type LaplaceTokenTvlStddevFields = {
  __typename?: 'laplace_token_tvl_stddev_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  tvl?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceTokenTvlStddevPopFields = {
  __typename?: 'laplace_token_tvl_stddev_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  tvl?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceTokenTvlStddevSampFields = {
  __typename?: 'laplace_token_tvl_stddev_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  tvl?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_token_tvl" */
export type LaplaceTokenTvlStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceTokenTvlStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceTokenTvlStreamCursorValueInput = {
  block_height?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  token?: InputMaybe<Scalars['String']>;
  tvl?: InputMaybe<Scalars['numeric']>;
};

/** aggregate sum on columns */
export type LaplaceTokenTvlSumFields = {
  __typename?: 'laplace_token_tvl_sum_fields';
  block_height?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  tvl?: Maybe<Scalars['numeric']>;
};

/** update columns of table "laplace.token_tvl" */
export enum LaplaceTokenTvlUpdateColumn {
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  Token = 'token',
  /** column name */
  Tvl = 'tvl'
}

export type LaplaceTokenTvlUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceTokenTvlIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceTokenTvlSetInput>;
  where: LaplaceTokenTvlBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceTokenTvlVarPopFields = {
  __typename?: 'laplace_token_tvl_var_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  tvl?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceTokenTvlVarSampFields = {
  __typename?: 'laplace_token_tvl_var_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  tvl?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceTokenTvlVarianceFields = {
  __typename?: 'laplace_token_tvl_variance_fields';
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  tvl?: Maybe<Scalars['Float']>;
};

/** ALEX yield token pool */
export type LaplaceYieldTokenPool = {
  __typename?: 'laplace_yield_token_pool';
  balance_token: Scalars['numeric'];
  balance_virtual: Scalars['numeric'];
  balance_yield_token: Scalars['numeric'];
  block_height: Scalars['numeric'];
  borrow_apr: Scalars['numeric'];
  burn_block_time: Scalars['numeric'];
  deposit_apr: Scalars['numeric'];
  expiry: Scalars['numeric'];
  fee_rate_token: Scalars['numeric'];
  fee_rate_yield_token: Scalars['numeric'];
  fee_rebate: Scalars['numeric'];
  fee_to_address: Scalars['String'];
  listed: Scalars['numeric'];
  max_expiry: Scalars['numeric'];
  min_fee?: Maybe<Scalars['numeric']>;
  oracle_average: Scalars['numeric'];
  oracle_enabled: Scalars['Boolean'];
  oracle_resilient: Scalars['numeric'];
  pool_token: Scalars['String'];
  small_threshold?: Maybe<Scalars['numeric']>;
  sync_at: Scalars['timestamptz'];
  total_supply: Scalars['numeric'];
  underlying_token: Scalars['String'];
  yield_per_token?: Maybe<Scalars['numeric']>;
  yield_token: Scalars['String'];
  yield_token_price: Scalars['numeric'];
};

/** aggregated selection of "laplace.yield_token_pool" */
export type LaplaceYieldTokenPoolAggregate = {
  __typename?: 'laplace_yield_token_pool_aggregate';
  aggregate?: Maybe<LaplaceYieldTokenPoolAggregateFields>;
  nodes: Array<LaplaceYieldTokenPool>;
};

/** aggregate fields of "laplace.yield_token_pool" */
export type LaplaceYieldTokenPoolAggregateFields = {
  __typename?: 'laplace_yield_token_pool_aggregate_fields';
  avg?: Maybe<LaplaceYieldTokenPoolAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LaplaceYieldTokenPoolMaxFields>;
  min?: Maybe<LaplaceYieldTokenPoolMinFields>;
  stddev?: Maybe<LaplaceYieldTokenPoolStddevFields>;
  stddev_pop?: Maybe<LaplaceYieldTokenPoolStddevPopFields>;
  stddev_samp?: Maybe<LaplaceYieldTokenPoolStddevSampFields>;
  sum?: Maybe<LaplaceYieldTokenPoolSumFields>;
  var_pop?: Maybe<LaplaceYieldTokenPoolVarPopFields>;
  var_samp?: Maybe<LaplaceYieldTokenPoolVarSampFields>;
  variance?: Maybe<LaplaceYieldTokenPoolVarianceFields>;
};


/** aggregate fields of "laplace.yield_token_pool" */
export type LaplaceYieldTokenPoolAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LaplaceYieldTokenPoolSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LaplaceYieldTokenPoolAvgFields = {
  __typename?: 'laplace_yield_token_pool_avg_fields';
  balance_token?: Maybe<Scalars['Float']>;
  balance_virtual?: Maybe<Scalars['Float']>;
  balance_yield_token?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  borrow_apr?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  deposit_apr?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  fee_rate_token?: Maybe<Scalars['Float']>;
  fee_rate_yield_token?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  listed?: Maybe<Scalars['Float']>;
  max_expiry?: Maybe<Scalars['Float']>;
  min_fee?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  small_threshold?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  yield_per_token?: Maybe<Scalars['Float']>;
  yield_token_price?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "laplace.yield_token_pool". All fields are combined with a logical 'AND'. */
export type LaplaceYieldTokenPoolBoolExp = {
  _and?: InputMaybe<Array<LaplaceYieldTokenPoolBoolExp>>;
  _not?: InputMaybe<LaplaceYieldTokenPoolBoolExp>;
  _or?: InputMaybe<Array<LaplaceYieldTokenPoolBoolExp>>;
  balance_token?: InputMaybe<NumericComparisonExp>;
  balance_virtual?: InputMaybe<NumericComparisonExp>;
  balance_yield_token?: InputMaybe<NumericComparisonExp>;
  block_height?: InputMaybe<NumericComparisonExp>;
  borrow_apr?: InputMaybe<NumericComparisonExp>;
  burn_block_time?: InputMaybe<NumericComparisonExp>;
  deposit_apr?: InputMaybe<NumericComparisonExp>;
  expiry?: InputMaybe<NumericComparisonExp>;
  fee_rate_token?: InputMaybe<NumericComparisonExp>;
  fee_rate_yield_token?: InputMaybe<NumericComparisonExp>;
  fee_rebate?: InputMaybe<NumericComparisonExp>;
  fee_to_address?: InputMaybe<StringComparisonExp>;
  listed?: InputMaybe<NumericComparisonExp>;
  max_expiry?: InputMaybe<NumericComparisonExp>;
  min_fee?: InputMaybe<NumericComparisonExp>;
  oracle_average?: InputMaybe<NumericComparisonExp>;
  oracle_enabled?: InputMaybe<BooleanComparisonExp>;
  oracle_resilient?: InputMaybe<NumericComparisonExp>;
  pool_token?: InputMaybe<StringComparisonExp>;
  small_threshold?: InputMaybe<NumericComparisonExp>;
  sync_at?: InputMaybe<TimestamptzComparisonExp>;
  total_supply?: InputMaybe<NumericComparisonExp>;
  underlying_token?: InputMaybe<StringComparisonExp>;
  yield_per_token?: InputMaybe<NumericComparisonExp>;
  yield_token?: InputMaybe<StringComparisonExp>;
  yield_token_price?: InputMaybe<NumericComparisonExp>;
};

/** unique or primary key constraints on table "laplace.yield_token_pool" */
export enum LaplaceYieldTokenPoolConstraint {
  /** unique or primary key constraint on columns "block_height", "expiry", "yield_token" */
  YieldTokenPoolPkey = 'yield_token_pool_pkey'
}

/** input type for incrementing numeric columns in table "laplace.yield_token_pool" */
export type LaplaceYieldTokenPoolIncInput = {
  balance_token?: InputMaybe<Scalars['numeric']>;
  balance_virtual?: InputMaybe<Scalars['numeric']>;
  balance_yield_token?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  borrow_apr?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  deposit_apr?: InputMaybe<Scalars['numeric']>;
  expiry?: InputMaybe<Scalars['numeric']>;
  fee_rate_token?: InputMaybe<Scalars['numeric']>;
  fee_rate_yield_token?: InputMaybe<Scalars['numeric']>;
  fee_rebate?: InputMaybe<Scalars['numeric']>;
  listed?: InputMaybe<Scalars['numeric']>;
  max_expiry?: InputMaybe<Scalars['numeric']>;
  min_fee?: InputMaybe<Scalars['numeric']>;
  oracle_average?: InputMaybe<Scalars['numeric']>;
  oracle_resilient?: InputMaybe<Scalars['numeric']>;
  small_threshold?: InputMaybe<Scalars['numeric']>;
  total_supply?: InputMaybe<Scalars['numeric']>;
  yield_per_token?: InputMaybe<Scalars['numeric']>;
  yield_token_price?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "laplace.yield_token_pool" */
export type LaplaceYieldTokenPoolInsertInput = {
  balance_token?: InputMaybe<Scalars['numeric']>;
  balance_virtual?: InputMaybe<Scalars['numeric']>;
  balance_yield_token?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  borrow_apr?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  deposit_apr?: InputMaybe<Scalars['numeric']>;
  expiry?: InputMaybe<Scalars['numeric']>;
  fee_rate_token?: InputMaybe<Scalars['numeric']>;
  fee_rate_yield_token?: InputMaybe<Scalars['numeric']>;
  fee_rebate?: InputMaybe<Scalars['numeric']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  listed?: InputMaybe<Scalars['numeric']>;
  max_expiry?: InputMaybe<Scalars['numeric']>;
  min_fee?: InputMaybe<Scalars['numeric']>;
  oracle_average?: InputMaybe<Scalars['numeric']>;
  oracle_enabled?: InputMaybe<Scalars['Boolean']>;
  oracle_resilient?: InputMaybe<Scalars['numeric']>;
  pool_token?: InputMaybe<Scalars['String']>;
  small_threshold?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  total_supply?: InputMaybe<Scalars['numeric']>;
  underlying_token?: InputMaybe<Scalars['String']>;
  yield_per_token?: InputMaybe<Scalars['numeric']>;
  yield_token?: InputMaybe<Scalars['String']>;
  yield_token_price?: InputMaybe<Scalars['numeric']>;
};

/** aggregate max on columns */
export type LaplaceYieldTokenPoolMaxFields = {
  __typename?: 'laplace_yield_token_pool_max_fields';
  balance_token?: Maybe<Scalars['numeric']>;
  balance_virtual?: Maybe<Scalars['numeric']>;
  balance_yield_token?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['numeric']>;
  borrow_apr?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  deposit_apr?: Maybe<Scalars['numeric']>;
  expiry?: Maybe<Scalars['numeric']>;
  fee_rate_token?: Maybe<Scalars['numeric']>;
  fee_rate_yield_token?: Maybe<Scalars['numeric']>;
  fee_rebate?: Maybe<Scalars['numeric']>;
  fee_to_address?: Maybe<Scalars['String']>;
  listed?: Maybe<Scalars['numeric']>;
  max_expiry?: Maybe<Scalars['numeric']>;
  min_fee?: Maybe<Scalars['numeric']>;
  oracle_average?: Maybe<Scalars['numeric']>;
  oracle_resilient?: Maybe<Scalars['numeric']>;
  pool_token?: Maybe<Scalars['String']>;
  small_threshold?: Maybe<Scalars['numeric']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  total_supply?: Maybe<Scalars['numeric']>;
  underlying_token?: Maybe<Scalars['String']>;
  yield_per_token?: Maybe<Scalars['numeric']>;
  yield_token?: Maybe<Scalars['String']>;
  yield_token_price?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type LaplaceYieldTokenPoolMinFields = {
  __typename?: 'laplace_yield_token_pool_min_fields';
  balance_token?: Maybe<Scalars['numeric']>;
  balance_virtual?: Maybe<Scalars['numeric']>;
  balance_yield_token?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['numeric']>;
  borrow_apr?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  deposit_apr?: Maybe<Scalars['numeric']>;
  expiry?: Maybe<Scalars['numeric']>;
  fee_rate_token?: Maybe<Scalars['numeric']>;
  fee_rate_yield_token?: Maybe<Scalars['numeric']>;
  fee_rebate?: Maybe<Scalars['numeric']>;
  fee_to_address?: Maybe<Scalars['String']>;
  listed?: Maybe<Scalars['numeric']>;
  max_expiry?: Maybe<Scalars['numeric']>;
  min_fee?: Maybe<Scalars['numeric']>;
  oracle_average?: Maybe<Scalars['numeric']>;
  oracle_resilient?: Maybe<Scalars['numeric']>;
  pool_token?: Maybe<Scalars['String']>;
  small_threshold?: Maybe<Scalars['numeric']>;
  sync_at?: Maybe<Scalars['timestamptz']>;
  total_supply?: Maybe<Scalars['numeric']>;
  underlying_token?: Maybe<Scalars['String']>;
  yield_per_token?: Maybe<Scalars['numeric']>;
  yield_token?: Maybe<Scalars['String']>;
  yield_token_price?: Maybe<Scalars['numeric']>;
};

/** response of any mutation on the table "laplace.yield_token_pool" */
export type LaplaceYieldTokenPoolMutationResponse = {
  __typename?: 'laplace_yield_token_pool_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LaplaceYieldTokenPool>;
};

/** on_conflict condition type for table "laplace.yield_token_pool" */
export type LaplaceYieldTokenPoolOnConflict = {
  constraint: LaplaceYieldTokenPoolConstraint;
  update_columns?: Array<LaplaceYieldTokenPoolUpdateColumn>;
  where?: InputMaybe<LaplaceYieldTokenPoolBoolExp>;
};

/** Ordering options when selecting data from "laplace.yield_token_pool". */
export type LaplaceYieldTokenPoolOrderBy = {
  balance_token?: InputMaybe<OrderBy>;
  balance_virtual?: InputMaybe<OrderBy>;
  balance_yield_token?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  borrow_apr?: InputMaybe<OrderBy>;
  burn_block_time?: InputMaybe<OrderBy>;
  deposit_apr?: InputMaybe<OrderBy>;
  expiry?: InputMaybe<OrderBy>;
  fee_rate_token?: InputMaybe<OrderBy>;
  fee_rate_yield_token?: InputMaybe<OrderBy>;
  fee_rebate?: InputMaybe<OrderBy>;
  fee_to_address?: InputMaybe<OrderBy>;
  listed?: InputMaybe<OrderBy>;
  max_expiry?: InputMaybe<OrderBy>;
  min_fee?: InputMaybe<OrderBy>;
  oracle_average?: InputMaybe<OrderBy>;
  oracle_enabled?: InputMaybe<OrderBy>;
  oracle_resilient?: InputMaybe<OrderBy>;
  pool_token?: InputMaybe<OrderBy>;
  small_threshold?: InputMaybe<OrderBy>;
  sync_at?: InputMaybe<OrderBy>;
  total_supply?: InputMaybe<OrderBy>;
  underlying_token?: InputMaybe<OrderBy>;
  yield_per_token?: InputMaybe<OrderBy>;
  yield_token?: InputMaybe<OrderBy>;
  yield_token_price?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: laplace.yield_token_pool */
export type LaplaceYieldTokenPoolPkColumnsInput = {
  block_height: Scalars['numeric'];
  expiry: Scalars['numeric'];
  yield_token: Scalars['String'];
};

/** select columns of table "laplace.yield_token_pool" */
export enum LaplaceYieldTokenPoolSelectColumn {
  /** column name */
  BalanceToken = 'balance_token',
  /** column name */
  BalanceVirtual = 'balance_virtual',
  /** column name */
  BalanceYieldToken = 'balance_yield_token',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BorrowApr = 'borrow_apr',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  DepositApr = 'deposit_apr',
  /** column name */
  Expiry = 'expiry',
  /** column name */
  FeeRateToken = 'fee_rate_token',
  /** column name */
  FeeRateYieldToken = 'fee_rate_yield_token',
  /** column name */
  FeeRebate = 'fee_rebate',
  /** column name */
  FeeToAddress = 'fee_to_address',
  /** column name */
  Listed = 'listed',
  /** column name */
  MaxExpiry = 'max_expiry',
  /** column name */
  MinFee = 'min_fee',
  /** column name */
  OracleAverage = 'oracle_average',
  /** column name */
  OracleEnabled = 'oracle_enabled',
  /** column name */
  OracleResilient = 'oracle_resilient',
  /** column name */
  PoolToken = 'pool_token',
  /** column name */
  SmallThreshold = 'small_threshold',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TotalSupply = 'total_supply',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  YieldPerToken = 'yield_per_token',
  /** column name */
  YieldToken = 'yield_token',
  /** column name */
  YieldTokenPrice = 'yield_token_price'
}

/** input type for updating data in table "laplace.yield_token_pool" */
export type LaplaceYieldTokenPoolSetInput = {
  balance_token?: InputMaybe<Scalars['numeric']>;
  balance_virtual?: InputMaybe<Scalars['numeric']>;
  balance_yield_token?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  borrow_apr?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  deposit_apr?: InputMaybe<Scalars['numeric']>;
  expiry?: InputMaybe<Scalars['numeric']>;
  fee_rate_token?: InputMaybe<Scalars['numeric']>;
  fee_rate_yield_token?: InputMaybe<Scalars['numeric']>;
  fee_rebate?: InputMaybe<Scalars['numeric']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  listed?: InputMaybe<Scalars['numeric']>;
  max_expiry?: InputMaybe<Scalars['numeric']>;
  min_fee?: InputMaybe<Scalars['numeric']>;
  oracle_average?: InputMaybe<Scalars['numeric']>;
  oracle_enabled?: InputMaybe<Scalars['Boolean']>;
  oracle_resilient?: InputMaybe<Scalars['numeric']>;
  pool_token?: InputMaybe<Scalars['String']>;
  small_threshold?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  total_supply?: InputMaybe<Scalars['numeric']>;
  underlying_token?: InputMaybe<Scalars['String']>;
  yield_per_token?: InputMaybe<Scalars['numeric']>;
  yield_token?: InputMaybe<Scalars['String']>;
  yield_token_price?: InputMaybe<Scalars['numeric']>;
};

/** aggregate stddev on columns */
export type LaplaceYieldTokenPoolStddevFields = {
  __typename?: 'laplace_yield_token_pool_stddev_fields';
  balance_token?: Maybe<Scalars['Float']>;
  balance_virtual?: Maybe<Scalars['Float']>;
  balance_yield_token?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  borrow_apr?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  deposit_apr?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  fee_rate_token?: Maybe<Scalars['Float']>;
  fee_rate_yield_token?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  listed?: Maybe<Scalars['Float']>;
  max_expiry?: Maybe<Scalars['Float']>;
  min_fee?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  small_threshold?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  yield_per_token?: Maybe<Scalars['Float']>;
  yield_token_price?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type LaplaceYieldTokenPoolStddevPopFields = {
  __typename?: 'laplace_yield_token_pool_stddev_pop_fields';
  balance_token?: Maybe<Scalars['Float']>;
  balance_virtual?: Maybe<Scalars['Float']>;
  balance_yield_token?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  borrow_apr?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  deposit_apr?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  fee_rate_token?: Maybe<Scalars['Float']>;
  fee_rate_yield_token?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  listed?: Maybe<Scalars['Float']>;
  max_expiry?: Maybe<Scalars['Float']>;
  min_fee?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  small_threshold?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  yield_per_token?: Maybe<Scalars['Float']>;
  yield_token_price?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type LaplaceYieldTokenPoolStddevSampFields = {
  __typename?: 'laplace_yield_token_pool_stddev_samp_fields';
  balance_token?: Maybe<Scalars['Float']>;
  balance_virtual?: Maybe<Scalars['Float']>;
  balance_yield_token?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  borrow_apr?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  deposit_apr?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  fee_rate_token?: Maybe<Scalars['Float']>;
  fee_rate_yield_token?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  listed?: Maybe<Scalars['Float']>;
  max_expiry?: Maybe<Scalars['Float']>;
  min_fee?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  small_threshold?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  yield_per_token?: Maybe<Scalars['Float']>;
  yield_token_price?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "laplace_yield_token_pool" */
export type LaplaceYieldTokenPoolStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LaplaceYieldTokenPoolStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LaplaceYieldTokenPoolStreamCursorValueInput = {
  balance_token?: InputMaybe<Scalars['numeric']>;
  balance_virtual?: InputMaybe<Scalars['numeric']>;
  balance_yield_token?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['numeric']>;
  borrow_apr?: InputMaybe<Scalars['numeric']>;
  burn_block_time?: InputMaybe<Scalars['numeric']>;
  deposit_apr?: InputMaybe<Scalars['numeric']>;
  expiry?: InputMaybe<Scalars['numeric']>;
  fee_rate_token?: InputMaybe<Scalars['numeric']>;
  fee_rate_yield_token?: InputMaybe<Scalars['numeric']>;
  fee_rebate?: InputMaybe<Scalars['numeric']>;
  fee_to_address?: InputMaybe<Scalars['String']>;
  listed?: InputMaybe<Scalars['numeric']>;
  max_expiry?: InputMaybe<Scalars['numeric']>;
  min_fee?: InputMaybe<Scalars['numeric']>;
  oracle_average?: InputMaybe<Scalars['numeric']>;
  oracle_enabled?: InputMaybe<Scalars['Boolean']>;
  oracle_resilient?: InputMaybe<Scalars['numeric']>;
  pool_token?: InputMaybe<Scalars['String']>;
  small_threshold?: InputMaybe<Scalars['numeric']>;
  sync_at?: InputMaybe<Scalars['timestamptz']>;
  total_supply?: InputMaybe<Scalars['numeric']>;
  underlying_token?: InputMaybe<Scalars['String']>;
  yield_per_token?: InputMaybe<Scalars['numeric']>;
  yield_token?: InputMaybe<Scalars['String']>;
  yield_token_price?: InputMaybe<Scalars['numeric']>;
};

/** aggregate sum on columns */
export type LaplaceYieldTokenPoolSumFields = {
  __typename?: 'laplace_yield_token_pool_sum_fields';
  balance_token?: Maybe<Scalars['numeric']>;
  balance_virtual?: Maybe<Scalars['numeric']>;
  balance_yield_token?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['numeric']>;
  borrow_apr?: Maybe<Scalars['numeric']>;
  burn_block_time?: Maybe<Scalars['numeric']>;
  deposit_apr?: Maybe<Scalars['numeric']>;
  expiry?: Maybe<Scalars['numeric']>;
  fee_rate_token?: Maybe<Scalars['numeric']>;
  fee_rate_yield_token?: Maybe<Scalars['numeric']>;
  fee_rebate?: Maybe<Scalars['numeric']>;
  listed?: Maybe<Scalars['numeric']>;
  max_expiry?: Maybe<Scalars['numeric']>;
  min_fee?: Maybe<Scalars['numeric']>;
  oracle_average?: Maybe<Scalars['numeric']>;
  oracle_resilient?: Maybe<Scalars['numeric']>;
  small_threshold?: Maybe<Scalars['numeric']>;
  total_supply?: Maybe<Scalars['numeric']>;
  yield_per_token?: Maybe<Scalars['numeric']>;
  yield_token_price?: Maybe<Scalars['numeric']>;
};

/** update columns of table "laplace.yield_token_pool" */
export enum LaplaceYieldTokenPoolUpdateColumn {
  /** column name */
  BalanceToken = 'balance_token',
  /** column name */
  BalanceVirtual = 'balance_virtual',
  /** column name */
  BalanceYieldToken = 'balance_yield_token',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BorrowApr = 'borrow_apr',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  DepositApr = 'deposit_apr',
  /** column name */
  Expiry = 'expiry',
  /** column name */
  FeeRateToken = 'fee_rate_token',
  /** column name */
  FeeRateYieldToken = 'fee_rate_yield_token',
  /** column name */
  FeeRebate = 'fee_rebate',
  /** column name */
  FeeToAddress = 'fee_to_address',
  /** column name */
  Listed = 'listed',
  /** column name */
  MaxExpiry = 'max_expiry',
  /** column name */
  MinFee = 'min_fee',
  /** column name */
  OracleAverage = 'oracle_average',
  /** column name */
  OracleEnabled = 'oracle_enabled',
  /** column name */
  OracleResilient = 'oracle_resilient',
  /** column name */
  PoolToken = 'pool_token',
  /** column name */
  SmallThreshold = 'small_threshold',
  /** column name */
  SyncAt = 'sync_at',
  /** column name */
  TotalSupply = 'total_supply',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  YieldPerToken = 'yield_per_token',
  /** column name */
  YieldToken = 'yield_token',
  /** column name */
  YieldTokenPrice = 'yield_token_price'
}

export type LaplaceYieldTokenPoolUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LaplaceYieldTokenPoolIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LaplaceYieldTokenPoolSetInput>;
  where: LaplaceYieldTokenPoolBoolExp;
};

/** aggregate var_pop on columns */
export type LaplaceYieldTokenPoolVarPopFields = {
  __typename?: 'laplace_yield_token_pool_var_pop_fields';
  balance_token?: Maybe<Scalars['Float']>;
  balance_virtual?: Maybe<Scalars['Float']>;
  balance_yield_token?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  borrow_apr?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  deposit_apr?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  fee_rate_token?: Maybe<Scalars['Float']>;
  fee_rate_yield_token?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  listed?: Maybe<Scalars['Float']>;
  max_expiry?: Maybe<Scalars['Float']>;
  min_fee?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  small_threshold?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  yield_per_token?: Maybe<Scalars['Float']>;
  yield_token_price?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type LaplaceYieldTokenPoolVarSampFields = {
  __typename?: 'laplace_yield_token_pool_var_samp_fields';
  balance_token?: Maybe<Scalars['Float']>;
  balance_virtual?: Maybe<Scalars['Float']>;
  balance_yield_token?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  borrow_apr?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  deposit_apr?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  fee_rate_token?: Maybe<Scalars['Float']>;
  fee_rate_yield_token?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  listed?: Maybe<Scalars['Float']>;
  max_expiry?: Maybe<Scalars['Float']>;
  min_fee?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  small_threshold?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  yield_per_token?: Maybe<Scalars['Float']>;
  yield_token_price?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LaplaceYieldTokenPoolVarianceFields = {
  __typename?: 'laplace_yield_token_pool_variance_fields';
  balance_token?: Maybe<Scalars['Float']>;
  balance_virtual?: Maybe<Scalars['Float']>;
  balance_yield_token?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  borrow_apr?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  deposit_apr?: Maybe<Scalars['Float']>;
  expiry?: Maybe<Scalars['Float']>;
  fee_rate_token?: Maybe<Scalars['Float']>;
  fee_rate_yield_token?: Maybe<Scalars['Float']>;
  fee_rebate?: Maybe<Scalars['Float']>;
  listed?: Maybe<Scalars['Float']>;
  max_expiry?: Maybe<Scalars['Float']>;
  min_fee?: Maybe<Scalars['Float']>;
  oracle_average?: Maybe<Scalars['Float']>;
  oracle_resilient?: Maybe<Scalars['Float']>;
  small_threshold?: Maybe<Scalars['Float']>;
  total_supply?: Maybe<Scalars['Float']>;
  yield_per_token?: Maybe<Scalars['Float']>;
  yield_token_price?: Maybe<Scalars['Float']>;
};

/** mutation root */
export type MutationRoot = {
  __typename?: 'mutation_root';
  /** delete data from the table: "blocks" */
  delete_blocks?: Maybe<BlocksMutationResponse>;
  /** delete single row from the table: "blocks" */
  delete_blocks_by_pk?: Maybe<Blocks>;
  /** delete data from the table: "contract_logs" */
  delete_contract_logs?: Maybe<ContractLogsMutationResponse>;
  /** delete single row from the table: "contract_logs" */
  delete_contract_logs_by_pk?: Maybe<ContractLogs>;
  /** delete data from the table: "ft_events" */
  delete_ft_events?: Maybe<FtEventsMutationResponse>;
  /** delete single row from the table: "ft_events" */
  delete_ft_events_by_pk?: Maybe<FtEvents>;
  /** delete data from the table: "laplace.alex_reserve_pools" */
  delete_laplace_alex_reserve_pools?: Maybe<LaplaceAlexReservePoolsMutationResponse>;
  /** delete single row from the table: "laplace.alex_reserve_pools" */
  delete_laplace_alex_reserve_pools_by_pk?: Maybe<LaplaceAlexReservePools>;
  /** delete data from the table: "laplace.borrow_deposit_daily_stats" */
  delete_laplace_borrow_deposit_daily_stats?: Maybe<LaplaceBorrowDepositDailyStatsMutationResponse>;
  /** delete single row from the table: "laplace.borrow_deposit_daily_stats" */
  delete_laplace_borrow_deposit_daily_stats_by_pk?: Maybe<LaplaceBorrowDepositDailyStats>;
  /** delete data from the table: "laplace.borrow_deposit_hourly_stats" */
  delete_laplace_borrow_deposit_hourly_stats?: Maybe<LaplaceBorrowDepositHourlyStatsMutationResponse>;
  /** delete single row from the table: "laplace.borrow_deposit_hourly_stats" */
  delete_laplace_borrow_deposit_hourly_stats_by_pk?: Maybe<LaplaceBorrowDepositHourlyStats>;
  /** delete data from the table: "laplace.borrow_deposit_stats" */
  delete_laplace_borrow_deposit_stats?: Maybe<LaplaceBorrowDepositStatsMutationResponse>;
  /** delete single row from the table: "laplace.borrow_deposit_stats" */
  delete_laplace_borrow_deposit_stats_by_pk?: Maybe<LaplaceBorrowDepositStats>;
  /** delete data from the table: "laplace.coin_gecko" */
  delete_laplace_coin_gecko?: Maybe<LaplaceCoinGeckoMutationResponse>;
  /** delete data from the table: "laplace.coin_gecko_archive" */
  delete_laplace_coin_gecko_archive?: Maybe<LaplaceCoinGeckoArchiveMutationResponse>;
  /** delete single row from the table: "laplace.coin_gecko_archive" */
  delete_laplace_coin_gecko_archive_by_pk?: Maybe<LaplaceCoinGeckoArchive>;
  /** delete single row from the table: "laplace.coin_gecko" */
  delete_laplace_coin_gecko_by_pk?: Maybe<LaplaceCoinGecko>;
  /** delete data from the table: "laplace.collateral_rebalancing_pool" */
  delete_laplace_collateral_rebalancing_pool?: Maybe<LaplaceCollateralRebalancingPoolMutationResponse>;
  /** delete single row from the table: "laplace.collateral_rebalancing_pool" */
  delete_laplace_collateral_rebalancing_pool_by_pk?: Maybe<LaplaceCollateralRebalancingPool>;
  /** delete data from the table: "laplace.config_contracts" */
  delete_laplace_config_contracts?: Maybe<LaplaceConfigContractsMutationResponse>;
  /** delete single row from the table: "laplace.config_contracts" */
  delete_laplace_config_contracts_by_pk?: Maybe<LaplaceConfigContracts>;
  /** delete data from the table: "laplace.contract_calls" */
  delete_laplace_contract_calls?: Maybe<LaplaceContractCallsMutationResponse>;
  /** delete single row from the table: "laplace.contract_calls" */
  delete_laplace_contract_calls_by_pk?: Maybe<LaplaceContractCalls>;
  /** delete data from the table: "laplace.deployed_contracts" */
  delete_laplace_deployed_contracts?: Maybe<LaplaceDeployedContractsMutationResponse>;
  /** delete single row from the table: "laplace.deployed_contracts" */
  delete_laplace_deployed_contracts_by_pk?: Maybe<LaplaceDeployedContracts>;
  /** delete data from the table: "laplace.external_token_price" */
  delete_laplace_external_token_price?: Maybe<LaplaceExternalTokenPriceMutationResponse>;
  /** delete single row from the table: "laplace.external_token_price" */
  delete_laplace_external_token_price_by_pk?: Maybe<LaplaceExternalTokenPrice>;
  /** delete data from the table: "laplace.fixed_weight_pool_v1_01" */
  delete_laplace_fixed_weight_pool_v1_01?: Maybe<LaplaceFixedWeightPoolV1_01MutationResponse>;
  /** delete single row from the table: "laplace.fixed_weight_pool_v1_01" */
  delete_laplace_fixed_weight_pool_v1_01_by_pk?: Maybe<LaplaceFixedWeightPoolV1_01>;
  /** delete data from the table: "laplace.history_price_data" */
  delete_laplace_history_price_data?: Maybe<LaplaceHistoryPriceDataMutationResponse>;
  /** delete single row from the table: "laplace.history_price_data" */
  delete_laplace_history_price_data_by_pk?: Maybe<LaplaceHistoryPriceData>;
  /** delete data from the table: "laplace.history_staking_stats" */
  delete_laplace_history_staking_stats?: Maybe<LaplaceHistoryStakingStatsMutationResponse>;
  /** delete single row from the table: "laplace.history_staking_stats" */
  delete_laplace_history_staking_stats_by_pk?: Maybe<LaplaceHistoryStakingStats>;
  /** delete data from the table: "laplace.ido_pool_creation" */
  delete_laplace_ido_pool_creation?: Maybe<LaplaceIdoPoolCreationMutationResponse>;
  /** delete single row from the table: "laplace.ido_pool_creation" */
  delete_laplace_ido_pool_creation_by_pk?: Maybe<LaplaceIdoPoolCreation>;
  /** delete data from the table: "laplace.ido_register" */
  delete_laplace_ido_register?: Maybe<LaplaceIdoRegisterMutationResponse>;
  /** delete single row from the table: "laplace.ido_register" */
  delete_laplace_ido_register_by_pk?: Maybe<LaplaceIdoRegister>;
  /** delete data from the table: "laplace.latest_alex_reserve_pools" */
  delete_laplace_latest_alex_reserve_pools?: Maybe<LaplaceLatestAlexReservePoolsMutationResponse>;
  /** delete single row from the table: "laplace.latest_alex_reserve_pools" */
  delete_laplace_latest_alex_reserve_pools_by_pk?: Maybe<LaplaceLatestAlexReservePools>;
  /** delete data from the table: "laplace.latest_auto_alex" */
  delete_laplace_latest_auto_alex?: Maybe<LaplaceLatestAutoAlexMutationResponse>;
  /** delete single row from the table: "laplace.latest_auto_alex" */
  delete_laplace_latest_auto_alex_by_pk?: Maybe<LaplaceLatestAutoAlex>;
  /** delete data from the table: "laplace.latest_collateral_per_share" */
  delete_laplace_latest_collateral_per_share?: Maybe<LaplaceLatestCollateralPerShareMutationResponse>;
  /** delete single row from the table: "laplace.latest_collateral_per_share" */
  delete_laplace_latest_collateral_per_share_by_pk?: Maybe<LaplaceLatestCollateralPerShare>;
  /** delete data from the table: "laplace.latest_collateral_rebalancing_pool" */
  delete_laplace_latest_collateral_rebalancing_pool?: Maybe<LaplaceLatestCollateralRebalancingPoolMutationResponse>;
  /** delete single row from the table: "laplace.latest_collateral_rebalancing_pool" */
  delete_laplace_latest_collateral_rebalancing_pool_by_pk?: Maybe<LaplaceLatestCollateralRebalancingPool>;
  /** delete data from the table: "laplace.latest_fixed_weight_pool_v1_01" */
  delete_laplace_latest_fixed_weight_pool_v1_01?: Maybe<LaplaceLatestFixedWeightPoolV1_01MutationResponse>;
  /** delete single row from the table: "laplace.latest_fixed_weight_pool_v1_01" */
  delete_laplace_latest_fixed_weight_pool_v1_01_by_pk?: Maybe<LaplaceLatestFixedWeightPoolV1_01>;
  /** delete data from the table: "laplace.latest_pool_stats" */
  delete_laplace_latest_pool_stats?: Maybe<LaplaceLatestPoolStatsMutationResponse>;
  /** delete single row from the table: "laplace.latest_pool_stats" */
  delete_laplace_latest_pool_stats_by_pk?: Maybe<LaplaceLatestPoolStats>;
  /** delete data from the table: "laplace.latest_simple_weight_pool_alex" */
  delete_laplace_latest_simple_weight_pool_alex?: Maybe<LaplaceLatestSimpleWeightPoolAlexMutationResponse>;
  /** delete single row from the table: "laplace.latest_simple_weight_pool_alex" */
  delete_laplace_latest_simple_weight_pool_alex_by_pk?: Maybe<LaplaceLatestSimpleWeightPoolAlex>;
  /** delete data from the table: "laplace.latest_yield_token_pool" */
  delete_laplace_latest_yield_token_pool?: Maybe<LaplaceLatestYieldTokenPoolMutationResponse>;
  /** delete single row from the table: "laplace.latest_yield_token_pool" */
  delete_laplace_latest_yield_token_pool_by_pk?: Maybe<LaplaceLatestYieldTokenPool>;
  /** delete data from the table: "laplace.oracle_instant_price" */
  delete_laplace_oracle_instant_price?: Maybe<LaplaceOracleInstantPriceMutationResponse>;
  /** delete single row from the table: "laplace.oracle_instant_price" */
  delete_laplace_oracle_instant_price_by_pk?: Maybe<LaplaceOracleInstantPrice>;
  /** delete data from the table: "laplace.oracle_resilient_price" */
  delete_laplace_oracle_resilient_price?: Maybe<LaplaceOracleResilientPriceMutationResponse>;
  /** delete single row from the table: "laplace.oracle_resilient_price" */
  delete_laplace_oracle_resilient_price_by_pk?: Maybe<LaplaceOracleResilientPrice>;
  /** delete data from the table: "laplace.pool_stats" */
  delete_laplace_pool_stats?: Maybe<LaplacePoolStatsMutationResponse>;
  /** delete single row from the table: "laplace.pool_stats" */
  delete_laplace_pool_stats_by_pk?: Maybe<LaplacePoolStats>;
  /** delete data from the table: "laplace.reward_cycle_stats" */
  delete_laplace_reward_cycle_stats?: Maybe<LaplaceRewardCycleStatsMutationResponse>;
  /** delete single row from the table: "laplace.reward_cycle_stats" */
  delete_laplace_reward_cycle_stats_by_pk?: Maybe<LaplaceRewardCycleStats>;
  /** delete data from the table: "laplace.simple_weight_pool_alex" */
  delete_laplace_simple_weight_pool_alex?: Maybe<LaplaceSimpleWeightPoolAlexMutationResponse>;
  /** delete single row from the table: "laplace.simple_weight_pool_alex" */
  delete_laplace_simple_weight_pool_alex_by_pk?: Maybe<LaplaceSimpleWeightPoolAlex>;
  /** delete data from the table: "laplace.stacks_blockchain_events" */
  delete_laplace_stacks_blockchain_events?: Maybe<LaplaceStacksBlockchainEventsMutationResponse>;
  /** delete data from the table: "laplace.swap_records" */
  delete_laplace_swap_records?: Maybe<LaplaceSwapRecordsMutationResponse>;
  /** delete single row from the table: "laplace.swap_records" */
  delete_laplace_swap_records_by_pk?: Maybe<LaplaceSwapRecords>;
  /** delete data from the table: "laplace.sync_status" */
  delete_laplace_sync_status?: Maybe<LaplaceSyncStatusMutationResponse>;
  /** delete single row from the table: "laplace.sync_status" */
  delete_laplace_sync_status_by_pk?: Maybe<LaplaceSyncStatus>;
  /** delete data from the table: "laplace.synced_blocks" */
  delete_laplace_synced_blocks?: Maybe<LaplaceSyncedBlocksMutationResponse>;
  /** delete single row from the table: "laplace.synced_blocks" */
  delete_laplace_synced_blocks_by_pk?: Maybe<LaplaceSyncedBlocks>;
  /** delete data from the table: "laplace.token_stats" */
  delete_laplace_token_stats?: Maybe<LaplaceTokenStatsMutationResponse>;
  /** delete single row from the table: "laplace.token_stats" */
  delete_laplace_token_stats_by_pk?: Maybe<LaplaceTokenStats>;
  /** delete data from the table: "laplace.token_tvl" */
  delete_laplace_token_tvl?: Maybe<LaplaceTokenTvlMutationResponse>;
  /** delete single row from the table: "laplace.token_tvl" */
  delete_laplace_token_tvl_by_pk?: Maybe<LaplaceTokenTvl>;
  /** delete data from the table: "laplace.yield_token_pool" */
  delete_laplace_yield_token_pool?: Maybe<LaplaceYieldTokenPoolMutationResponse>;
  /** delete single row from the table: "laplace.yield_token_pool" */
  delete_laplace_yield_token_pool_by_pk?: Maybe<LaplaceYieldTokenPool>;
  /** delete data from the table: "public_dbt.autoalex_apower_distribution" */
  delete_public_dbt_autoalex_apower_distribution?: Maybe<PublicDbtAutoalexApowerDistributionMutationResponse>;
  /** delete data from the table: "public_dbt.autoalex_lockdrop_snapshot_config" */
  delete_public_dbt_autoalex_lockdrop_snapshot_config?: Maybe<PublicDbtAutoalexLockdropSnapshotConfigMutationResponse>;
  /** delete data from the table: "public_dbt.autoalex_snapshot_config" */
  delete_public_dbt_autoalex_snapshot_config?: Maybe<PublicDbtAutoalexSnapshotConfigMutationResponse>;
  /** delete data from the table: "public_dbt.dim_balance_autoalex_rank_on_height_view" */
  delete_public_dbt_dim_balance_autoalex_rank_on_height_view?: Maybe<PublicDbtDimBalanceAutoalexRankOnHeightViewMutationResponse>;
  /** delete data from the table: "public_dbt.dim_balance_autoalex_rank_view" */
  delete_public_dbt_dim_balance_autoalex_rank_view?: Maybe<PublicDbtDimBalanceAutoalexRankViewMutationResponse>;
  /** delete data from the table: "smart_contracts" */
  delete_smart_contracts?: Maybe<SmartContractsMutationResponse>;
  /** delete single row from the table: "smart_contracts" */
  delete_smart_contracts_by_pk?: Maybe<SmartContracts>;
  /** delete data from the table: "stx_events" */
  delete_stx_events?: Maybe<StxEventsMutationResponse>;
  /** delete single row from the table: "stx_events" */
  delete_stx_events_by_pk?: Maybe<StxEvents>;
  /** delete data from the table: "txs" */
  delete_txs?: Maybe<TxsMutationResponse>;
  /** delete single row from the table: "txs" */
  delete_txs_by_pk?: Maybe<Txs>;
  /** insert data into the table: "blocks" */
  insert_blocks?: Maybe<BlocksMutationResponse>;
  /** insert a single row into the table: "blocks" */
  insert_blocks_one?: Maybe<Blocks>;
  /** insert data into the table: "contract_logs" */
  insert_contract_logs?: Maybe<ContractLogsMutationResponse>;
  /** insert a single row into the table: "contract_logs" */
  insert_contract_logs_one?: Maybe<ContractLogs>;
  /** insert data into the table: "ft_events" */
  insert_ft_events?: Maybe<FtEventsMutationResponse>;
  /** insert a single row into the table: "ft_events" */
  insert_ft_events_one?: Maybe<FtEvents>;
  /** insert data into the table: "laplace.alex_reserve_pools" */
  insert_laplace_alex_reserve_pools?: Maybe<LaplaceAlexReservePoolsMutationResponse>;
  /** insert a single row into the table: "laplace.alex_reserve_pools" */
  insert_laplace_alex_reserve_pools_one?: Maybe<LaplaceAlexReservePools>;
  /** insert data into the table: "laplace.borrow_deposit_daily_stats" */
  insert_laplace_borrow_deposit_daily_stats?: Maybe<LaplaceBorrowDepositDailyStatsMutationResponse>;
  /** insert a single row into the table: "laplace.borrow_deposit_daily_stats" */
  insert_laplace_borrow_deposit_daily_stats_one?: Maybe<LaplaceBorrowDepositDailyStats>;
  /** insert data into the table: "laplace.borrow_deposit_hourly_stats" */
  insert_laplace_borrow_deposit_hourly_stats?: Maybe<LaplaceBorrowDepositHourlyStatsMutationResponse>;
  /** insert a single row into the table: "laplace.borrow_deposit_hourly_stats" */
  insert_laplace_borrow_deposit_hourly_stats_one?: Maybe<LaplaceBorrowDepositHourlyStats>;
  /** insert data into the table: "laplace.borrow_deposit_stats" */
  insert_laplace_borrow_deposit_stats?: Maybe<LaplaceBorrowDepositStatsMutationResponse>;
  /** insert a single row into the table: "laplace.borrow_deposit_stats" */
  insert_laplace_borrow_deposit_stats_one?: Maybe<LaplaceBorrowDepositStats>;
  /** insert data into the table: "laplace.coin_gecko" */
  insert_laplace_coin_gecko?: Maybe<LaplaceCoinGeckoMutationResponse>;
  /** insert data into the table: "laplace.coin_gecko_archive" */
  insert_laplace_coin_gecko_archive?: Maybe<LaplaceCoinGeckoArchiveMutationResponse>;
  /** insert a single row into the table: "laplace.coin_gecko_archive" */
  insert_laplace_coin_gecko_archive_one?: Maybe<LaplaceCoinGeckoArchive>;
  /** insert a single row into the table: "laplace.coin_gecko" */
  insert_laplace_coin_gecko_one?: Maybe<LaplaceCoinGecko>;
  /** insert data into the table: "laplace.collateral_rebalancing_pool" */
  insert_laplace_collateral_rebalancing_pool?: Maybe<LaplaceCollateralRebalancingPoolMutationResponse>;
  /** insert a single row into the table: "laplace.collateral_rebalancing_pool" */
  insert_laplace_collateral_rebalancing_pool_one?: Maybe<LaplaceCollateralRebalancingPool>;
  /** insert data into the table: "laplace.config_contracts" */
  insert_laplace_config_contracts?: Maybe<LaplaceConfigContractsMutationResponse>;
  /** insert a single row into the table: "laplace.config_contracts" */
  insert_laplace_config_contracts_one?: Maybe<LaplaceConfigContracts>;
  /** insert data into the table: "laplace.contract_calls" */
  insert_laplace_contract_calls?: Maybe<LaplaceContractCallsMutationResponse>;
  /** insert a single row into the table: "laplace.contract_calls" */
  insert_laplace_contract_calls_one?: Maybe<LaplaceContractCalls>;
  /** insert data into the table: "laplace.deployed_contracts" */
  insert_laplace_deployed_contracts?: Maybe<LaplaceDeployedContractsMutationResponse>;
  /** insert a single row into the table: "laplace.deployed_contracts" */
  insert_laplace_deployed_contracts_one?: Maybe<LaplaceDeployedContracts>;
  /** insert data into the table: "laplace.external_token_price" */
  insert_laplace_external_token_price?: Maybe<LaplaceExternalTokenPriceMutationResponse>;
  /** insert a single row into the table: "laplace.external_token_price" */
  insert_laplace_external_token_price_one?: Maybe<LaplaceExternalTokenPrice>;
  /** insert data into the table: "laplace.fixed_weight_pool_v1_01" */
  insert_laplace_fixed_weight_pool_v1_01?: Maybe<LaplaceFixedWeightPoolV1_01MutationResponse>;
  /** insert a single row into the table: "laplace.fixed_weight_pool_v1_01" */
  insert_laplace_fixed_weight_pool_v1_01_one?: Maybe<LaplaceFixedWeightPoolV1_01>;
  /** insert data into the table: "laplace.history_price_data" */
  insert_laplace_history_price_data?: Maybe<LaplaceHistoryPriceDataMutationResponse>;
  /** insert a single row into the table: "laplace.history_price_data" */
  insert_laplace_history_price_data_one?: Maybe<LaplaceHistoryPriceData>;
  /** insert data into the table: "laplace.history_staking_stats" */
  insert_laplace_history_staking_stats?: Maybe<LaplaceHistoryStakingStatsMutationResponse>;
  /** insert a single row into the table: "laplace.history_staking_stats" */
  insert_laplace_history_staking_stats_one?: Maybe<LaplaceHistoryStakingStats>;
  /** insert data into the table: "laplace.ido_pool_creation" */
  insert_laplace_ido_pool_creation?: Maybe<LaplaceIdoPoolCreationMutationResponse>;
  /** insert a single row into the table: "laplace.ido_pool_creation" */
  insert_laplace_ido_pool_creation_one?: Maybe<LaplaceIdoPoolCreation>;
  /** insert data into the table: "laplace.ido_register" */
  insert_laplace_ido_register?: Maybe<LaplaceIdoRegisterMutationResponse>;
  /** insert a single row into the table: "laplace.ido_register" */
  insert_laplace_ido_register_one?: Maybe<LaplaceIdoRegister>;
  /** insert data into the table: "laplace.latest_alex_reserve_pools" */
  insert_laplace_latest_alex_reserve_pools?: Maybe<LaplaceLatestAlexReservePoolsMutationResponse>;
  /** insert a single row into the table: "laplace.latest_alex_reserve_pools" */
  insert_laplace_latest_alex_reserve_pools_one?: Maybe<LaplaceLatestAlexReservePools>;
  /** insert data into the table: "laplace.latest_auto_alex" */
  insert_laplace_latest_auto_alex?: Maybe<LaplaceLatestAutoAlexMutationResponse>;
  /** insert a single row into the table: "laplace.latest_auto_alex" */
  insert_laplace_latest_auto_alex_one?: Maybe<LaplaceLatestAutoAlex>;
  /** insert data into the table: "laplace.latest_collateral_per_share" */
  insert_laplace_latest_collateral_per_share?: Maybe<LaplaceLatestCollateralPerShareMutationResponse>;
  /** insert a single row into the table: "laplace.latest_collateral_per_share" */
  insert_laplace_latest_collateral_per_share_one?: Maybe<LaplaceLatestCollateralPerShare>;
  /** insert data into the table: "laplace.latest_collateral_rebalancing_pool" */
  insert_laplace_latest_collateral_rebalancing_pool?: Maybe<LaplaceLatestCollateralRebalancingPoolMutationResponse>;
  /** insert a single row into the table: "laplace.latest_collateral_rebalancing_pool" */
  insert_laplace_latest_collateral_rebalancing_pool_one?: Maybe<LaplaceLatestCollateralRebalancingPool>;
  /** insert data into the table: "laplace.latest_fixed_weight_pool_v1_01" */
  insert_laplace_latest_fixed_weight_pool_v1_01?: Maybe<LaplaceLatestFixedWeightPoolV1_01MutationResponse>;
  /** insert a single row into the table: "laplace.latest_fixed_weight_pool_v1_01" */
  insert_laplace_latest_fixed_weight_pool_v1_01_one?: Maybe<LaplaceLatestFixedWeightPoolV1_01>;
  /** insert data into the table: "laplace.latest_pool_stats" */
  insert_laplace_latest_pool_stats?: Maybe<LaplaceLatestPoolStatsMutationResponse>;
  /** insert a single row into the table: "laplace.latest_pool_stats" */
  insert_laplace_latest_pool_stats_one?: Maybe<LaplaceLatestPoolStats>;
  /** insert data into the table: "laplace.latest_simple_weight_pool_alex" */
  insert_laplace_latest_simple_weight_pool_alex?: Maybe<LaplaceLatestSimpleWeightPoolAlexMutationResponse>;
  /** insert a single row into the table: "laplace.latest_simple_weight_pool_alex" */
  insert_laplace_latest_simple_weight_pool_alex_one?: Maybe<LaplaceLatestSimpleWeightPoolAlex>;
  /** insert data into the table: "laplace.latest_yield_token_pool" */
  insert_laplace_latest_yield_token_pool?: Maybe<LaplaceLatestYieldTokenPoolMutationResponse>;
  /** insert a single row into the table: "laplace.latest_yield_token_pool" */
  insert_laplace_latest_yield_token_pool_one?: Maybe<LaplaceLatestYieldTokenPool>;
  /** insert data into the table: "laplace.oracle_instant_price" */
  insert_laplace_oracle_instant_price?: Maybe<LaplaceOracleInstantPriceMutationResponse>;
  /** insert a single row into the table: "laplace.oracle_instant_price" */
  insert_laplace_oracle_instant_price_one?: Maybe<LaplaceOracleInstantPrice>;
  /** insert data into the table: "laplace.oracle_resilient_price" */
  insert_laplace_oracle_resilient_price?: Maybe<LaplaceOracleResilientPriceMutationResponse>;
  /** insert a single row into the table: "laplace.oracle_resilient_price" */
  insert_laplace_oracle_resilient_price_one?: Maybe<LaplaceOracleResilientPrice>;
  /** insert data into the table: "laplace.pool_stats" */
  insert_laplace_pool_stats?: Maybe<LaplacePoolStatsMutationResponse>;
  /** insert a single row into the table: "laplace.pool_stats" */
  insert_laplace_pool_stats_one?: Maybe<LaplacePoolStats>;
  /** insert data into the table: "laplace.reward_cycle_stats" */
  insert_laplace_reward_cycle_stats?: Maybe<LaplaceRewardCycleStatsMutationResponse>;
  /** insert a single row into the table: "laplace.reward_cycle_stats" */
  insert_laplace_reward_cycle_stats_one?: Maybe<LaplaceRewardCycleStats>;
  /** insert data into the table: "laplace.simple_weight_pool_alex" */
  insert_laplace_simple_weight_pool_alex?: Maybe<LaplaceSimpleWeightPoolAlexMutationResponse>;
  /** insert a single row into the table: "laplace.simple_weight_pool_alex" */
  insert_laplace_simple_weight_pool_alex_one?: Maybe<LaplaceSimpleWeightPoolAlex>;
  /** insert data into the table: "laplace.stacks_blockchain_events" */
  insert_laplace_stacks_blockchain_events?: Maybe<LaplaceStacksBlockchainEventsMutationResponse>;
  /** insert a single row into the table: "laplace.stacks_blockchain_events" */
  insert_laplace_stacks_blockchain_events_one?: Maybe<LaplaceStacksBlockchainEvents>;
  /** insert data into the table: "laplace.swap_records" */
  insert_laplace_swap_records?: Maybe<LaplaceSwapRecordsMutationResponse>;
  /** insert a single row into the table: "laplace.swap_records" */
  insert_laplace_swap_records_one?: Maybe<LaplaceSwapRecords>;
  /** insert data into the table: "laplace.sync_status" */
  insert_laplace_sync_status?: Maybe<LaplaceSyncStatusMutationResponse>;
  /** insert a single row into the table: "laplace.sync_status" */
  insert_laplace_sync_status_one?: Maybe<LaplaceSyncStatus>;
  /** insert data into the table: "laplace.synced_blocks" */
  insert_laplace_synced_blocks?: Maybe<LaplaceSyncedBlocksMutationResponse>;
  /** insert a single row into the table: "laplace.synced_blocks" */
  insert_laplace_synced_blocks_one?: Maybe<LaplaceSyncedBlocks>;
  /** insert data into the table: "laplace.token_stats" */
  insert_laplace_token_stats?: Maybe<LaplaceTokenStatsMutationResponse>;
  /** insert a single row into the table: "laplace.token_stats" */
  insert_laplace_token_stats_one?: Maybe<LaplaceTokenStats>;
  /** insert data into the table: "laplace.token_tvl" */
  insert_laplace_token_tvl?: Maybe<LaplaceTokenTvlMutationResponse>;
  /** insert a single row into the table: "laplace.token_tvl" */
  insert_laplace_token_tvl_one?: Maybe<LaplaceTokenTvl>;
  /** insert data into the table: "laplace.yield_token_pool" */
  insert_laplace_yield_token_pool?: Maybe<LaplaceYieldTokenPoolMutationResponse>;
  /** insert a single row into the table: "laplace.yield_token_pool" */
  insert_laplace_yield_token_pool_one?: Maybe<LaplaceYieldTokenPool>;
  /** insert data into the table: "public_dbt.autoalex_apower_distribution" */
  insert_public_dbt_autoalex_apower_distribution?: Maybe<PublicDbtAutoalexApowerDistributionMutationResponse>;
  /** insert a single row into the table: "public_dbt.autoalex_apower_distribution" */
  insert_public_dbt_autoalex_apower_distribution_one?: Maybe<PublicDbtAutoalexApowerDistribution>;
  /** insert data into the table: "public_dbt.autoalex_lockdrop_snapshot_config" */
  insert_public_dbt_autoalex_lockdrop_snapshot_config?: Maybe<PublicDbtAutoalexLockdropSnapshotConfigMutationResponse>;
  /** insert a single row into the table: "public_dbt.autoalex_lockdrop_snapshot_config" */
  insert_public_dbt_autoalex_lockdrop_snapshot_config_one?: Maybe<PublicDbtAutoalexLockdropSnapshotConfig>;
  /** insert data into the table: "public_dbt.autoalex_snapshot_config" */
  insert_public_dbt_autoalex_snapshot_config?: Maybe<PublicDbtAutoalexSnapshotConfigMutationResponse>;
  /** insert a single row into the table: "public_dbt.autoalex_snapshot_config" */
  insert_public_dbt_autoalex_snapshot_config_one?: Maybe<PublicDbtAutoalexSnapshotConfig>;
  /** insert data into the table: "public_dbt.dim_balance_autoalex_rank_on_height_view" */
  insert_public_dbt_dim_balance_autoalex_rank_on_height_view?: Maybe<PublicDbtDimBalanceAutoalexRankOnHeightViewMutationResponse>;
  /** insert a single row into the table: "public_dbt.dim_balance_autoalex_rank_on_height_view" */
  insert_public_dbt_dim_balance_autoalex_rank_on_height_view_one?: Maybe<PublicDbtDimBalanceAutoalexRankOnHeightView>;
  /** insert data into the table: "public_dbt.dim_balance_autoalex_rank_view" */
  insert_public_dbt_dim_balance_autoalex_rank_view?: Maybe<PublicDbtDimBalanceAutoalexRankViewMutationResponse>;
  /** insert a single row into the table: "public_dbt.dim_balance_autoalex_rank_view" */
  insert_public_dbt_dim_balance_autoalex_rank_view_one?: Maybe<PublicDbtDimBalanceAutoalexRankView>;
  /** insert data into the table: "smart_contracts" */
  insert_smart_contracts?: Maybe<SmartContractsMutationResponse>;
  /** insert a single row into the table: "smart_contracts" */
  insert_smart_contracts_one?: Maybe<SmartContracts>;
  /** insert data into the table: "stx_events" */
  insert_stx_events?: Maybe<StxEventsMutationResponse>;
  /** insert a single row into the table: "stx_events" */
  insert_stx_events_one?: Maybe<StxEvents>;
  /** insert data into the table: "txs" */
  insert_txs?: Maybe<TxsMutationResponse>;
  /** insert a single row into the table: "txs" */
  insert_txs_one?: Maybe<Txs>;
  /** update data of the table: "blocks" */
  update_blocks?: Maybe<BlocksMutationResponse>;
  /** update single row of the table: "blocks" */
  update_blocks_by_pk?: Maybe<Blocks>;
  /** update multiples rows of table: "blocks" */
  update_blocks_many?: Maybe<Array<Maybe<BlocksMutationResponse>>>;
  /** update data of the table: "contract_logs" */
  update_contract_logs?: Maybe<ContractLogsMutationResponse>;
  /** update single row of the table: "contract_logs" */
  update_contract_logs_by_pk?: Maybe<ContractLogs>;
  /** update multiples rows of table: "contract_logs" */
  update_contract_logs_many?: Maybe<Array<Maybe<ContractLogsMutationResponse>>>;
  /** update data of the table: "ft_events" */
  update_ft_events?: Maybe<FtEventsMutationResponse>;
  /** update single row of the table: "ft_events" */
  update_ft_events_by_pk?: Maybe<FtEvents>;
  /** update multiples rows of table: "ft_events" */
  update_ft_events_many?: Maybe<Array<Maybe<FtEventsMutationResponse>>>;
  /** update data of the table: "laplace.alex_reserve_pools" */
  update_laplace_alex_reserve_pools?: Maybe<LaplaceAlexReservePoolsMutationResponse>;
  /** update single row of the table: "laplace.alex_reserve_pools" */
  update_laplace_alex_reserve_pools_by_pk?: Maybe<LaplaceAlexReservePools>;
  /** update multiples rows of table: "laplace.alex_reserve_pools" */
  update_laplace_alex_reserve_pools_many?: Maybe<Array<Maybe<LaplaceAlexReservePoolsMutationResponse>>>;
  /** update data of the table: "laplace.borrow_deposit_daily_stats" */
  update_laplace_borrow_deposit_daily_stats?: Maybe<LaplaceBorrowDepositDailyStatsMutationResponse>;
  /** update single row of the table: "laplace.borrow_deposit_daily_stats" */
  update_laplace_borrow_deposit_daily_stats_by_pk?: Maybe<LaplaceBorrowDepositDailyStats>;
  /** update multiples rows of table: "laplace.borrow_deposit_daily_stats" */
  update_laplace_borrow_deposit_daily_stats_many?: Maybe<Array<Maybe<LaplaceBorrowDepositDailyStatsMutationResponse>>>;
  /** update data of the table: "laplace.borrow_deposit_hourly_stats" */
  update_laplace_borrow_deposit_hourly_stats?: Maybe<LaplaceBorrowDepositHourlyStatsMutationResponse>;
  /** update single row of the table: "laplace.borrow_deposit_hourly_stats" */
  update_laplace_borrow_deposit_hourly_stats_by_pk?: Maybe<LaplaceBorrowDepositHourlyStats>;
  /** update multiples rows of table: "laplace.borrow_deposit_hourly_stats" */
  update_laplace_borrow_deposit_hourly_stats_many?: Maybe<Array<Maybe<LaplaceBorrowDepositHourlyStatsMutationResponse>>>;
  /** update data of the table: "laplace.borrow_deposit_stats" */
  update_laplace_borrow_deposit_stats?: Maybe<LaplaceBorrowDepositStatsMutationResponse>;
  /** update single row of the table: "laplace.borrow_deposit_stats" */
  update_laplace_borrow_deposit_stats_by_pk?: Maybe<LaplaceBorrowDepositStats>;
  /** update multiples rows of table: "laplace.borrow_deposit_stats" */
  update_laplace_borrow_deposit_stats_many?: Maybe<Array<Maybe<LaplaceBorrowDepositStatsMutationResponse>>>;
  /** update data of the table: "laplace.coin_gecko" */
  update_laplace_coin_gecko?: Maybe<LaplaceCoinGeckoMutationResponse>;
  /** update data of the table: "laplace.coin_gecko_archive" */
  update_laplace_coin_gecko_archive?: Maybe<LaplaceCoinGeckoArchiveMutationResponse>;
  /** update single row of the table: "laplace.coin_gecko_archive" */
  update_laplace_coin_gecko_archive_by_pk?: Maybe<LaplaceCoinGeckoArchive>;
  /** update multiples rows of table: "laplace.coin_gecko_archive" */
  update_laplace_coin_gecko_archive_many?: Maybe<Array<Maybe<LaplaceCoinGeckoArchiveMutationResponse>>>;
  /** update single row of the table: "laplace.coin_gecko" */
  update_laplace_coin_gecko_by_pk?: Maybe<LaplaceCoinGecko>;
  /** update multiples rows of table: "laplace.coin_gecko" */
  update_laplace_coin_gecko_many?: Maybe<Array<Maybe<LaplaceCoinGeckoMutationResponse>>>;
  /** update data of the table: "laplace.collateral_rebalancing_pool" */
  update_laplace_collateral_rebalancing_pool?: Maybe<LaplaceCollateralRebalancingPoolMutationResponse>;
  /** update single row of the table: "laplace.collateral_rebalancing_pool" */
  update_laplace_collateral_rebalancing_pool_by_pk?: Maybe<LaplaceCollateralRebalancingPool>;
  /** update multiples rows of table: "laplace.collateral_rebalancing_pool" */
  update_laplace_collateral_rebalancing_pool_many?: Maybe<Array<Maybe<LaplaceCollateralRebalancingPoolMutationResponse>>>;
  /** update data of the table: "laplace.config_contracts" */
  update_laplace_config_contracts?: Maybe<LaplaceConfigContractsMutationResponse>;
  /** update single row of the table: "laplace.config_contracts" */
  update_laplace_config_contracts_by_pk?: Maybe<LaplaceConfigContracts>;
  /** update multiples rows of table: "laplace.config_contracts" */
  update_laplace_config_contracts_many?: Maybe<Array<Maybe<LaplaceConfigContractsMutationResponse>>>;
  /** update data of the table: "laplace.contract_calls" */
  update_laplace_contract_calls?: Maybe<LaplaceContractCallsMutationResponse>;
  /** update single row of the table: "laplace.contract_calls" */
  update_laplace_contract_calls_by_pk?: Maybe<LaplaceContractCalls>;
  /** update multiples rows of table: "laplace.contract_calls" */
  update_laplace_contract_calls_many?: Maybe<Array<Maybe<LaplaceContractCallsMutationResponse>>>;
  /** update data of the table: "laplace.deployed_contracts" */
  update_laplace_deployed_contracts?: Maybe<LaplaceDeployedContractsMutationResponse>;
  /** update single row of the table: "laplace.deployed_contracts" */
  update_laplace_deployed_contracts_by_pk?: Maybe<LaplaceDeployedContracts>;
  /** update multiples rows of table: "laplace.deployed_contracts" */
  update_laplace_deployed_contracts_many?: Maybe<Array<Maybe<LaplaceDeployedContractsMutationResponse>>>;
  /** update data of the table: "laplace.external_token_price" */
  update_laplace_external_token_price?: Maybe<LaplaceExternalTokenPriceMutationResponse>;
  /** update single row of the table: "laplace.external_token_price" */
  update_laplace_external_token_price_by_pk?: Maybe<LaplaceExternalTokenPrice>;
  /** update multiples rows of table: "laplace.external_token_price" */
  update_laplace_external_token_price_many?: Maybe<Array<Maybe<LaplaceExternalTokenPriceMutationResponse>>>;
  /** update data of the table: "laplace.fixed_weight_pool_v1_01" */
  update_laplace_fixed_weight_pool_v1_01?: Maybe<LaplaceFixedWeightPoolV1_01MutationResponse>;
  /** update single row of the table: "laplace.fixed_weight_pool_v1_01" */
  update_laplace_fixed_weight_pool_v1_01_by_pk?: Maybe<LaplaceFixedWeightPoolV1_01>;
  /** update multiples rows of table: "laplace.fixed_weight_pool_v1_01" */
  update_laplace_fixed_weight_pool_v1_01_many?: Maybe<Array<Maybe<LaplaceFixedWeightPoolV1_01MutationResponse>>>;
  /** update data of the table: "laplace.history_price_data" */
  update_laplace_history_price_data?: Maybe<LaplaceHistoryPriceDataMutationResponse>;
  /** update single row of the table: "laplace.history_price_data" */
  update_laplace_history_price_data_by_pk?: Maybe<LaplaceHistoryPriceData>;
  /** update multiples rows of table: "laplace.history_price_data" */
  update_laplace_history_price_data_many?: Maybe<Array<Maybe<LaplaceHistoryPriceDataMutationResponse>>>;
  /** update data of the table: "laplace.history_staking_stats" */
  update_laplace_history_staking_stats?: Maybe<LaplaceHistoryStakingStatsMutationResponse>;
  /** update single row of the table: "laplace.history_staking_stats" */
  update_laplace_history_staking_stats_by_pk?: Maybe<LaplaceHistoryStakingStats>;
  /** update multiples rows of table: "laplace.history_staking_stats" */
  update_laplace_history_staking_stats_many?: Maybe<Array<Maybe<LaplaceHistoryStakingStatsMutationResponse>>>;
  /** update data of the table: "laplace.ido_pool_creation" */
  update_laplace_ido_pool_creation?: Maybe<LaplaceIdoPoolCreationMutationResponse>;
  /** update single row of the table: "laplace.ido_pool_creation" */
  update_laplace_ido_pool_creation_by_pk?: Maybe<LaplaceIdoPoolCreation>;
  /** update multiples rows of table: "laplace.ido_pool_creation" */
  update_laplace_ido_pool_creation_many?: Maybe<Array<Maybe<LaplaceIdoPoolCreationMutationResponse>>>;
  /** update data of the table: "laplace.ido_register" */
  update_laplace_ido_register?: Maybe<LaplaceIdoRegisterMutationResponse>;
  /** update single row of the table: "laplace.ido_register" */
  update_laplace_ido_register_by_pk?: Maybe<LaplaceIdoRegister>;
  /** update multiples rows of table: "laplace.ido_register" */
  update_laplace_ido_register_many?: Maybe<Array<Maybe<LaplaceIdoRegisterMutationResponse>>>;
  /** update data of the table: "laplace.latest_alex_reserve_pools" */
  update_laplace_latest_alex_reserve_pools?: Maybe<LaplaceLatestAlexReservePoolsMutationResponse>;
  /** update single row of the table: "laplace.latest_alex_reserve_pools" */
  update_laplace_latest_alex_reserve_pools_by_pk?: Maybe<LaplaceLatestAlexReservePools>;
  /** update multiples rows of table: "laplace.latest_alex_reserve_pools" */
  update_laplace_latest_alex_reserve_pools_many?: Maybe<Array<Maybe<LaplaceLatestAlexReservePoolsMutationResponse>>>;
  /** update data of the table: "laplace.latest_auto_alex" */
  update_laplace_latest_auto_alex?: Maybe<LaplaceLatestAutoAlexMutationResponse>;
  /** update single row of the table: "laplace.latest_auto_alex" */
  update_laplace_latest_auto_alex_by_pk?: Maybe<LaplaceLatestAutoAlex>;
  /** update multiples rows of table: "laplace.latest_auto_alex" */
  update_laplace_latest_auto_alex_many?: Maybe<Array<Maybe<LaplaceLatestAutoAlexMutationResponse>>>;
  /** update data of the table: "laplace.latest_collateral_per_share" */
  update_laplace_latest_collateral_per_share?: Maybe<LaplaceLatestCollateralPerShareMutationResponse>;
  /** update single row of the table: "laplace.latest_collateral_per_share" */
  update_laplace_latest_collateral_per_share_by_pk?: Maybe<LaplaceLatestCollateralPerShare>;
  /** update multiples rows of table: "laplace.latest_collateral_per_share" */
  update_laplace_latest_collateral_per_share_many?: Maybe<Array<Maybe<LaplaceLatestCollateralPerShareMutationResponse>>>;
  /** update data of the table: "laplace.latest_collateral_rebalancing_pool" */
  update_laplace_latest_collateral_rebalancing_pool?: Maybe<LaplaceLatestCollateralRebalancingPoolMutationResponse>;
  /** update single row of the table: "laplace.latest_collateral_rebalancing_pool" */
  update_laplace_latest_collateral_rebalancing_pool_by_pk?: Maybe<LaplaceLatestCollateralRebalancingPool>;
  /** update multiples rows of table: "laplace.latest_collateral_rebalancing_pool" */
  update_laplace_latest_collateral_rebalancing_pool_many?: Maybe<Array<Maybe<LaplaceLatestCollateralRebalancingPoolMutationResponse>>>;
  /** update data of the table: "laplace.latest_fixed_weight_pool_v1_01" */
  update_laplace_latest_fixed_weight_pool_v1_01?: Maybe<LaplaceLatestFixedWeightPoolV1_01MutationResponse>;
  /** update single row of the table: "laplace.latest_fixed_weight_pool_v1_01" */
  update_laplace_latest_fixed_weight_pool_v1_01_by_pk?: Maybe<LaplaceLatestFixedWeightPoolV1_01>;
  /** update multiples rows of table: "laplace.latest_fixed_weight_pool_v1_01" */
  update_laplace_latest_fixed_weight_pool_v1_01_many?: Maybe<Array<Maybe<LaplaceLatestFixedWeightPoolV1_01MutationResponse>>>;
  /** update data of the table: "laplace.latest_pool_stats" */
  update_laplace_latest_pool_stats?: Maybe<LaplaceLatestPoolStatsMutationResponse>;
  /** update single row of the table: "laplace.latest_pool_stats" */
  update_laplace_latest_pool_stats_by_pk?: Maybe<LaplaceLatestPoolStats>;
  /** update multiples rows of table: "laplace.latest_pool_stats" */
  update_laplace_latest_pool_stats_many?: Maybe<Array<Maybe<LaplaceLatestPoolStatsMutationResponse>>>;
  /** update data of the table: "laplace.latest_simple_weight_pool_alex" */
  update_laplace_latest_simple_weight_pool_alex?: Maybe<LaplaceLatestSimpleWeightPoolAlexMutationResponse>;
  /** update single row of the table: "laplace.latest_simple_weight_pool_alex" */
  update_laplace_latest_simple_weight_pool_alex_by_pk?: Maybe<LaplaceLatestSimpleWeightPoolAlex>;
  /** update multiples rows of table: "laplace.latest_simple_weight_pool_alex" */
  update_laplace_latest_simple_weight_pool_alex_many?: Maybe<Array<Maybe<LaplaceLatestSimpleWeightPoolAlexMutationResponse>>>;
  /** update data of the table: "laplace.latest_yield_token_pool" */
  update_laplace_latest_yield_token_pool?: Maybe<LaplaceLatestYieldTokenPoolMutationResponse>;
  /** update single row of the table: "laplace.latest_yield_token_pool" */
  update_laplace_latest_yield_token_pool_by_pk?: Maybe<LaplaceLatestYieldTokenPool>;
  /** update multiples rows of table: "laplace.latest_yield_token_pool" */
  update_laplace_latest_yield_token_pool_many?: Maybe<Array<Maybe<LaplaceLatestYieldTokenPoolMutationResponse>>>;
  /** update data of the table: "laplace.oracle_instant_price" */
  update_laplace_oracle_instant_price?: Maybe<LaplaceOracleInstantPriceMutationResponse>;
  /** update single row of the table: "laplace.oracle_instant_price" */
  update_laplace_oracle_instant_price_by_pk?: Maybe<LaplaceOracleInstantPrice>;
  /** update multiples rows of table: "laplace.oracle_instant_price" */
  update_laplace_oracle_instant_price_many?: Maybe<Array<Maybe<LaplaceOracleInstantPriceMutationResponse>>>;
  /** update data of the table: "laplace.oracle_resilient_price" */
  update_laplace_oracle_resilient_price?: Maybe<LaplaceOracleResilientPriceMutationResponse>;
  /** update single row of the table: "laplace.oracle_resilient_price" */
  update_laplace_oracle_resilient_price_by_pk?: Maybe<LaplaceOracleResilientPrice>;
  /** update multiples rows of table: "laplace.oracle_resilient_price" */
  update_laplace_oracle_resilient_price_many?: Maybe<Array<Maybe<LaplaceOracleResilientPriceMutationResponse>>>;
  /** update data of the table: "laplace.pool_stats" */
  update_laplace_pool_stats?: Maybe<LaplacePoolStatsMutationResponse>;
  /** update single row of the table: "laplace.pool_stats" */
  update_laplace_pool_stats_by_pk?: Maybe<LaplacePoolStats>;
  /** update multiples rows of table: "laplace.pool_stats" */
  update_laplace_pool_stats_many?: Maybe<Array<Maybe<LaplacePoolStatsMutationResponse>>>;
  /** update data of the table: "laplace.reward_cycle_stats" */
  update_laplace_reward_cycle_stats?: Maybe<LaplaceRewardCycleStatsMutationResponse>;
  /** update single row of the table: "laplace.reward_cycle_stats" */
  update_laplace_reward_cycle_stats_by_pk?: Maybe<LaplaceRewardCycleStats>;
  /** update multiples rows of table: "laplace.reward_cycle_stats" */
  update_laplace_reward_cycle_stats_many?: Maybe<Array<Maybe<LaplaceRewardCycleStatsMutationResponse>>>;
  /** update data of the table: "laplace.simple_weight_pool_alex" */
  update_laplace_simple_weight_pool_alex?: Maybe<LaplaceSimpleWeightPoolAlexMutationResponse>;
  /** update single row of the table: "laplace.simple_weight_pool_alex" */
  update_laplace_simple_weight_pool_alex_by_pk?: Maybe<LaplaceSimpleWeightPoolAlex>;
  /** update multiples rows of table: "laplace.simple_weight_pool_alex" */
  update_laplace_simple_weight_pool_alex_many?: Maybe<Array<Maybe<LaplaceSimpleWeightPoolAlexMutationResponse>>>;
  /** update data of the table: "laplace.stacks_blockchain_events" */
  update_laplace_stacks_blockchain_events?: Maybe<LaplaceStacksBlockchainEventsMutationResponse>;
  /** update multiples rows of table: "laplace.stacks_blockchain_events" */
  update_laplace_stacks_blockchain_events_many?: Maybe<Array<Maybe<LaplaceStacksBlockchainEventsMutationResponse>>>;
  /** update data of the table: "laplace.swap_records" */
  update_laplace_swap_records?: Maybe<LaplaceSwapRecordsMutationResponse>;
  /** update single row of the table: "laplace.swap_records" */
  update_laplace_swap_records_by_pk?: Maybe<LaplaceSwapRecords>;
  /** update multiples rows of table: "laplace.swap_records" */
  update_laplace_swap_records_many?: Maybe<Array<Maybe<LaplaceSwapRecordsMutationResponse>>>;
  /** update data of the table: "laplace.sync_status" */
  update_laplace_sync_status?: Maybe<LaplaceSyncStatusMutationResponse>;
  /** update single row of the table: "laplace.sync_status" */
  update_laplace_sync_status_by_pk?: Maybe<LaplaceSyncStatus>;
  /** update multiples rows of table: "laplace.sync_status" */
  update_laplace_sync_status_many?: Maybe<Array<Maybe<LaplaceSyncStatusMutationResponse>>>;
  /** update data of the table: "laplace.synced_blocks" */
  update_laplace_synced_blocks?: Maybe<LaplaceSyncedBlocksMutationResponse>;
  /** update single row of the table: "laplace.synced_blocks" */
  update_laplace_synced_blocks_by_pk?: Maybe<LaplaceSyncedBlocks>;
  /** update multiples rows of table: "laplace.synced_blocks" */
  update_laplace_synced_blocks_many?: Maybe<Array<Maybe<LaplaceSyncedBlocksMutationResponse>>>;
  /** update data of the table: "laplace.token_stats" */
  update_laplace_token_stats?: Maybe<LaplaceTokenStatsMutationResponse>;
  /** update single row of the table: "laplace.token_stats" */
  update_laplace_token_stats_by_pk?: Maybe<LaplaceTokenStats>;
  /** update multiples rows of table: "laplace.token_stats" */
  update_laplace_token_stats_many?: Maybe<Array<Maybe<LaplaceTokenStatsMutationResponse>>>;
  /** update data of the table: "laplace.token_tvl" */
  update_laplace_token_tvl?: Maybe<LaplaceTokenTvlMutationResponse>;
  /** update single row of the table: "laplace.token_tvl" */
  update_laplace_token_tvl_by_pk?: Maybe<LaplaceTokenTvl>;
  /** update multiples rows of table: "laplace.token_tvl" */
  update_laplace_token_tvl_many?: Maybe<Array<Maybe<LaplaceTokenTvlMutationResponse>>>;
  /** update data of the table: "laplace.yield_token_pool" */
  update_laplace_yield_token_pool?: Maybe<LaplaceYieldTokenPoolMutationResponse>;
  /** update single row of the table: "laplace.yield_token_pool" */
  update_laplace_yield_token_pool_by_pk?: Maybe<LaplaceYieldTokenPool>;
  /** update multiples rows of table: "laplace.yield_token_pool" */
  update_laplace_yield_token_pool_many?: Maybe<Array<Maybe<LaplaceYieldTokenPoolMutationResponse>>>;
  /** update data of the table: "public_dbt.autoalex_apower_distribution" */
  update_public_dbt_autoalex_apower_distribution?: Maybe<PublicDbtAutoalexApowerDistributionMutationResponse>;
  /** update multiples rows of table: "public_dbt.autoalex_apower_distribution" */
  update_public_dbt_autoalex_apower_distribution_many?: Maybe<Array<Maybe<PublicDbtAutoalexApowerDistributionMutationResponse>>>;
  /** update data of the table: "public_dbt.autoalex_lockdrop_snapshot_config" */
  update_public_dbt_autoalex_lockdrop_snapshot_config?: Maybe<PublicDbtAutoalexLockdropSnapshotConfigMutationResponse>;
  /** update multiples rows of table: "public_dbt.autoalex_lockdrop_snapshot_config" */
  update_public_dbt_autoalex_lockdrop_snapshot_config_many?: Maybe<Array<Maybe<PublicDbtAutoalexLockdropSnapshotConfigMutationResponse>>>;
  /** update data of the table: "public_dbt.autoalex_snapshot_config" */
  update_public_dbt_autoalex_snapshot_config?: Maybe<PublicDbtAutoalexSnapshotConfigMutationResponse>;
  /** update multiples rows of table: "public_dbt.autoalex_snapshot_config" */
  update_public_dbt_autoalex_snapshot_config_many?: Maybe<Array<Maybe<PublicDbtAutoalexSnapshotConfigMutationResponse>>>;
  /** update data of the table: "public_dbt.dim_balance_autoalex_rank_on_height_view" */
  update_public_dbt_dim_balance_autoalex_rank_on_height_view?: Maybe<PublicDbtDimBalanceAutoalexRankOnHeightViewMutationResponse>;
  /** update multiples rows of table: "public_dbt.dim_balance_autoalex_rank_on_height_view" */
  update_public_dbt_dim_balance_autoalex_rank_on_height_view_many?: Maybe<Array<Maybe<PublicDbtDimBalanceAutoalexRankOnHeightViewMutationResponse>>>;
  /** update data of the table: "public_dbt.dim_balance_autoalex_rank_view" */
  update_public_dbt_dim_balance_autoalex_rank_view?: Maybe<PublicDbtDimBalanceAutoalexRankViewMutationResponse>;
  /** update multiples rows of table: "public_dbt.dim_balance_autoalex_rank_view" */
  update_public_dbt_dim_balance_autoalex_rank_view_many?: Maybe<Array<Maybe<PublicDbtDimBalanceAutoalexRankViewMutationResponse>>>;
  /** update data of the table: "smart_contracts" */
  update_smart_contracts?: Maybe<SmartContractsMutationResponse>;
  /** update single row of the table: "smart_contracts" */
  update_smart_contracts_by_pk?: Maybe<SmartContracts>;
  /** update multiples rows of table: "smart_contracts" */
  update_smart_contracts_many?: Maybe<Array<Maybe<SmartContractsMutationResponse>>>;
  /** update data of the table: "stx_events" */
  update_stx_events?: Maybe<StxEventsMutationResponse>;
  /** update single row of the table: "stx_events" */
  update_stx_events_by_pk?: Maybe<StxEvents>;
  /** update multiples rows of table: "stx_events" */
  update_stx_events_many?: Maybe<Array<Maybe<StxEventsMutationResponse>>>;
  /** update data of the table: "txs" */
  update_txs?: Maybe<TxsMutationResponse>;
  /** update single row of the table: "txs" */
  update_txs_by_pk?: Maybe<Txs>;
  /** update multiples rows of table: "txs" */
  update_txs_many?: Maybe<Array<Maybe<TxsMutationResponse>>>;
};


/** mutation root */
export type MutationRootDeleteBlocksArgs = {
  where: BlocksBoolExp;
};


/** mutation root */
export type MutationRootDeleteBlocksByPkArgs = {
  index_block_hash: Scalars['bytea'];
};


/** mutation root */
export type MutationRootDeleteContractLogsArgs = {
  where: ContractLogsBoolExp;
};


/** mutation root */
export type MutationRootDeleteContractLogsByPkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type MutationRootDeleteFtEventsArgs = {
  where: FtEventsBoolExp;
};


/** mutation root */
export type MutationRootDeleteFtEventsByPkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type MutationRootDeleteLaplaceAlexReservePoolsArgs = {
  where: LaplaceAlexReservePoolsBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceAlexReservePoolsByPkArgs = {
  block_height: Scalars['Int'];
  token_deployer_address: Scalars['String'];
  token_name: Scalars['String'];
};


/** mutation root */
export type MutationRootDeleteLaplaceBorrowDepositDailyStatsArgs = {
  where: LaplaceBorrowDepositDailyStatsBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceBorrowDepositDailyStatsByPkArgs = {
  day: Scalars['numeric'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};


/** mutation root */
export type MutationRootDeleteLaplaceBorrowDepositHourlyStatsArgs = {
  where: LaplaceBorrowDepositHourlyStatsBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceBorrowDepositHourlyStatsByPkArgs = {
  expiry: Scalars['numeric'];
  hour: Scalars['numeric'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};


/** mutation root */
export type MutationRootDeleteLaplaceBorrowDepositStatsArgs = {
  where: LaplaceBorrowDepositStatsBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceBorrowDepositStatsByPkArgs = {
  block_height: Scalars['numeric'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};


/** mutation root */
export type MutationRootDeleteLaplaceCoinGeckoArgs = {
  where: LaplaceCoinGeckoBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceCoinGeckoArchiveArgs = {
  where: LaplaceCoinGeckoArchiveBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceCoinGeckoArchiveByPkArgs = {
  timestamp: Scalars['timestamptz'];
  token: Scalars['String'];
};


/** mutation root */
export type MutationRootDeleteLaplaceCoinGeckoByPkArgs = {
  token: Scalars['String'];
};


/** mutation root */
export type MutationRootDeleteLaplaceCollateralRebalancingPoolArgs = {
  where: LaplaceCollateralRebalancingPoolBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceCollateralRebalancingPoolByPkArgs = {
  block_height: Scalars['numeric'];
  expiry: Scalars['numeric'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};


/** mutation root */
export type MutationRootDeleteLaplaceConfigContractsArgs = {
  where: LaplaceConfigContractsBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceConfigContractsByPkArgs = {
  contract: Scalars['String'];
};


/** mutation root */
export type MutationRootDeleteLaplaceContractCallsArgs = {
  where: LaplaceContractCallsBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceContractCallsByPkArgs = {
  block_height: Scalars['Int'];
  tx_id: Scalars['bytea'];
};


/** mutation root */
export type MutationRootDeleteLaplaceDeployedContractsArgs = {
  where: LaplaceDeployedContractsBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceDeployedContractsByPkArgs = {
  contract_name: Scalars['String'];
  deployer_address: Scalars['String'];
  tx_id: Scalars['String'];
};


/** mutation root */
export type MutationRootDeleteLaplaceExternalTokenPriceArgs = {
  where: LaplaceExternalTokenPriceBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceExternalTokenPriceByPkArgs = {
  token_name: Scalars['String'];
};


/** mutation root */
export type MutationRootDeleteLaplaceFixedWeightPoolV1_01Args = {
  where: LaplaceFixedWeightPoolV1_01BoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceFixedWeightPoolV1_01ByPkArgs = {
  block_height: Scalars['Int'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
  weight_x: Scalars['bigint'];
  weight_y: Scalars['bigint'];
};


/** mutation root */
export type MutationRootDeleteLaplaceHistoryPriceDataArgs = {
  where: LaplaceHistoryPriceDataBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceHistoryPriceDataByPkArgs = {
  block_height: Scalars['numeric'];
  token: Scalars['String'];
};


/** mutation root */
export type MutationRootDeleteLaplaceHistoryStakingStatsArgs = {
  where: LaplaceHistoryStakingStatsBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceHistoryStakingStatsByPkArgs = {
  cycle: Scalars['Int'];
  token: Scalars['String'];
};


/** mutation root */
export type MutationRootDeleteLaplaceIdoPoolCreationArgs = {
  where: LaplaceIdoPoolCreationBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceIdoPoolCreationByPkArgs = {
  activation_threshold: Scalars['Int'];
  apower_per_ticket_in_fixed: Scalars['bigint'];
  claim_end_height: Scalars['Int'];
  ido_owner: Scalars['String'];
  ido_token: Scalars['String'];
  ido_tokens_per_ticket: Scalars['Int'];
  payment_token: Scalars['String'];
  registration_end_height: Scalars['Int'];
  registration_start_height: Scalars['Int'];
  tx_id: Scalars['String'];
};


/** mutation root */
export type MutationRootDeleteLaplaceIdoRegisterArgs = {
  where: LaplaceIdoRegisterBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceIdoRegisterByPkArgs = {
  block_height: Scalars['Int'];
  tx_id: Scalars['bytea'];
};


/** mutation root */
export type MutationRootDeleteLaplaceLatestAlexReservePoolsArgs = {
  where: LaplaceLatestAlexReservePoolsBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceLatestAlexReservePoolsByPkArgs = {
  token_deployer_address: Scalars['String'];
  token_name: Scalars['String'];
};


/** mutation root */
export type MutationRootDeleteLaplaceLatestAutoAlexArgs = {
  where: LaplaceLatestAutoAlexBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceLatestAutoAlexByPkArgs = {
  token_name: Scalars['String'];
};


/** mutation root */
export type MutationRootDeleteLaplaceLatestCollateralPerShareArgs = {
  where: LaplaceLatestCollateralPerShareBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceLatestCollateralPerShareByPkArgs = {
  expiry: Scalars['numeric'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};


/** mutation root */
export type MutationRootDeleteLaplaceLatestCollateralRebalancingPoolArgs = {
  where: LaplaceLatestCollateralRebalancingPoolBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceLatestCollateralRebalancingPoolByPkArgs = {
  expiry: Scalars['numeric'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};


/** mutation root */
export type MutationRootDeleteLaplaceLatestFixedWeightPoolV1_01Args = {
  where: LaplaceLatestFixedWeightPoolV1_01BoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceLatestFixedWeightPoolV1_01ByPkArgs = {
  token_x: Scalars['String'];
  token_y: Scalars['String'];
  weight_x: Scalars['bigint'];
  weight_y: Scalars['bigint'];
};


/** mutation root */
export type MutationRootDeleteLaplaceLatestPoolStatsArgs = {
  where: LaplaceLatestPoolStatsBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceLatestPoolStatsByPkArgs = {
  pool_token: Scalars['String'];
};


/** mutation root */
export type MutationRootDeleteLaplaceLatestSimpleWeightPoolAlexArgs = {
  where: LaplaceLatestSimpleWeightPoolAlexBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceLatestSimpleWeightPoolAlexByPkArgs = {
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};


/** mutation root */
export type MutationRootDeleteLaplaceLatestYieldTokenPoolArgs = {
  where: LaplaceLatestYieldTokenPoolBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceLatestYieldTokenPoolByPkArgs = {
  expiry: Scalars['numeric'];
  yield_token: Scalars['String'];
};


/** mutation root */
export type MutationRootDeleteLaplaceOracleInstantPriceArgs = {
  where: LaplaceOracleInstantPriceBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceOracleInstantPriceByPkArgs = {
  block_height: Scalars['numeric'];
  pool_token: Scalars['String'];
  token: Scalars['String'];
};


/** mutation root */
export type MutationRootDeleteLaplaceOracleResilientPriceArgs = {
  where: LaplaceOracleResilientPriceBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceOracleResilientPriceByPkArgs = {
  block_height: Scalars['numeric'];
  pool_token: Scalars['String'];
  token: Scalars['String'];
};


/** mutation root */
export type MutationRootDeleteLaplacePoolStatsArgs = {
  where: LaplacePoolStatsBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplacePoolStatsByPkArgs = {
  block_height: Scalars['numeric'];
  pool_token: Scalars['String'];
};


/** mutation root */
export type MutationRootDeleteLaplaceRewardCycleStatsArgs = {
  where: LaplaceRewardCycleStatsBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceRewardCycleStatsByPkArgs = {
  block_height: Scalars['bigint'];
  token: Scalars['String'];
};


/** mutation root */
export type MutationRootDeleteLaplaceSimpleWeightPoolAlexArgs = {
  where: LaplaceSimpleWeightPoolAlexBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceSimpleWeightPoolAlexByPkArgs = {
  block_height: Scalars['Int'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};


/** mutation root */
export type MutationRootDeleteLaplaceStacksBlockchainEventsArgs = {
  where: LaplaceStacksBlockchainEventsBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceSwapRecordsArgs = {
  where: LaplaceSwapRecordsBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceSwapRecordsByPkArgs = {
  event_index: Scalars['numeric'];
  tx_id: Scalars['String'];
};


/** mutation root */
export type MutationRootDeleteLaplaceSyncStatusArgs = {
  where: LaplaceSyncStatusBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceSyncStatusByPkArgs = {
  key: Scalars['String'];
};


/** mutation root */
export type MutationRootDeleteLaplaceSyncedBlocksArgs = {
  where: LaplaceSyncedBlocksBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceSyncedBlocksByPkArgs = {
  block_height: Scalars['Int'];
};


/** mutation root */
export type MutationRootDeleteLaplaceTokenStatsArgs = {
  where: LaplaceTokenStatsBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceTokenStatsByPkArgs = {
  token_name: Scalars['String'];
};


/** mutation root */
export type MutationRootDeleteLaplaceTokenTvlArgs = {
  where: LaplaceTokenTvlBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceTokenTvlByPkArgs = {
  block_height: Scalars['numeric'];
  token: Scalars['String'];
};


/** mutation root */
export type MutationRootDeleteLaplaceYieldTokenPoolArgs = {
  where: LaplaceYieldTokenPoolBoolExp;
};


/** mutation root */
export type MutationRootDeleteLaplaceYieldTokenPoolByPkArgs = {
  block_height: Scalars['numeric'];
  expiry: Scalars['numeric'];
  yield_token: Scalars['String'];
};


/** mutation root */
export type MutationRootDeletePublicDbtAutoalexApowerDistributionArgs = {
  where: PublicDbtAutoalexApowerDistributionBoolExp;
};


/** mutation root */
export type MutationRootDeletePublicDbtAutoalexLockdropSnapshotConfigArgs = {
  where: PublicDbtAutoalexLockdropSnapshotConfigBoolExp;
};


/** mutation root */
export type MutationRootDeletePublicDbtAutoalexSnapshotConfigArgs = {
  where: PublicDbtAutoalexSnapshotConfigBoolExp;
};


/** mutation root */
export type MutationRootDeletePublicDbtDimBalanceAutoalexRankOnHeightViewArgs = {
  where: PublicDbtDimBalanceAutoalexRankOnHeightViewBoolExp;
};


/** mutation root */
export type MutationRootDeletePublicDbtDimBalanceAutoalexRankViewArgs = {
  where: PublicDbtDimBalanceAutoalexRankViewBoolExp;
};


/** mutation root */
export type MutationRootDeleteSmartContractsArgs = {
  where: SmartContractsBoolExp;
};


/** mutation root */
export type MutationRootDeleteSmartContractsByPkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type MutationRootDeleteStxEventsArgs = {
  where: StxEventsBoolExp;
};


/** mutation root */
export type MutationRootDeleteStxEventsByPkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type MutationRootDeleteTxsArgs = {
  where: TxsBoolExp;
};


/** mutation root */
export type MutationRootDeleteTxsByPkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type MutationRootInsertBlocksArgs = {
  objects: Array<BlocksInsertInput>;
  on_conflict?: InputMaybe<BlocksOnConflict>;
};


/** mutation root */
export type MutationRootInsertBlocksOneArgs = {
  object: BlocksInsertInput;
  on_conflict?: InputMaybe<BlocksOnConflict>;
};


/** mutation root */
export type MutationRootInsertContractLogsArgs = {
  objects: Array<ContractLogsInsertInput>;
  on_conflict?: InputMaybe<ContractLogsOnConflict>;
};


/** mutation root */
export type MutationRootInsertContractLogsOneArgs = {
  object: ContractLogsInsertInput;
  on_conflict?: InputMaybe<ContractLogsOnConflict>;
};


/** mutation root */
export type MutationRootInsertFtEventsArgs = {
  objects: Array<FtEventsInsertInput>;
  on_conflict?: InputMaybe<FtEventsOnConflict>;
};


/** mutation root */
export type MutationRootInsertFtEventsOneArgs = {
  object: FtEventsInsertInput;
  on_conflict?: InputMaybe<FtEventsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceAlexReservePoolsArgs = {
  objects: Array<LaplaceAlexReservePoolsInsertInput>;
  on_conflict?: InputMaybe<LaplaceAlexReservePoolsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceAlexReservePoolsOneArgs = {
  object: LaplaceAlexReservePoolsInsertInput;
  on_conflict?: InputMaybe<LaplaceAlexReservePoolsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceBorrowDepositDailyStatsArgs = {
  objects: Array<LaplaceBorrowDepositDailyStatsInsertInput>;
  on_conflict?: InputMaybe<LaplaceBorrowDepositDailyStatsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceBorrowDepositDailyStatsOneArgs = {
  object: LaplaceBorrowDepositDailyStatsInsertInput;
  on_conflict?: InputMaybe<LaplaceBorrowDepositDailyStatsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceBorrowDepositHourlyStatsArgs = {
  objects: Array<LaplaceBorrowDepositHourlyStatsInsertInput>;
  on_conflict?: InputMaybe<LaplaceBorrowDepositHourlyStatsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceBorrowDepositHourlyStatsOneArgs = {
  object: LaplaceBorrowDepositHourlyStatsInsertInput;
  on_conflict?: InputMaybe<LaplaceBorrowDepositHourlyStatsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceBorrowDepositStatsArgs = {
  objects: Array<LaplaceBorrowDepositStatsInsertInput>;
  on_conflict?: InputMaybe<LaplaceBorrowDepositStatsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceBorrowDepositStatsOneArgs = {
  object: LaplaceBorrowDepositStatsInsertInput;
  on_conflict?: InputMaybe<LaplaceBorrowDepositStatsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceCoinGeckoArgs = {
  objects: Array<LaplaceCoinGeckoInsertInput>;
  on_conflict?: InputMaybe<LaplaceCoinGeckoOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceCoinGeckoArchiveArgs = {
  objects: Array<LaplaceCoinGeckoArchiveInsertInput>;
  on_conflict?: InputMaybe<LaplaceCoinGeckoArchiveOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceCoinGeckoArchiveOneArgs = {
  object: LaplaceCoinGeckoArchiveInsertInput;
  on_conflict?: InputMaybe<LaplaceCoinGeckoArchiveOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceCoinGeckoOneArgs = {
  object: LaplaceCoinGeckoInsertInput;
  on_conflict?: InputMaybe<LaplaceCoinGeckoOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceCollateralRebalancingPoolArgs = {
  objects: Array<LaplaceCollateralRebalancingPoolInsertInput>;
  on_conflict?: InputMaybe<LaplaceCollateralRebalancingPoolOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceCollateralRebalancingPoolOneArgs = {
  object: LaplaceCollateralRebalancingPoolInsertInput;
  on_conflict?: InputMaybe<LaplaceCollateralRebalancingPoolOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceConfigContractsArgs = {
  objects: Array<LaplaceConfigContractsInsertInput>;
  on_conflict?: InputMaybe<LaplaceConfigContractsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceConfigContractsOneArgs = {
  object: LaplaceConfigContractsInsertInput;
  on_conflict?: InputMaybe<LaplaceConfigContractsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceContractCallsArgs = {
  objects: Array<LaplaceContractCallsInsertInput>;
  on_conflict?: InputMaybe<LaplaceContractCallsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceContractCallsOneArgs = {
  object: LaplaceContractCallsInsertInput;
  on_conflict?: InputMaybe<LaplaceContractCallsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceDeployedContractsArgs = {
  objects: Array<LaplaceDeployedContractsInsertInput>;
  on_conflict?: InputMaybe<LaplaceDeployedContractsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceDeployedContractsOneArgs = {
  object: LaplaceDeployedContractsInsertInput;
  on_conflict?: InputMaybe<LaplaceDeployedContractsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceExternalTokenPriceArgs = {
  objects: Array<LaplaceExternalTokenPriceInsertInput>;
  on_conflict?: InputMaybe<LaplaceExternalTokenPriceOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceExternalTokenPriceOneArgs = {
  object: LaplaceExternalTokenPriceInsertInput;
  on_conflict?: InputMaybe<LaplaceExternalTokenPriceOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceFixedWeightPoolV1_01Args = {
  objects: Array<LaplaceFixedWeightPoolV1_01InsertInput>;
  on_conflict?: InputMaybe<LaplaceFixedWeightPoolV1_01OnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceFixedWeightPoolV1_01OneArgs = {
  object: LaplaceFixedWeightPoolV1_01InsertInput;
  on_conflict?: InputMaybe<LaplaceFixedWeightPoolV1_01OnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceHistoryPriceDataArgs = {
  objects: Array<LaplaceHistoryPriceDataInsertInput>;
  on_conflict?: InputMaybe<LaplaceHistoryPriceDataOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceHistoryPriceDataOneArgs = {
  object: LaplaceHistoryPriceDataInsertInput;
  on_conflict?: InputMaybe<LaplaceHistoryPriceDataOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceHistoryStakingStatsArgs = {
  objects: Array<LaplaceHistoryStakingStatsInsertInput>;
  on_conflict?: InputMaybe<LaplaceHistoryStakingStatsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceHistoryStakingStatsOneArgs = {
  object: LaplaceHistoryStakingStatsInsertInput;
  on_conflict?: InputMaybe<LaplaceHistoryStakingStatsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceIdoPoolCreationArgs = {
  objects: Array<LaplaceIdoPoolCreationInsertInput>;
  on_conflict?: InputMaybe<LaplaceIdoPoolCreationOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceIdoPoolCreationOneArgs = {
  object: LaplaceIdoPoolCreationInsertInput;
  on_conflict?: InputMaybe<LaplaceIdoPoolCreationOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceIdoRegisterArgs = {
  objects: Array<LaplaceIdoRegisterInsertInput>;
  on_conflict?: InputMaybe<LaplaceIdoRegisterOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceIdoRegisterOneArgs = {
  object: LaplaceIdoRegisterInsertInput;
  on_conflict?: InputMaybe<LaplaceIdoRegisterOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceLatestAlexReservePoolsArgs = {
  objects: Array<LaplaceLatestAlexReservePoolsInsertInput>;
  on_conflict?: InputMaybe<LaplaceLatestAlexReservePoolsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceLatestAlexReservePoolsOneArgs = {
  object: LaplaceLatestAlexReservePoolsInsertInput;
  on_conflict?: InputMaybe<LaplaceLatestAlexReservePoolsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceLatestAutoAlexArgs = {
  objects: Array<LaplaceLatestAutoAlexInsertInput>;
  on_conflict?: InputMaybe<LaplaceLatestAutoAlexOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceLatestAutoAlexOneArgs = {
  object: LaplaceLatestAutoAlexInsertInput;
  on_conflict?: InputMaybe<LaplaceLatestAutoAlexOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceLatestCollateralPerShareArgs = {
  objects: Array<LaplaceLatestCollateralPerShareInsertInput>;
  on_conflict?: InputMaybe<LaplaceLatestCollateralPerShareOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceLatestCollateralPerShareOneArgs = {
  object: LaplaceLatestCollateralPerShareInsertInput;
  on_conflict?: InputMaybe<LaplaceLatestCollateralPerShareOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceLatestCollateralRebalancingPoolArgs = {
  objects: Array<LaplaceLatestCollateralRebalancingPoolInsertInput>;
  on_conflict?: InputMaybe<LaplaceLatestCollateralRebalancingPoolOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceLatestCollateralRebalancingPoolOneArgs = {
  object: LaplaceLatestCollateralRebalancingPoolInsertInput;
  on_conflict?: InputMaybe<LaplaceLatestCollateralRebalancingPoolOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceLatestFixedWeightPoolV1_01Args = {
  objects: Array<LaplaceLatestFixedWeightPoolV1_01InsertInput>;
  on_conflict?: InputMaybe<LaplaceLatestFixedWeightPoolV1_01OnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceLatestFixedWeightPoolV1_01OneArgs = {
  object: LaplaceLatestFixedWeightPoolV1_01InsertInput;
  on_conflict?: InputMaybe<LaplaceLatestFixedWeightPoolV1_01OnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceLatestPoolStatsArgs = {
  objects: Array<LaplaceLatestPoolStatsInsertInput>;
  on_conflict?: InputMaybe<LaplaceLatestPoolStatsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceLatestPoolStatsOneArgs = {
  object: LaplaceLatestPoolStatsInsertInput;
  on_conflict?: InputMaybe<LaplaceLatestPoolStatsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceLatestSimpleWeightPoolAlexArgs = {
  objects: Array<LaplaceLatestSimpleWeightPoolAlexInsertInput>;
  on_conflict?: InputMaybe<LaplaceLatestSimpleWeightPoolAlexOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceLatestSimpleWeightPoolAlexOneArgs = {
  object: LaplaceLatestSimpleWeightPoolAlexInsertInput;
  on_conflict?: InputMaybe<LaplaceLatestSimpleWeightPoolAlexOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceLatestYieldTokenPoolArgs = {
  objects: Array<LaplaceLatestYieldTokenPoolInsertInput>;
  on_conflict?: InputMaybe<LaplaceLatestYieldTokenPoolOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceLatestYieldTokenPoolOneArgs = {
  object: LaplaceLatestYieldTokenPoolInsertInput;
  on_conflict?: InputMaybe<LaplaceLatestYieldTokenPoolOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceOracleInstantPriceArgs = {
  objects: Array<LaplaceOracleInstantPriceInsertInput>;
  on_conflict?: InputMaybe<LaplaceOracleInstantPriceOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceOracleInstantPriceOneArgs = {
  object: LaplaceOracleInstantPriceInsertInput;
  on_conflict?: InputMaybe<LaplaceOracleInstantPriceOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceOracleResilientPriceArgs = {
  objects: Array<LaplaceOracleResilientPriceInsertInput>;
  on_conflict?: InputMaybe<LaplaceOracleResilientPriceOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceOracleResilientPriceOneArgs = {
  object: LaplaceOracleResilientPriceInsertInput;
  on_conflict?: InputMaybe<LaplaceOracleResilientPriceOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplacePoolStatsArgs = {
  objects: Array<LaplacePoolStatsInsertInput>;
  on_conflict?: InputMaybe<LaplacePoolStatsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplacePoolStatsOneArgs = {
  object: LaplacePoolStatsInsertInput;
  on_conflict?: InputMaybe<LaplacePoolStatsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceRewardCycleStatsArgs = {
  objects: Array<LaplaceRewardCycleStatsInsertInput>;
  on_conflict?: InputMaybe<LaplaceRewardCycleStatsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceRewardCycleStatsOneArgs = {
  object: LaplaceRewardCycleStatsInsertInput;
  on_conflict?: InputMaybe<LaplaceRewardCycleStatsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceSimpleWeightPoolAlexArgs = {
  objects: Array<LaplaceSimpleWeightPoolAlexInsertInput>;
  on_conflict?: InputMaybe<LaplaceSimpleWeightPoolAlexOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceSimpleWeightPoolAlexOneArgs = {
  object: LaplaceSimpleWeightPoolAlexInsertInput;
  on_conflict?: InputMaybe<LaplaceSimpleWeightPoolAlexOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceStacksBlockchainEventsArgs = {
  objects: Array<LaplaceStacksBlockchainEventsInsertInput>;
};


/** mutation root */
export type MutationRootInsertLaplaceStacksBlockchainEventsOneArgs = {
  object: LaplaceStacksBlockchainEventsInsertInput;
};


/** mutation root */
export type MutationRootInsertLaplaceSwapRecordsArgs = {
  objects: Array<LaplaceSwapRecordsInsertInput>;
  on_conflict?: InputMaybe<LaplaceSwapRecordsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceSwapRecordsOneArgs = {
  object: LaplaceSwapRecordsInsertInput;
  on_conflict?: InputMaybe<LaplaceSwapRecordsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceSyncStatusArgs = {
  objects: Array<LaplaceSyncStatusInsertInput>;
  on_conflict?: InputMaybe<LaplaceSyncStatusOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceSyncStatusOneArgs = {
  object: LaplaceSyncStatusInsertInput;
  on_conflict?: InputMaybe<LaplaceSyncStatusOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceSyncedBlocksArgs = {
  objects: Array<LaplaceSyncedBlocksInsertInput>;
  on_conflict?: InputMaybe<LaplaceSyncedBlocksOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceSyncedBlocksOneArgs = {
  object: LaplaceSyncedBlocksInsertInput;
  on_conflict?: InputMaybe<LaplaceSyncedBlocksOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceTokenStatsArgs = {
  objects: Array<LaplaceTokenStatsInsertInput>;
  on_conflict?: InputMaybe<LaplaceTokenStatsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceTokenStatsOneArgs = {
  object: LaplaceTokenStatsInsertInput;
  on_conflict?: InputMaybe<LaplaceTokenStatsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceTokenTvlArgs = {
  objects: Array<LaplaceTokenTvlInsertInput>;
  on_conflict?: InputMaybe<LaplaceTokenTvlOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceTokenTvlOneArgs = {
  object: LaplaceTokenTvlInsertInput;
  on_conflict?: InputMaybe<LaplaceTokenTvlOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceYieldTokenPoolArgs = {
  objects: Array<LaplaceYieldTokenPoolInsertInput>;
  on_conflict?: InputMaybe<LaplaceYieldTokenPoolOnConflict>;
};


/** mutation root */
export type MutationRootInsertLaplaceYieldTokenPoolOneArgs = {
  object: LaplaceYieldTokenPoolInsertInput;
  on_conflict?: InputMaybe<LaplaceYieldTokenPoolOnConflict>;
};


/** mutation root */
export type MutationRootInsertPublicDbtAutoalexApowerDistributionArgs = {
  objects: Array<PublicDbtAutoalexApowerDistributionInsertInput>;
};


/** mutation root */
export type MutationRootInsertPublicDbtAutoalexApowerDistributionOneArgs = {
  object: PublicDbtAutoalexApowerDistributionInsertInput;
};


/** mutation root */
export type MutationRootInsertPublicDbtAutoalexLockdropSnapshotConfigArgs = {
  objects: Array<PublicDbtAutoalexLockdropSnapshotConfigInsertInput>;
};


/** mutation root */
export type MutationRootInsertPublicDbtAutoalexLockdropSnapshotConfigOneArgs = {
  object: PublicDbtAutoalexLockdropSnapshotConfigInsertInput;
};


/** mutation root */
export type MutationRootInsertPublicDbtAutoalexSnapshotConfigArgs = {
  objects: Array<PublicDbtAutoalexSnapshotConfigInsertInput>;
};


/** mutation root */
export type MutationRootInsertPublicDbtAutoalexSnapshotConfigOneArgs = {
  object: PublicDbtAutoalexSnapshotConfigInsertInput;
};


/** mutation root */
export type MutationRootInsertPublicDbtDimBalanceAutoalexRankOnHeightViewArgs = {
  objects: Array<PublicDbtDimBalanceAutoalexRankOnHeightViewInsertInput>;
};


/** mutation root */
export type MutationRootInsertPublicDbtDimBalanceAutoalexRankOnHeightViewOneArgs = {
  object: PublicDbtDimBalanceAutoalexRankOnHeightViewInsertInput;
};


/** mutation root */
export type MutationRootInsertPublicDbtDimBalanceAutoalexRankViewArgs = {
  objects: Array<PublicDbtDimBalanceAutoalexRankViewInsertInput>;
};


/** mutation root */
export type MutationRootInsertPublicDbtDimBalanceAutoalexRankViewOneArgs = {
  object: PublicDbtDimBalanceAutoalexRankViewInsertInput;
};


/** mutation root */
export type MutationRootInsertSmartContractsArgs = {
  objects: Array<SmartContractsInsertInput>;
  on_conflict?: InputMaybe<SmartContractsOnConflict>;
};


/** mutation root */
export type MutationRootInsertSmartContractsOneArgs = {
  object: SmartContractsInsertInput;
  on_conflict?: InputMaybe<SmartContractsOnConflict>;
};


/** mutation root */
export type MutationRootInsertStxEventsArgs = {
  objects: Array<StxEventsInsertInput>;
  on_conflict?: InputMaybe<StxEventsOnConflict>;
};


/** mutation root */
export type MutationRootInsertStxEventsOneArgs = {
  object: StxEventsInsertInput;
  on_conflict?: InputMaybe<StxEventsOnConflict>;
};


/** mutation root */
export type MutationRootInsertTxsArgs = {
  objects: Array<TxsInsertInput>;
  on_conflict?: InputMaybe<TxsOnConflict>;
};


/** mutation root */
export type MutationRootInsertTxsOneArgs = {
  object: TxsInsertInput;
  on_conflict?: InputMaybe<TxsOnConflict>;
};


/** mutation root */
export type MutationRootUpdateBlocksArgs = {
  _inc?: InputMaybe<BlocksIncInput>;
  _set?: InputMaybe<BlocksSetInput>;
  where: BlocksBoolExp;
};


/** mutation root */
export type MutationRootUpdateBlocksByPkArgs = {
  _inc?: InputMaybe<BlocksIncInput>;
  _set?: InputMaybe<BlocksSetInput>;
  pk_columns: BlocksPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateBlocksManyArgs = {
  updates: Array<BlocksUpdates>;
};


/** mutation root */
export type MutationRootUpdateContractLogsArgs = {
  _inc?: InputMaybe<ContractLogsIncInput>;
  _set?: InputMaybe<ContractLogsSetInput>;
  where: ContractLogsBoolExp;
};


/** mutation root */
export type MutationRootUpdateContractLogsByPkArgs = {
  _inc?: InputMaybe<ContractLogsIncInput>;
  _set?: InputMaybe<ContractLogsSetInput>;
  pk_columns: ContractLogsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateContractLogsManyArgs = {
  updates: Array<ContractLogsUpdates>;
};


/** mutation root */
export type MutationRootUpdateFtEventsArgs = {
  _inc?: InputMaybe<FtEventsIncInput>;
  _set?: InputMaybe<FtEventsSetInput>;
  where: FtEventsBoolExp;
};


/** mutation root */
export type MutationRootUpdateFtEventsByPkArgs = {
  _inc?: InputMaybe<FtEventsIncInput>;
  _set?: InputMaybe<FtEventsSetInput>;
  pk_columns: FtEventsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateFtEventsManyArgs = {
  updates: Array<FtEventsUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceAlexReservePoolsArgs = {
  _append?: InputMaybe<LaplaceAlexReservePoolsAppendInput>;
  _delete_at_path?: InputMaybe<LaplaceAlexReservePoolsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<LaplaceAlexReservePoolsDeleteElemInput>;
  _delete_key?: InputMaybe<LaplaceAlexReservePoolsDeleteKeyInput>;
  _inc?: InputMaybe<LaplaceAlexReservePoolsIncInput>;
  _prepend?: InputMaybe<LaplaceAlexReservePoolsPrependInput>;
  _set?: InputMaybe<LaplaceAlexReservePoolsSetInput>;
  where: LaplaceAlexReservePoolsBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceAlexReservePoolsByPkArgs = {
  _append?: InputMaybe<LaplaceAlexReservePoolsAppendInput>;
  _delete_at_path?: InputMaybe<LaplaceAlexReservePoolsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<LaplaceAlexReservePoolsDeleteElemInput>;
  _delete_key?: InputMaybe<LaplaceAlexReservePoolsDeleteKeyInput>;
  _inc?: InputMaybe<LaplaceAlexReservePoolsIncInput>;
  _prepend?: InputMaybe<LaplaceAlexReservePoolsPrependInput>;
  _set?: InputMaybe<LaplaceAlexReservePoolsSetInput>;
  pk_columns: LaplaceAlexReservePoolsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceAlexReservePoolsManyArgs = {
  updates: Array<LaplaceAlexReservePoolsUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceBorrowDepositDailyStatsArgs = {
  _inc?: InputMaybe<LaplaceBorrowDepositDailyStatsIncInput>;
  _set?: InputMaybe<LaplaceBorrowDepositDailyStatsSetInput>;
  where: LaplaceBorrowDepositDailyStatsBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceBorrowDepositDailyStatsByPkArgs = {
  _inc?: InputMaybe<LaplaceBorrowDepositDailyStatsIncInput>;
  _set?: InputMaybe<LaplaceBorrowDepositDailyStatsSetInput>;
  pk_columns: LaplaceBorrowDepositDailyStatsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceBorrowDepositDailyStatsManyArgs = {
  updates: Array<LaplaceBorrowDepositDailyStatsUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceBorrowDepositHourlyStatsArgs = {
  _inc?: InputMaybe<LaplaceBorrowDepositHourlyStatsIncInput>;
  _set?: InputMaybe<LaplaceBorrowDepositHourlyStatsSetInput>;
  where: LaplaceBorrowDepositHourlyStatsBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceBorrowDepositHourlyStatsByPkArgs = {
  _inc?: InputMaybe<LaplaceBorrowDepositHourlyStatsIncInput>;
  _set?: InputMaybe<LaplaceBorrowDepositHourlyStatsSetInput>;
  pk_columns: LaplaceBorrowDepositHourlyStatsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceBorrowDepositHourlyStatsManyArgs = {
  updates: Array<LaplaceBorrowDepositHourlyStatsUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceBorrowDepositStatsArgs = {
  _inc?: InputMaybe<LaplaceBorrowDepositStatsIncInput>;
  _set?: InputMaybe<LaplaceBorrowDepositStatsSetInput>;
  where: LaplaceBorrowDepositStatsBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceBorrowDepositStatsByPkArgs = {
  _inc?: InputMaybe<LaplaceBorrowDepositStatsIncInput>;
  _set?: InputMaybe<LaplaceBorrowDepositStatsSetInput>;
  pk_columns: LaplaceBorrowDepositStatsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceBorrowDepositStatsManyArgs = {
  updates: Array<LaplaceBorrowDepositStatsUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceCoinGeckoArgs = {
  _append?: InputMaybe<LaplaceCoinGeckoAppendInput>;
  _delete_at_path?: InputMaybe<LaplaceCoinGeckoDeleteAtPathInput>;
  _delete_elem?: InputMaybe<LaplaceCoinGeckoDeleteElemInput>;
  _delete_key?: InputMaybe<LaplaceCoinGeckoDeleteKeyInput>;
  _inc?: InputMaybe<LaplaceCoinGeckoIncInput>;
  _prepend?: InputMaybe<LaplaceCoinGeckoPrependInput>;
  _set?: InputMaybe<LaplaceCoinGeckoSetInput>;
  where: LaplaceCoinGeckoBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceCoinGeckoArchiveArgs = {
  _append?: InputMaybe<LaplaceCoinGeckoArchiveAppendInput>;
  _delete_at_path?: InputMaybe<LaplaceCoinGeckoArchiveDeleteAtPathInput>;
  _delete_elem?: InputMaybe<LaplaceCoinGeckoArchiveDeleteElemInput>;
  _delete_key?: InputMaybe<LaplaceCoinGeckoArchiveDeleteKeyInput>;
  _inc?: InputMaybe<LaplaceCoinGeckoArchiveIncInput>;
  _prepend?: InputMaybe<LaplaceCoinGeckoArchivePrependInput>;
  _set?: InputMaybe<LaplaceCoinGeckoArchiveSetInput>;
  where: LaplaceCoinGeckoArchiveBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceCoinGeckoArchiveByPkArgs = {
  _append?: InputMaybe<LaplaceCoinGeckoArchiveAppendInput>;
  _delete_at_path?: InputMaybe<LaplaceCoinGeckoArchiveDeleteAtPathInput>;
  _delete_elem?: InputMaybe<LaplaceCoinGeckoArchiveDeleteElemInput>;
  _delete_key?: InputMaybe<LaplaceCoinGeckoArchiveDeleteKeyInput>;
  _inc?: InputMaybe<LaplaceCoinGeckoArchiveIncInput>;
  _prepend?: InputMaybe<LaplaceCoinGeckoArchivePrependInput>;
  _set?: InputMaybe<LaplaceCoinGeckoArchiveSetInput>;
  pk_columns: LaplaceCoinGeckoArchivePkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceCoinGeckoArchiveManyArgs = {
  updates: Array<LaplaceCoinGeckoArchiveUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceCoinGeckoByPkArgs = {
  _append?: InputMaybe<LaplaceCoinGeckoAppendInput>;
  _delete_at_path?: InputMaybe<LaplaceCoinGeckoDeleteAtPathInput>;
  _delete_elem?: InputMaybe<LaplaceCoinGeckoDeleteElemInput>;
  _delete_key?: InputMaybe<LaplaceCoinGeckoDeleteKeyInput>;
  _inc?: InputMaybe<LaplaceCoinGeckoIncInput>;
  _prepend?: InputMaybe<LaplaceCoinGeckoPrependInput>;
  _set?: InputMaybe<LaplaceCoinGeckoSetInput>;
  pk_columns: LaplaceCoinGeckoPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceCoinGeckoManyArgs = {
  updates: Array<LaplaceCoinGeckoUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceCollateralRebalancingPoolArgs = {
  _inc?: InputMaybe<LaplaceCollateralRebalancingPoolIncInput>;
  _set?: InputMaybe<LaplaceCollateralRebalancingPoolSetInput>;
  where: LaplaceCollateralRebalancingPoolBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceCollateralRebalancingPoolByPkArgs = {
  _inc?: InputMaybe<LaplaceCollateralRebalancingPoolIncInput>;
  _set?: InputMaybe<LaplaceCollateralRebalancingPoolSetInput>;
  pk_columns: LaplaceCollateralRebalancingPoolPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceCollateralRebalancingPoolManyArgs = {
  updates: Array<LaplaceCollateralRebalancingPoolUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceConfigContractsArgs = {
  _set?: InputMaybe<LaplaceConfigContractsSetInput>;
  where: LaplaceConfigContractsBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceConfigContractsByPkArgs = {
  _set?: InputMaybe<LaplaceConfigContractsSetInput>;
  pk_columns: LaplaceConfigContractsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceConfigContractsManyArgs = {
  updates: Array<LaplaceConfigContractsUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceContractCallsArgs = {
  _append?: InputMaybe<LaplaceContractCallsAppendInput>;
  _delete_at_path?: InputMaybe<LaplaceContractCallsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<LaplaceContractCallsDeleteElemInput>;
  _delete_key?: InputMaybe<LaplaceContractCallsDeleteKeyInput>;
  _inc?: InputMaybe<LaplaceContractCallsIncInput>;
  _prepend?: InputMaybe<LaplaceContractCallsPrependInput>;
  _set?: InputMaybe<LaplaceContractCallsSetInput>;
  where: LaplaceContractCallsBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceContractCallsByPkArgs = {
  _append?: InputMaybe<LaplaceContractCallsAppendInput>;
  _delete_at_path?: InputMaybe<LaplaceContractCallsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<LaplaceContractCallsDeleteElemInput>;
  _delete_key?: InputMaybe<LaplaceContractCallsDeleteKeyInput>;
  _inc?: InputMaybe<LaplaceContractCallsIncInput>;
  _prepend?: InputMaybe<LaplaceContractCallsPrependInput>;
  _set?: InputMaybe<LaplaceContractCallsSetInput>;
  pk_columns: LaplaceContractCallsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceContractCallsManyArgs = {
  updates: Array<LaplaceContractCallsUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceDeployedContractsArgs = {
  _set?: InputMaybe<LaplaceDeployedContractsSetInput>;
  where: LaplaceDeployedContractsBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceDeployedContractsByPkArgs = {
  _set?: InputMaybe<LaplaceDeployedContractsSetInput>;
  pk_columns: LaplaceDeployedContractsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceDeployedContractsManyArgs = {
  updates: Array<LaplaceDeployedContractsUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceExternalTokenPriceArgs = {
  _inc?: InputMaybe<LaplaceExternalTokenPriceIncInput>;
  _set?: InputMaybe<LaplaceExternalTokenPriceSetInput>;
  where: LaplaceExternalTokenPriceBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceExternalTokenPriceByPkArgs = {
  _inc?: InputMaybe<LaplaceExternalTokenPriceIncInput>;
  _set?: InputMaybe<LaplaceExternalTokenPriceSetInput>;
  pk_columns: LaplaceExternalTokenPricePkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceExternalTokenPriceManyArgs = {
  updates: Array<LaplaceExternalTokenPriceUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceFixedWeightPoolV1_01Args = {
  _inc?: InputMaybe<LaplaceFixedWeightPoolV1_01IncInput>;
  _set?: InputMaybe<LaplaceFixedWeightPoolV1_01SetInput>;
  where: LaplaceFixedWeightPoolV1_01BoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceFixedWeightPoolV1_01ByPkArgs = {
  _inc?: InputMaybe<LaplaceFixedWeightPoolV1_01IncInput>;
  _set?: InputMaybe<LaplaceFixedWeightPoolV1_01SetInput>;
  pk_columns: LaplaceFixedWeightPoolV1_01PkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceFixedWeightPoolV1_01ManyArgs = {
  updates: Array<LaplaceFixedWeightPoolV1_01Updates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceHistoryPriceDataArgs = {
  _inc?: InputMaybe<LaplaceHistoryPriceDataIncInput>;
  _set?: InputMaybe<LaplaceHistoryPriceDataSetInput>;
  where: LaplaceHistoryPriceDataBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceHistoryPriceDataByPkArgs = {
  _inc?: InputMaybe<LaplaceHistoryPriceDataIncInput>;
  _set?: InputMaybe<LaplaceHistoryPriceDataSetInput>;
  pk_columns: LaplaceHistoryPriceDataPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceHistoryPriceDataManyArgs = {
  updates: Array<LaplaceHistoryPriceDataUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceHistoryStakingStatsArgs = {
  _inc?: InputMaybe<LaplaceHistoryStakingStatsIncInput>;
  _set?: InputMaybe<LaplaceHistoryStakingStatsSetInput>;
  where: LaplaceHistoryStakingStatsBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceHistoryStakingStatsByPkArgs = {
  _inc?: InputMaybe<LaplaceHistoryStakingStatsIncInput>;
  _set?: InputMaybe<LaplaceHistoryStakingStatsSetInput>;
  pk_columns: LaplaceHistoryStakingStatsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceHistoryStakingStatsManyArgs = {
  updates: Array<LaplaceHistoryStakingStatsUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceIdoPoolCreationArgs = {
  _inc?: InputMaybe<LaplaceIdoPoolCreationIncInput>;
  _set?: InputMaybe<LaplaceIdoPoolCreationSetInput>;
  where: LaplaceIdoPoolCreationBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceIdoPoolCreationByPkArgs = {
  _inc?: InputMaybe<LaplaceIdoPoolCreationIncInput>;
  _set?: InputMaybe<LaplaceIdoPoolCreationSetInput>;
  pk_columns: LaplaceIdoPoolCreationPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceIdoPoolCreationManyArgs = {
  updates: Array<LaplaceIdoPoolCreationUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceIdoRegisterArgs = {
  _inc?: InputMaybe<LaplaceIdoRegisterIncInput>;
  _set?: InputMaybe<LaplaceIdoRegisterSetInput>;
  where: LaplaceIdoRegisterBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceIdoRegisterByPkArgs = {
  _inc?: InputMaybe<LaplaceIdoRegisterIncInput>;
  _set?: InputMaybe<LaplaceIdoRegisterSetInput>;
  pk_columns: LaplaceIdoRegisterPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceIdoRegisterManyArgs = {
  updates: Array<LaplaceIdoRegisterUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceLatestAlexReservePoolsArgs = {
  _append?: InputMaybe<LaplaceLatestAlexReservePoolsAppendInput>;
  _delete_at_path?: InputMaybe<LaplaceLatestAlexReservePoolsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<LaplaceLatestAlexReservePoolsDeleteElemInput>;
  _delete_key?: InputMaybe<LaplaceLatestAlexReservePoolsDeleteKeyInput>;
  _inc?: InputMaybe<LaplaceLatestAlexReservePoolsIncInput>;
  _prepend?: InputMaybe<LaplaceLatestAlexReservePoolsPrependInput>;
  _set?: InputMaybe<LaplaceLatestAlexReservePoolsSetInput>;
  where: LaplaceLatestAlexReservePoolsBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceLatestAlexReservePoolsByPkArgs = {
  _append?: InputMaybe<LaplaceLatestAlexReservePoolsAppendInput>;
  _delete_at_path?: InputMaybe<LaplaceLatestAlexReservePoolsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<LaplaceLatestAlexReservePoolsDeleteElemInput>;
  _delete_key?: InputMaybe<LaplaceLatestAlexReservePoolsDeleteKeyInput>;
  _inc?: InputMaybe<LaplaceLatestAlexReservePoolsIncInput>;
  _prepend?: InputMaybe<LaplaceLatestAlexReservePoolsPrependInput>;
  _set?: InputMaybe<LaplaceLatestAlexReservePoolsSetInput>;
  pk_columns: LaplaceLatestAlexReservePoolsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceLatestAlexReservePoolsManyArgs = {
  updates: Array<LaplaceLatestAlexReservePoolsUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceLatestAutoAlexArgs = {
  _append?: InputMaybe<LaplaceLatestAutoAlexAppendInput>;
  _delete_at_path?: InputMaybe<LaplaceLatestAutoAlexDeleteAtPathInput>;
  _delete_elem?: InputMaybe<LaplaceLatestAutoAlexDeleteElemInput>;
  _delete_key?: InputMaybe<LaplaceLatestAutoAlexDeleteKeyInput>;
  _inc?: InputMaybe<LaplaceLatestAutoAlexIncInput>;
  _prepend?: InputMaybe<LaplaceLatestAutoAlexPrependInput>;
  _set?: InputMaybe<LaplaceLatestAutoAlexSetInput>;
  where: LaplaceLatestAutoAlexBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceLatestAutoAlexByPkArgs = {
  _append?: InputMaybe<LaplaceLatestAutoAlexAppendInput>;
  _delete_at_path?: InputMaybe<LaplaceLatestAutoAlexDeleteAtPathInput>;
  _delete_elem?: InputMaybe<LaplaceLatestAutoAlexDeleteElemInput>;
  _delete_key?: InputMaybe<LaplaceLatestAutoAlexDeleteKeyInput>;
  _inc?: InputMaybe<LaplaceLatestAutoAlexIncInput>;
  _prepend?: InputMaybe<LaplaceLatestAutoAlexPrependInput>;
  _set?: InputMaybe<LaplaceLatestAutoAlexSetInput>;
  pk_columns: LaplaceLatestAutoAlexPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceLatestAutoAlexManyArgs = {
  updates: Array<LaplaceLatestAutoAlexUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceLatestCollateralPerShareArgs = {
  _inc?: InputMaybe<LaplaceLatestCollateralPerShareIncInput>;
  _set?: InputMaybe<LaplaceLatestCollateralPerShareSetInput>;
  where: LaplaceLatestCollateralPerShareBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceLatestCollateralPerShareByPkArgs = {
  _inc?: InputMaybe<LaplaceLatestCollateralPerShareIncInput>;
  _set?: InputMaybe<LaplaceLatestCollateralPerShareSetInput>;
  pk_columns: LaplaceLatestCollateralPerSharePkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceLatestCollateralPerShareManyArgs = {
  updates: Array<LaplaceLatestCollateralPerShareUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceLatestCollateralRebalancingPoolArgs = {
  _inc?: InputMaybe<LaplaceLatestCollateralRebalancingPoolIncInput>;
  _set?: InputMaybe<LaplaceLatestCollateralRebalancingPoolSetInput>;
  where: LaplaceLatestCollateralRebalancingPoolBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceLatestCollateralRebalancingPoolByPkArgs = {
  _inc?: InputMaybe<LaplaceLatestCollateralRebalancingPoolIncInput>;
  _set?: InputMaybe<LaplaceLatestCollateralRebalancingPoolSetInput>;
  pk_columns: LaplaceLatestCollateralRebalancingPoolPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceLatestCollateralRebalancingPoolManyArgs = {
  updates: Array<LaplaceLatestCollateralRebalancingPoolUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceLatestFixedWeightPoolV1_01Args = {
  _inc?: InputMaybe<LaplaceLatestFixedWeightPoolV1_01IncInput>;
  _set?: InputMaybe<LaplaceLatestFixedWeightPoolV1_01SetInput>;
  where: LaplaceLatestFixedWeightPoolV1_01BoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceLatestFixedWeightPoolV1_01ByPkArgs = {
  _inc?: InputMaybe<LaplaceLatestFixedWeightPoolV1_01IncInput>;
  _set?: InputMaybe<LaplaceLatestFixedWeightPoolV1_01SetInput>;
  pk_columns: LaplaceLatestFixedWeightPoolV1_01PkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceLatestFixedWeightPoolV1_01ManyArgs = {
  updates: Array<LaplaceLatestFixedWeightPoolV1_01Updates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceLatestPoolStatsArgs = {
  _inc?: InputMaybe<LaplaceLatestPoolStatsIncInput>;
  _set?: InputMaybe<LaplaceLatestPoolStatsSetInput>;
  where: LaplaceLatestPoolStatsBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceLatestPoolStatsByPkArgs = {
  _inc?: InputMaybe<LaplaceLatestPoolStatsIncInput>;
  _set?: InputMaybe<LaplaceLatestPoolStatsSetInput>;
  pk_columns: LaplaceLatestPoolStatsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceLatestPoolStatsManyArgs = {
  updates: Array<LaplaceLatestPoolStatsUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceLatestSimpleWeightPoolAlexArgs = {
  _inc?: InputMaybe<LaplaceLatestSimpleWeightPoolAlexIncInput>;
  _set?: InputMaybe<LaplaceLatestSimpleWeightPoolAlexSetInput>;
  where: LaplaceLatestSimpleWeightPoolAlexBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceLatestSimpleWeightPoolAlexByPkArgs = {
  _inc?: InputMaybe<LaplaceLatestSimpleWeightPoolAlexIncInput>;
  _set?: InputMaybe<LaplaceLatestSimpleWeightPoolAlexSetInput>;
  pk_columns: LaplaceLatestSimpleWeightPoolAlexPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceLatestSimpleWeightPoolAlexManyArgs = {
  updates: Array<LaplaceLatestSimpleWeightPoolAlexUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceLatestYieldTokenPoolArgs = {
  _inc?: InputMaybe<LaplaceLatestYieldTokenPoolIncInput>;
  _set?: InputMaybe<LaplaceLatestYieldTokenPoolSetInput>;
  where: LaplaceLatestYieldTokenPoolBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceLatestYieldTokenPoolByPkArgs = {
  _inc?: InputMaybe<LaplaceLatestYieldTokenPoolIncInput>;
  _set?: InputMaybe<LaplaceLatestYieldTokenPoolSetInput>;
  pk_columns: LaplaceLatestYieldTokenPoolPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceLatestYieldTokenPoolManyArgs = {
  updates: Array<LaplaceLatestYieldTokenPoolUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceOracleInstantPriceArgs = {
  _inc?: InputMaybe<LaplaceOracleInstantPriceIncInput>;
  _set?: InputMaybe<LaplaceOracleInstantPriceSetInput>;
  where: LaplaceOracleInstantPriceBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceOracleInstantPriceByPkArgs = {
  _inc?: InputMaybe<LaplaceOracleInstantPriceIncInput>;
  _set?: InputMaybe<LaplaceOracleInstantPriceSetInput>;
  pk_columns: LaplaceOracleInstantPricePkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceOracleInstantPriceManyArgs = {
  updates: Array<LaplaceOracleInstantPriceUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceOracleResilientPriceArgs = {
  _inc?: InputMaybe<LaplaceOracleResilientPriceIncInput>;
  _set?: InputMaybe<LaplaceOracleResilientPriceSetInput>;
  where: LaplaceOracleResilientPriceBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceOracleResilientPriceByPkArgs = {
  _inc?: InputMaybe<LaplaceOracleResilientPriceIncInput>;
  _set?: InputMaybe<LaplaceOracleResilientPriceSetInput>;
  pk_columns: LaplaceOracleResilientPricePkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceOracleResilientPriceManyArgs = {
  updates: Array<LaplaceOracleResilientPriceUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplacePoolStatsArgs = {
  _inc?: InputMaybe<LaplacePoolStatsIncInput>;
  _set?: InputMaybe<LaplacePoolStatsSetInput>;
  where: LaplacePoolStatsBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplacePoolStatsByPkArgs = {
  _inc?: InputMaybe<LaplacePoolStatsIncInput>;
  _set?: InputMaybe<LaplacePoolStatsSetInput>;
  pk_columns: LaplacePoolStatsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplacePoolStatsManyArgs = {
  updates: Array<LaplacePoolStatsUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceRewardCycleStatsArgs = {
  _append?: InputMaybe<LaplaceRewardCycleStatsAppendInput>;
  _delete_at_path?: InputMaybe<LaplaceRewardCycleStatsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<LaplaceRewardCycleStatsDeleteElemInput>;
  _delete_key?: InputMaybe<LaplaceRewardCycleStatsDeleteKeyInput>;
  _inc?: InputMaybe<LaplaceRewardCycleStatsIncInput>;
  _prepend?: InputMaybe<LaplaceRewardCycleStatsPrependInput>;
  _set?: InputMaybe<LaplaceRewardCycleStatsSetInput>;
  where: LaplaceRewardCycleStatsBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceRewardCycleStatsByPkArgs = {
  _append?: InputMaybe<LaplaceRewardCycleStatsAppendInput>;
  _delete_at_path?: InputMaybe<LaplaceRewardCycleStatsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<LaplaceRewardCycleStatsDeleteElemInput>;
  _delete_key?: InputMaybe<LaplaceRewardCycleStatsDeleteKeyInput>;
  _inc?: InputMaybe<LaplaceRewardCycleStatsIncInput>;
  _prepend?: InputMaybe<LaplaceRewardCycleStatsPrependInput>;
  _set?: InputMaybe<LaplaceRewardCycleStatsSetInput>;
  pk_columns: LaplaceRewardCycleStatsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceRewardCycleStatsManyArgs = {
  updates: Array<LaplaceRewardCycleStatsUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceSimpleWeightPoolAlexArgs = {
  _inc?: InputMaybe<LaplaceSimpleWeightPoolAlexIncInput>;
  _set?: InputMaybe<LaplaceSimpleWeightPoolAlexSetInput>;
  where: LaplaceSimpleWeightPoolAlexBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceSimpleWeightPoolAlexByPkArgs = {
  _inc?: InputMaybe<LaplaceSimpleWeightPoolAlexIncInput>;
  _set?: InputMaybe<LaplaceSimpleWeightPoolAlexSetInput>;
  pk_columns: LaplaceSimpleWeightPoolAlexPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceSimpleWeightPoolAlexManyArgs = {
  updates: Array<LaplaceSimpleWeightPoolAlexUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceStacksBlockchainEventsArgs = {
  _append?: InputMaybe<LaplaceStacksBlockchainEventsAppendInput>;
  _delete_at_path?: InputMaybe<LaplaceStacksBlockchainEventsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<LaplaceStacksBlockchainEventsDeleteElemInput>;
  _delete_key?: InputMaybe<LaplaceStacksBlockchainEventsDeleteKeyInput>;
  _inc?: InputMaybe<LaplaceStacksBlockchainEventsIncInput>;
  _prepend?: InputMaybe<LaplaceStacksBlockchainEventsPrependInput>;
  _set?: InputMaybe<LaplaceStacksBlockchainEventsSetInput>;
  where: LaplaceStacksBlockchainEventsBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceStacksBlockchainEventsManyArgs = {
  updates: Array<LaplaceStacksBlockchainEventsUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceSwapRecordsArgs = {
  _inc?: InputMaybe<LaplaceSwapRecordsIncInput>;
  _set?: InputMaybe<LaplaceSwapRecordsSetInput>;
  where: LaplaceSwapRecordsBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceSwapRecordsByPkArgs = {
  _inc?: InputMaybe<LaplaceSwapRecordsIncInput>;
  _set?: InputMaybe<LaplaceSwapRecordsSetInput>;
  pk_columns: LaplaceSwapRecordsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceSwapRecordsManyArgs = {
  updates: Array<LaplaceSwapRecordsUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceSyncStatusArgs = {
  _set?: InputMaybe<LaplaceSyncStatusSetInput>;
  where: LaplaceSyncStatusBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceSyncStatusByPkArgs = {
  _set?: InputMaybe<LaplaceSyncStatusSetInput>;
  pk_columns: LaplaceSyncStatusPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceSyncStatusManyArgs = {
  updates: Array<LaplaceSyncStatusUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceSyncedBlocksArgs = {
  _inc?: InputMaybe<LaplaceSyncedBlocksIncInput>;
  _set?: InputMaybe<LaplaceSyncedBlocksSetInput>;
  where: LaplaceSyncedBlocksBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceSyncedBlocksByPkArgs = {
  _inc?: InputMaybe<LaplaceSyncedBlocksIncInput>;
  _set?: InputMaybe<LaplaceSyncedBlocksSetInput>;
  pk_columns: LaplaceSyncedBlocksPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceSyncedBlocksManyArgs = {
  updates: Array<LaplaceSyncedBlocksUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceTokenStatsArgs = {
  _inc?: InputMaybe<LaplaceTokenStatsIncInput>;
  _set?: InputMaybe<LaplaceTokenStatsSetInput>;
  where: LaplaceTokenStatsBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceTokenStatsByPkArgs = {
  _inc?: InputMaybe<LaplaceTokenStatsIncInput>;
  _set?: InputMaybe<LaplaceTokenStatsSetInput>;
  pk_columns: LaplaceTokenStatsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceTokenStatsManyArgs = {
  updates: Array<LaplaceTokenStatsUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceTokenTvlArgs = {
  _inc?: InputMaybe<LaplaceTokenTvlIncInput>;
  _set?: InputMaybe<LaplaceTokenTvlSetInput>;
  where: LaplaceTokenTvlBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceTokenTvlByPkArgs = {
  _inc?: InputMaybe<LaplaceTokenTvlIncInput>;
  _set?: InputMaybe<LaplaceTokenTvlSetInput>;
  pk_columns: LaplaceTokenTvlPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceTokenTvlManyArgs = {
  updates: Array<LaplaceTokenTvlUpdates>;
};


/** mutation root */
export type MutationRootUpdateLaplaceYieldTokenPoolArgs = {
  _inc?: InputMaybe<LaplaceYieldTokenPoolIncInput>;
  _set?: InputMaybe<LaplaceYieldTokenPoolSetInput>;
  where: LaplaceYieldTokenPoolBoolExp;
};


/** mutation root */
export type MutationRootUpdateLaplaceYieldTokenPoolByPkArgs = {
  _inc?: InputMaybe<LaplaceYieldTokenPoolIncInput>;
  _set?: InputMaybe<LaplaceYieldTokenPoolSetInput>;
  pk_columns: LaplaceYieldTokenPoolPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLaplaceYieldTokenPoolManyArgs = {
  updates: Array<LaplaceYieldTokenPoolUpdates>;
};


/** mutation root */
export type MutationRootUpdatePublicDbtAutoalexApowerDistributionArgs = {
  _inc?: InputMaybe<PublicDbtAutoalexApowerDistributionIncInput>;
  _set?: InputMaybe<PublicDbtAutoalexApowerDistributionSetInput>;
  where: PublicDbtAutoalexApowerDistributionBoolExp;
};


/** mutation root */
export type MutationRootUpdatePublicDbtAutoalexApowerDistributionManyArgs = {
  updates: Array<PublicDbtAutoalexApowerDistributionUpdates>;
};


/** mutation root */
export type MutationRootUpdatePublicDbtAutoalexLockdropSnapshotConfigArgs = {
  _inc?: InputMaybe<PublicDbtAutoalexLockdropSnapshotConfigIncInput>;
  _set?: InputMaybe<PublicDbtAutoalexLockdropSnapshotConfigSetInput>;
  where: PublicDbtAutoalexLockdropSnapshotConfigBoolExp;
};


/** mutation root */
export type MutationRootUpdatePublicDbtAutoalexLockdropSnapshotConfigManyArgs = {
  updates: Array<PublicDbtAutoalexLockdropSnapshotConfigUpdates>;
};


/** mutation root */
export type MutationRootUpdatePublicDbtAutoalexSnapshotConfigArgs = {
  _inc?: InputMaybe<PublicDbtAutoalexSnapshotConfigIncInput>;
  _set?: InputMaybe<PublicDbtAutoalexSnapshotConfigSetInput>;
  where: PublicDbtAutoalexSnapshotConfigBoolExp;
};


/** mutation root */
export type MutationRootUpdatePublicDbtAutoalexSnapshotConfigManyArgs = {
  updates: Array<PublicDbtAutoalexSnapshotConfigUpdates>;
};


/** mutation root */
export type MutationRootUpdatePublicDbtDimBalanceAutoalexRankOnHeightViewArgs = {
  _inc?: InputMaybe<PublicDbtDimBalanceAutoalexRankOnHeightViewIncInput>;
  _set?: InputMaybe<PublicDbtDimBalanceAutoalexRankOnHeightViewSetInput>;
  where: PublicDbtDimBalanceAutoalexRankOnHeightViewBoolExp;
};


/** mutation root */
export type MutationRootUpdatePublicDbtDimBalanceAutoalexRankOnHeightViewManyArgs = {
  updates: Array<PublicDbtDimBalanceAutoalexRankOnHeightViewUpdates>;
};


/** mutation root */
export type MutationRootUpdatePublicDbtDimBalanceAutoalexRankViewArgs = {
  _inc?: InputMaybe<PublicDbtDimBalanceAutoalexRankViewIncInput>;
  _set?: InputMaybe<PublicDbtDimBalanceAutoalexRankViewSetInput>;
  where: PublicDbtDimBalanceAutoalexRankViewBoolExp;
};


/** mutation root */
export type MutationRootUpdatePublicDbtDimBalanceAutoalexRankViewManyArgs = {
  updates: Array<PublicDbtDimBalanceAutoalexRankViewUpdates>;
};


/** mutation root */
export type MutationRootUpdateSmartContractsArgs = {
  _append?: InputMaybe<SmartContractsAppendInput>;
  _delete_at_path?: InputMaybe<SmartContractsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<SmartContractsDeleteElemInput>;
  _delete_key?: InputMaybe<SmartContractsDeleteKeyInput>;
  _inc?: InputMaybe<SmartContractsIncInput>;
  _prepend?: InputMaybe<SmartContractsPrependInput>;
  _set?: InputMaybe<SmartContractsSetInput>;
  where: SmartContractsBoolExp;
};


/** mutation root */
export type MutationRootUpdateSmartContractsByPkArgs = {
  _append?: InputMaybe<SmartContractsAppendInput>;
  _delete_at_path?: InputMaybe<SmartContractsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<SmartContractsDeleteElemInput>;
  _delete_key?: InputMaybe<SmartContractsDeleteKeyInput>;
  _inc?: InputMaybe<SmartContractsIncInput>;
  _prepend?: InputMaybe<SmartContractsPrependInput>;
  _set?: InputMaybe<SmartContractsSetInput>;
  pk_columns: SmartContractsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateSmartContractsManyArgs = {
  updates: Array<SmartContractsUpdates>;
};


/** mutation root */
export type MutationRootUpdateStxEventsArgs = {
  _inc?: InputMaybe<StxEventsIncInput>;
  _set?: InputMaybe<StxEventsSetInput>;
  where: StxEventsBoolExp;
};


/** mutation root */
export type MutationRootUpdateStxEventsByPkArgs = {
  _inc?: InputMaybe<StxEventsIncInput>;
  _set?: InputMaybe<StxEventsSetInput>;
  pk_columns: StxEventsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateStxEventsManyArgs = {
  updates: Array<StxEventsUpdates>;
};


/** mutation root */
export type MutationRootUpdateTxsArgs = {
  _inc?: InputMaybe<TxsIncInput>;
  _set?: InputMaybe<TxsSetInput>;
  where: TxsBoolExp;
};


/** mutation root */
export type MutationRootUpdateTxsByPkArgs = {
  _inc?: InputMaybe<TxsIncInput>;
  _set?: InputMaybe<TxsSetInput>;
  pk_columns: TxsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateTxsManyArgs = {
  updates: Array<TxsUpdates>;
};

/** Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'. */
export type NumericComparisonExp = {
  _eq?: InputMaybe<Scalars['numeric']>;
  _gt?: InputMaybe<Scalars['numeric']>;
  _gte?: InputMaybe<Scalars['numeric']>;
  _in?: InputMaybe<Array<Scalars['numeric']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['numeric']>;
  _lte?: InputMaybe<Scalars['numeric']>;
  _neq?: InputMaybe<Scalars['numeric']>;
  _nin?: InputMaybe<Array<Scalars['numeric']>>;
};

/** column ordering options */
export enum OrderBy {
  /** in ascending order, nulls last */
  Asc = 'asc',
  /** in ascending order, nulls first */
  AscNullsFirst = 'asc_nulls_first',
  /** in ascending order, nulls last */
  AscNullsLast = 'asc_nulls_last',
  /** in descending order, nulls first */
  Desc = 'desc',
  /** in descending order, nulls first */
  DescNullsFirst = 'desc_nulls_first',
  /** in descending order, nulls last */
  DescNullsLast = 'desc_nulls_last'
}

/** columns and relationships of "public_dbt.autoalex_apower_distribution" */
export type PublicDbtAutoalexApowerDistribution = {
  __typename?: 'public_dbt_autoalex_apower_distribution';
  cycle_index?: Maybe<Scalars['Int']>;
  distance?: Maybe<Scalars['Int']>;
  end?: Maybe<Scalars['Int']>;
  random_height?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Int']>;
};

/** aggregated selection of "public_dbt.autoalex_apower_distribution" */
export type PublicDbtAutoalexApowerDistributionAggregate = {
  __typename?: 'public_dbt_autoalex_apower_distribution_aggregate';
  aggregate?: Maybe<PublicDbtAutoalexApowerDistributionAggregateFields>;
  nodes: Array<PublicDbtAutoalexApowerDistribution>;
};

/** aggregate fields of "public_dbt.autoalex_apower_distribution" */
export type PublicDbtAutoalexApowerDistributionAggregateFields = {
  __typename?: 'public_dbt_autoalex_apower_distribution_aggregate_fields';
  avg?: Maybe<PublicDbtAutoalexApowerDistributionAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<PublicDbtAutoalexApowerDistributionMaxFields>;
  min?: Maybe<PublicDbtAutoalexApowerDistributionMinFields>;
  stddev?: Maybe<PublicDbtAutoalexApowerDistributionStddevFields>;
  stddev_pop?: Maybe<PublicDbtAutoalexApowerDistributionStddevPopFields>;
  stddev_samp?: Maybe<PublicDbtAutoalexApowerDistributionStddevSampFields>;
  sum?: Maybe<PublicDbtAutoalexApowerDistributionSumFields>;
  var_pop?: Maybe<PublicDbtAutoalexApowerDistributionVarPopFields>;
  var_samp?: Maybe<PublicDbtAutoalexApowerDistributionVarSampFields>;
  variance?: Maybe<PublicDbtAutoalexApowerDistributionVarianceFields>;
};


/** aggregate fields of "public_dbt.autoalex_apower_distribution" */
export type PublicDbtAutoalexApowerDistributionAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PublicDbtAutoalexApowerDistributionSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type PublicDbtAutoalexApowerDistributionAvgFields = {
  __typename?: 'public_dbt_autoalex_apower_distribution_avg_fields';
  cycle_index?: Maybe<Scalars['Float']>;
  distance?: Maybe<Scalars['Float']>;
  end?: Maybe<Scalars['Float']>;
  random_height?: Maybe<Scalars['Float']>;
  start?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "public_dbt.autoalex_apower_distribution". All fields are combined with a logical 'AND'. */
export type PublicDbtAutoalexApowerDistributionBoolExp = {
  _and?: InputMaybe<Array<PublicDbtAutoalexApowerDistributionBoolExp>>;
  _not?: InputMaybe<PublicDbtAutoalexApowerDistributionBoolExp>;
  _or?: InputMaybe<Array<PublicDbtAutoalexApowerDistributionBoolExp>>;
  cycle_index?: InputMaybe<IntComparisonExp>;
  distance?: InputMaybe<IntComparisonExp>;
  end?: InputMaybe<IntComparisonExp>;
  random_height?: InputMaybe<IntComparisonExp>;
  start?: InputMaybe<IntComparisonExp>;
};

/** input type for incrementing numeric columns in table "public_dbt.autoalex_apower_distribution" */
export type PublicDbtAutoalexApowerDistributionIncInput = {
  cycle_index?: InputMaybe<Scalars['Int']>;
  distance?: InputMaybe<Scalars['Int']>;
  end?: InputMaybe<Scalars['Int']>;
  random_height?: InputMaybe<Scalars['Int']>;
  start?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "public_dbt.autoalex_apower_distribution" */
export type PublicDbtAutoalexApowerDistributionInsertInput = {
  cycle_index?: InputMaybe<Scalars['Int']>;
  distance?: InputMaybe<Scalars['Int']>;
  end?: InputMaybe<Scalars['Int']>;
  random_height?: InputMaybe<Scalars['Int']>;
  start?: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type PublicDbtAutoalexApowerDistributionMaxFields = {
  __typename?: 'public_dbt_autoalex_apower_distribution_max_fields';
  cycle_index?: Maybe<Scalars['Int']>;
  distance?: Maybe<Scalars['Int']>;
  end?: Maybe<Scalars['Int']>;
  random_height?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type PublicDbtAutoalexApowerDistributionMinFields = {
  __typename?: 'public_dbt_autoalex_apower_distribution_min_fields';
  cycle_index?: Maybe<Scalars['Int']>;
  distance?: Maybe<Scalars['Int']>;
  end?: Maybe<Scalars['Int']>;
  random_height?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "public_dbt.autoalex_apower_distribution" */
export type PublicDbtAutoalexApowerDistributionMutationResponse = {
  __typename?: 'public_dbt_autoalex_apower_distribution_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<PublicDbtAutoalexApowerDistribution>;
};

/** Ordering options when selecting data from "public_dbt.autoalex_apower_distribution". */
export type PublicDbtAutoalexApowerDistributionOrderBy = {
  cycle_index?: InputMaybe<OrderBy>;
  distance?: InputMaybe<OrderBy>;
  end?: InputMaybe<OrderBy>;
  random_height?: InputMaybe<OrderBy>;
  start?: InputMaybe<OrderBy>;
};

/** select columns of table "public_dbt.autoalex_apower_distribution" */
export enum PublicDbtAutoalexApowerDistributionSelectColumn {
  /** column name */
  CycleIndex = 'cycle_index',
  /** column name */
  Distance = 'distance',
  /** column name */
  End = 'end',
  /** column name */
  RandomHeight = 'random_height',
  /** column name */
  Start = 'start'
}

/** input type for updating data in table "public_dbt.autoalex_apower_distribution" */
export type PublicDbtAutoalexApowerDistributionSetInput = {
  cycle_index?: InputMaybe<Scalars['Int']>;
  distance?: InputMaybe<Scalars['Int']>;
  end?: InputMaybe<Scalars['Int']>;
  random_height?: InputMaybe<Scalars['Int']>;
  start?: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type PublicDbtAutoalexApowerDistributionStddevFields = {
  __typename?: 'public_dbt_autoalex_apower_distribution_stddev_fields';
  cycle_index?: Maybe<Scalars['Float']>;
  distance?: Maybe<Scalars['Float']>;
  end?: Maybe<Scalars['Float']>;
  random_height?: Maybe<Scalars['Float']>;
  start?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type PublicDbtAutoalexApowerDistributionStddevPopFields = {
  __typename?: 'public_dbt_autoalex_apower_distribution_stddev_pop_fields';
  cycle_index?: Maybe<Scalars['Float']>;
  distance?: Maybe<Scalars['Float']>;
  end?: Maybe<Scalars['Float']>;
  random_height?: Maybe<Scalars['Float']>;
  start?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type PublicDbtAutoalexApowerDistributionStddevSampFields = {
  __typename?: 'public_dbt_autoalex_apower_distribution_stddev_samp_fields';
  cycle_index?: Maybe<Scalars['Float']>;
  distance?: Maybe<Scalars['Float']>;
  end?: Maybe<Scalars['Float']>;
  random_height?: Maybe<Scalars['Float']>;
  start?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "public_dbt_autoalex_apower_distribution" */
export type PublicDbtAutoalexApowerDistributionStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: PublicDbtAutoalexApowerDistributionStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PublicDbtAutoalexApowerDistributionStreamCursorValueInput = {
  cycle_index?: InputMaybe<Scalars['Int']>;
  distance?: InputMaybe<Scalars['Int']>;
  end?: InputMaybe<Scalars['Int']>;
  random_height?: InputMaybe<Scalars['Int']>;
  start?: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type PublicDbtAutoalexApowerDistributionSumFields = {
  __typename?: 'public_dbt_autoalex_apower_distribution_sum_fields';
  cycle_index?: Maybe<Scalars['Int']>;
  distance?: Maybe<Scalars['Int']>;
  end?: Maybe<Scalars['Int']>;
  random_height?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Int']>;
};

export type PublicDbtAutoalexApowerDistributionUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<PublicDbtAutoalexApowerDistributionIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PublicDbtAutoalexApowerDistributionSetInput>;
  where: PublicDbtAutoalexApowerDistributionBoolExp;
};

/** aggregate var_pop on columns */
export type PublicDbtAutoalexApowerDistributionVarPopFields = {
  __typename?: 'public_dbt_autoalex_apower_distribution_var_pop_fields';
  cycle_index?: Maybe<Scalars['Float']>;
  distance?: Maybe<Scalars['Float']>;
  end?: Maybe<Scalars['Float']>;
  random_height?: Maybe<Scalars['Float']>;
  start?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type PublicDbtAutoalexApowerDistributionVarSampFields = {
  __typename?: 'public_dbt_autoalex_apower_distribution_var_samp_fields';
  cycle_index?: Maybe<Scalars['Float']>;
  distance?: Maybe<Scalars['Float']>;
  end?: Maybe<Scalars['Float']>;
  random_height?: Maybe<Scalars['Float']>;
  start?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type PublicDbtAutoalexApowerDistributionVarianceFields = {
  __typename?: 'public_dbt_autoalex_apower_distribution_variance_fields';
  cycle_index?: Maybe<Scalars['Float']>;
  distance?: Maybe<Scalars['Float']>;
  end?: Maybe<Scalars['Float']>;
  random_height?: Maybe<Scalars['Float']>;
  start?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "public_dbt.autoalex_claim_and_stake" */
export type PublicDbtAutoalexClaimAndStake = {
  __typename?: 'public_dbt_autoalex_claim_and_stake';
  apower_amount?: Maybe<Scalars['float8']>;
  apower_amount_fixed?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['Int']>;
  cycle_index?: Maybe<Scalars['Int']>;
  is_success?: Maybe<Scalars['Boolean']>;
};

/** aggregated selection of "public_dbt.autoalex_claim_and_stake" */
export type PublicDbtAutoalexClaimAndStakeAggregate = {
  __typename?: 'public_dbt_autoalex_claim_and_stake_aggregate';
  aggregate?: Maybe<PublicDbtAutoalexClaimAndStakeAggregateFields>;
  nodes: Array<PublicDbtAutoalexClaimAndStake>;
};

/** aggregate fields of "public_dbt.autoalex_claim_and_stake" */
export type PublicDbtAutoalexClaimAndStakeAggregateFields = {
  __typename?: 'public_dbt_autoalex_claim_and_stake_aggregate_fields';
  avg?: Maybe<PublicDbtAutoalexClaimAndStakeAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<PublicDbtAutoalexClaimAndStakeMaxFields>;
  min?: Maybe<PublicDbtAutoalexClaimAndStakeMinFields>;
  stddev?: Maybe<PublicDbtAutoalexClaimAndStakeStddevFields>;
  stddev_pop?: Maybe<PublicDbtAutoalexClaimAndStakeStddevPopFields>;
  stddev_samp?: Maybe<PublicDbtAutoalexClaimAndStakeStddevSampFields>;
  sum?: Maybe<PublicDbtAutoalexClaimAndStakeSumFields>;
  var_pop?: Maybe<PublicDbtAutoalexClaimAndStakeVarPopFields>;
  var_samp?: Maybe<PublicDbtAutoalexClaimAndStakeVarSampFields>;
  variance?: Maybe<PublicDbtAutoalexClaimAndStakeVarianceFields>;
};


/** aggregate fields of "public_dbt.autoalex_claim_and_stake" */
export type PublicDbtAutoalexClaimAndStakeAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PublicDbtAutoalexClaimAndStakeSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type PublicDbtAutoalexClaimAndStakeAvgFields = {
  __typename?: 'public_dbt_autoalex_claim_and_stake_avg_fields';
  apower_amount?: Maybe<Scalars['Float']>;
  apower_amount_fixed?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  cycle_index?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "public_dbt.autoalex_claim_and_stake". All fields are combined with a logical 'AND'. */
export type PublicDbtAutoalexClaimAndStakeBoolExp = {
  _and?: InputMaybe<Array<PublicDbtAutoalexClaimAndStakeBoolExp>>;
  _not?: InputMaybe<PublicDbtAutoalexClaimAndStakeBoolExp>;
  _or?: InputMaybe<Array<PublicDbtAutoalexClaimAndStakeBoolExp>>;
  apower_amount?: InputMaybe<Float8ComparisonExp>;
  apower_amount_fixed?: InputMaybe<NumericComparisonExp>;
  block_height?: InputMaybe<IntComparisonExp>;
  cycle_index?: InputMaybe<IntComparisonExp>;
  is_success?: InputMaybe<BooleanComparisonExp>;
};

/** aggregate max on columns */
export type PublicDbtAutoalexClaimAndStakeMaxFields = {
  __typename?: 'public_dbt_autoalex_claim_and_stake_max_fields';
  apower_amount?: Maybe<Scalars['float8']>;
  apower_amount_fixed?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['Int']>;
  cycle_index?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type PublicDbtAutoalexClaimAndStakeMinFields = {
  __typename?: 'public_dbt_autoalex_claim_and_stake_min_fields';
  apower_amount?: Maybe<Scalars['float8']>;
  apower_amount_fixed?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['Int']>;
  cycle_index?: Maybe<Scalars['Int']>;
};

/** Ordering options when selecting data from "public_dbt.autoalex_claim_and_stake". */
export type PublicDbtAutoalexClaimAndStakeOrderBy = {
  apower_amount?: InputMaybe<OrderBy>;
  apower_amount_fixed?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  cycle_index?: InputMaybe<OrderBy>;
  is_success?: InputMaybe<OrderBy>;
};

/** select columns of table "public_dbt.autoalex_claim_and_stake" */
export enum PublicDbtAutoalexClaimAndStakeSelectColumn {
  /** column name */
  ApowerAmount = 'apower_amount',
  /** column name */
  ApowerAmountFixed = 'apower_amount_fixed',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  CycleIndex = 'cycle_index',
  /** column name */
  IsSuccess = 'is_success'
}

/** aggregate stddev on columns */
export type PublicDbtAutoalexClaimAndStakeStddevFields = {
  __typename?: 'public_dbt_autoalex_claim_and_stake_stddev_fields';
  apower_amount?: Maybe<Scalars['Float']>;
  apower_amount_fixed?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  cycle_index?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type PublicDbtAutoalexClaimAndStakeStddevPopFields = {
  __typename?: 'public_dbt_autoalex_claim_and_stake_stddev_pop_fields';
  apower_amount?: Maybe<Scalars['Float']>;
  apower_amount_fixed?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  cycle_index?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type PublicDbtAutoalexClaimAndStakeStddevSampFields = {
  __typename?: 'public_dbt_autoalex_claim_and_stake_stddev_samp_fields';
  apower_amount?: Maybe<Scalars['Float']>;
  apower_amount_fixed?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  cycle_index?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "public_dbt_autoalex_claim_and_stake" */
export type PublicDbtAutoalexClaimAndStakeStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: PublicDbtAutoalexClaimAndStakeStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PublicDbtAutoalexClaimAndStakeStreamCursorValueInput = {
  apower_amount?: InputMaybe<Scalars['float8']>;
  apower_amount_fixed?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['Int']>;
  cycle_index?: InputMaybe<Scalars['Int']>;
  is_success?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate sum on columns */
export type PublicDbtAutoalexClaimAndStakeSumFields = {
  __typename?: 'public_dbt_autoalex_claim_and_stake_sum_fields';
  apower_amount?: Maybe<Scalars['float8']>;
  apower_amount_fixed?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['Int']>;
  cycle_index?: Maybe<Scalars['Int']>;
};

/** aggregate var_pop on columns */
export type PublicDbtAutoalexClaimAndStakeVarPopFields = {
  __typename?: 'public_dbt_autoalex_claim_and_stake_var_pop_fields';
  apower_amount?: Maybe<Scalars['Float']>;
  apower_amount_fixed?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  cycle_index?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type PublicDbtAutoalexClaimAndStakeVarSampFields = {
  __typename?: 'public_dbt_autoalex_claim_and_stake_var_samp_fields';
  apower_amount?: Maybe<Scalars['Float']>;
  apower_amount_fixed?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  cycle_index?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type PublicDbtAutoalexClaimAndStakeVarianceFields = {
  __typename?: 'public_dbt_autoalex_claim_and_stake_variance_fields';
  apower_amount?: Maybe<Scalars['Float']>;
  apower_amount_fixed?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  cycle_index?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "public_dbt.autoalex_lockdrop_snapshot_config" */
export type PublicDbtAutoalexLockdropSnapshotConfig = {
  __typename?: 'public_dbt_autoalex_lockdrop_snapshot_config';
  block_height?: Maybe<Scalars['Int']>;
  gt2k5?: Maybe<Scalars['Int']>;
  gt5k?: Maybe<Scalars['float8']>;
  gt10k?: Maybe<Scalars['float8']>;
  gt50k?: Maybe<Scalars['Int']>;
  gt500?: Maybe<Scalars['float8']>;
  gt600?: Maybe<Scalars['float8']>;
  gt850?: Maybe<Scalars['float8']>;
  rank?: Maybe<Scalars['Int']>;
};

/** aggregated selection of "public_dbt.autoalex_lockdrop_snapshot_config" */
export type PublicDbtAutoalexLockdropSnapshotConfigAggregate = {
  __typename?: 'public_dbt_autoalex_lockdrop_snapshot_config_aggregate';
  aggregate?: Maybe<PublicDbtAutoalexLockdropSnapshotConfigAggregateFields>;
  nodes: Array<PublicDbtAutoalexLockdropSnapshotConfig>;
};

/** aggregate fields of "public_dbt.autoalex_lockdrop_snapshot_config" */
export type PublicDbtAutoalexLockdropSnapshotConfigAggregateFields = {
  __typename?: 'public_dbt_autoalex_lockdrop_snapshot_config_aggregate_fields';
  avg?: Maybe<PublicDbtAutoalexLockdropSnapshotConfigAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<PublicDbtAutoalexLockdropSnapshotConfigMaxFields>;
  min?: Maybe<PublicDbtAutoalexLockdropSnapshotConfigMinFields>;
  stddev?: Maybe<PublicDbtAutoalexLockdropSnapshotConfigStddevFields>;
  stddev_pop?: Maybe<PublicDbtAutoalexLockdropSnapshotConfigStddevPopFields>;
  stddev_samp?: Maybe<PublicDbtAutoalexLockdropSnapshotConfigStddevSampFields>;
  sum?: Maybe<PublicDbtAutoalexLockdropSnapshotConfigSumFields>;
  var_pop?: Maybe<PublicDbtAutoalexLockdropSnapshotConfigVarPopFields>;
  var_samp?: Maybe<PublicDbtAutoalexLockdropSnapshotConfigVarSampFields>;
  variance?: Maybe<PublicDbtAutoalexLockdropSnapshotConfigVarianceFields>;
};


/** aggregate fields of "public_dbt.autoalex_lockdrop_snapshot_config" */
export type PublicDbtAutoalexLockdropSnapshotConfigAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PublicDbtAutoalexLockdropSnapshotConfigSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type PublicDbtAutoalexLockdropSnapshotConfigAvgFields = {
  __typename?: 'public_dbt_autoalex_lockdrop_snapshot_config_avg_fields';
  block_height?: Maybe<Scalars['Float']>;
  gt2k5?: Maybe<Scalars['Float']>;
  gt5k?: Maybe<Scalars['Float']>;
  gt10k?: Maybe<Scalars['Float']>;
  gt50k?: Maybe<Scalars['Float']>;
  gt500?: Maybe<Scalars['Float']>;
  gt600?: Maybe<Scalars['Float']>;
  gt850?: Maybe<Scalars['Float']>;
  rank?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "public_dbt.autoalex_lockdrop_snapshot_config". All fields are combined with a logical 'AND'. */
export type PublicDbtAutoalexLockdropSnapshotConfigBoolExp = {
  _and?: InputMaybe<Array<PublicDbtAutoalexLockdropSnapshotConfigBoolExp>>;
  _not?: InputMaybe<PublicDbtAutoalexLockdropSnapshotConfigBoolExp>;
  _or?: InputMaybe<Array<PublicDbtAutoalexLockdropSnapshotConfigBoolExp>>;
  block_height?: InputMaybe<IntComparisonExp>;
  gt2k5?: InputMaybe<IntComparisonExp>;
  gt5k?: InputMaybe<Float8ComparisonExp>;
  gt10k?: InputMaybe<Float8ComparisonExp>;
  gt50k?: InputMaybe<IntComparisonExp>;
  gt500?: InputMaybe<Float8ComparisonExp>;
  gt600?: InputMaybe<Float8ComparisonExp>;
  gt850?: InputMaybe<Float8ComparisonExp>;
  rank?: InputMaybe<IntComparisonExp>;
};

/** input type for incrementing numeric columns in table "public_dbt.autoalex_lockdrop_snapshot_config" */
export type PublicDbtAutoalexLockdropSnapshotConfigIncInput = {
  block_height?: InputMaybe<Scalars['Int']>;
  gt2k5?: InputMaybe<Scalars['Int']>;
  gt5k?: InputMaybe<Scalars['float8']>;
  gt10k?: InputMaybe<Scalars['float8']>;
  gt50k?: InputMaybe<Scalars['Int']>;
  gt500?: InputMaybe<Scalars['float8']>;
  gt600?: InputMaybe<Scalars['float8']>;
  gt850?: InputMaybe<Scalars['float8']>;
  rank?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "public_dbt.autoalex_lockdrop_snapshot_config" */
export type PublicDbtAutoalexLockdropSnapshotConfigInsertInput = {
  block_height?: InputMaybe<Scalars['Int']>;
  gt2k5?: InputMaybe<Scalars['Int']>;
  gt5k?: InputMaybe<Scalars['float8']>;
  gt10k?: InputMaybe<Scalars['float8']>;
  gt50k?: InputMaybe<Scalars['Int']>;
  gt500?: InputMaybe<Scalars['float8']>;
  gt600?: InputMaybe<Scalars['float8']>;
  gt850?: InputMaybe<Scalars['float8']>;
  rank?: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type PublicDbtAutoalexLockdropSnapshotConfigMaxFields = {
  __typename?: 'public_dbt_autoalex_lockdrop_snapshot_config_max_fields';
  block_height?: Maybe<Scalars['Int']>;
  gt2k5?: Maybe<Scalars['Int']>;
  gt5k?: Maybe<Scalars['float8']>;
  gt10k?: Maybe<Scalars['float8']>;
  gt50k?: Maybe<Scalars['Int']>;
  gt500?: Maybe<Scalars['float8']>;
  gt600?: Maybe<Scalars['float8']>;
  gt850?: Maybe<Scalars['float8']>;
  rank?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type PublicDbtAutoalexLockdropSnapshotConfigMinFields = {
  __typename?: 'public_dbt_autoalex_lockdrop_snapshot_config_min_fields';
  block_height?: Maybe<Scalars['Int']>;
  gt2k5?: Maybe<Scalars['Int']>;
  gt5k?: Maybe<Scalars['float8']>;
  gt10k?: Maybe<Scalars['float8']>;
  gt50k?: Maybe<Scalars['Int']>;
  gt500?: Maybe<Scalars['float8']>;
  gt600?: Maybe<Scalars['float8']>;
  gt850?: Maybe<Scalars['float8']>;
  rank?: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "public_dbt.autoalex_lockdrop_snapshot_config" */
export type PublicDbtAutoalexLockdropSnapshotConfigMutationResponse = {
  __typename?: 'public_dbt_autoalex_lockdrop_snapshot_config_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<PublicDbtAutoalexLockdropSnapshotConfig>;
};

/** Ordering options when selecting data from "public_dbt.autoalex_lockdrop_snapshot_config". */
export type PublicDbtAutoalexLockdropSnapshotConfigOrderBy = {
  block_height?: InputMaybe<OrderBy>;
  gt2k5?: InputMaybe<OrderBy>;
  gt5k?: InputMaybe<OrderBy>;
  gt10k?: InputMaybe<OrderBy>;
  gt50k?: InputMaybe<OrderBy>;
  gt500?: InputMaybe<OrderBy>;
  gt600?: InputMaybe<OrderBy>;
  gt850?: InputMaybe<OrderBy>;
  rank?: InputMaybe<OrderBy>;
};

/** select columns of table "public_dbt.autoalex_lockdrop_snapshot_config" */
export enum PublicDbtAutoalexLockdropSnapshotConfigSelectColumn {
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  Gt2k5 = 'gt2k5',
  /** column name */
  Gt5k = 'gt5k',
  /** column name */
  Gt10k = 'gt10k',
  /** column name */
  Gt50k = 'gt50k',
  /** column name */
  Gt500 = 'gt500',
  /** column name */
  Gt600 = 'gt600',
  /** column name */
  Gt850 = 'gt850',
  /** column name */
  Rank = 'rank'
}

/** input type for updating data in table "public_dbt.autoalex_lockdrop_snapshot_config" */
export type PublicDbtAutoalexLockdropSnapshotConfigSetInput = {
  block_height?: InputMaybe<Scalars['Int']>;
  gt2k5?: InputMaybe<Scalars['Int']>;
  gt5k?: InputMaybe<Scalars['float8']>;
  gt10k?: InputMaybe<Scalars['float8']>;
  gt50k?: InputMaybe<Scalars['Int']>;
  gt500?: InputMaybe<Scalars['float8']>;
  gt600?: InputMaybe<Scalars['float8']>;
  gt850?: InputMaybe<Scalars['float8']>;
  rank?: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type PublicDbtAutoalexLockdropSnapshotConfigStddevFields = {
  __typename?: 'public_dbt_autoalex_lockdrop_snapshot_config_stddev_fields';
  block_height?: Maybe<Scalars['Float']>;
  gt2k5?: Maybe<Scalars['Float']>;
  gt5k?: Maybe<Scalars['Float']>;
  gt10k?: Maybe<Scalars['Float']>;
  gt50k?: Maybe<Scalars['Float']>;
  gt500?: Maybe<Scalars['Float']>;
  gt600?: Maybe<Scalars['Float']>;
  gt850?: Maybe<Scalars['Float']>;
  rank?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type PublicDbtAutoalexLockdropSnapshotConfigStddevPopFields = {
  __typename?: 'public_dbt_autoalex_lockdrop_snapshot_config_stddev_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  gt2k5?: Maybe<Scalars['Float']>;
  gt5k?: Maybe<Scalars['Float']>;
  gt10k?: Maybe<Scalars['Float']>;
  gt50k?: Maybe<Scalars['Float']>;
  gt500?: Maybe<Scalars['Float']>;
  gt600?: Maybe<Scalars['Float']>;
  gt850?: Maybe<Scalars['Float']>;
  rank?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type PublicDbtAutoalexLockdropSnapshotConfigStddevSampFields = {
  __typename?: 'public_dbt_autoalex_lockdrop_snapshot_config_stddev_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  gt2k5?: Maybe<Scalars['Float']>;
  gt5k?: Maybe<Scalars['Float']>;
  gt10k?: Maybe<Scalars['Float']>;
  gt50k?: Maybe<Scalars['Float']>;
  gt500?: Maybe<Scalars['Float']>;
  gt600?: Maybe<Scalars['Float']>;
  gt850?: Maybe<Scalars['Float']>;
  rank?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "public_dbt_autoalex_lockdrop_snapshot_config" */
export type PublicDbtAutoalexLockdropSnapshotConfigStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: PublicDbtAutoalexLockdropSnapshotConfigStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PublicDbtAutoalexLockdropSnapshotConfigStreamCursorValueInput = {
  block_height?: InputMaybe<Scalars['Int']>;
  gt2k5?: InputMaybe<Scalars['Int']>;
  gt5k?: InputMaybe<Scalars['float8']>;
  gt10k?: InputMaybe<Scalars['float8']>;
  gt50k?: InputMaybe<Scalars['Int']>;
  gt500?: InputMaybe<Scalars['float8']>;
  gt600?: InputMaybe<Scalars['float8']>;
  gt850?: InputMaybe<Scalars['float8']>;
  rank?: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type PublicDbtAutoalexLockdropSnapshotConfigSumFields = {
  __typename?: 'public_dbt_autoalex_lockdrop_snapshot_config_sum_fields';
  block_height?: Maybe<Scalars['Int']>;
  gt2k5?: Maybe<Scalars['Int']>;
  gt5k?: Maybe<Scalars['float8']>;
  gt10k?: Maybe<Scalars['float8']>;
  gt50k?: Maybe<Scalars['Int']>;
  gt500?: Maybe<Scalars['float8']>;
  gt600?: Maybe<Scalars['float8']>;
  gt850?: Maybe<Scalars['float8']>;
  rank?: Maybe<Scalars['Int']>;
};

export type PublicDbtAutoalexLockdropSnapshotConfigUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<PublicDbtAutoalexLockdropSnapshotConfigIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PublicDbtAutoalexLockdropSnapshotConfigSetInput>;
  where: PublicDbtAutoalexLockdropSnapshotConfigBoolExp;
};

/** aggregate var_pop on columns */
export type PublicDbtAutoalexLockdropSnapshotConfigVarPopFields = {
  __typename?: 'public_dbt_autoalex_lockdrop_snapshot_config_var_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  gt2k5?: Maybe<Scalars['Float']>;
  gt5k?: Maybe<Scalars['Float']>;
  gt10k?: Maybe<Scalars['Float']>;
  gt50k?: Maybe<Scalars['Float']>;
  gt500?: Maybe<Scalars['Float']>;
  gt600?: Maybe<Scalars['Float']>;
  gt850?: Maybe<Scalars['Float']>;
  rank?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type PublicDbtAutoalexLockdropSnapshotConfigVarSampFields = {
  __typename?: 'public_dbt_autoalex_lockdrop_snapshot_config_var_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  gt2k5?: Maybe<Scalars['Float']>;
  gt5k?: Maybe<Scalars['Float']>;
  gt10k?: Maybe<Scalars['Float']>;
  gt50k?: Maybe<Scalars['Float']>;
  gt500?: Maybe<Scalars['Float']>;
  gt600?: Maybe<Scalars['Float']>;
  gt850?: Maybe<Scalars['Float']>;
  rank?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type PublicDbtAutoalexLockdropSnapshotConfigVarianceFields = {
  __typename?: 'public_dbt_autoalex_lockdrop_snapshot_config_variance_fields';
  block_height?: Maybe<Scalars['Float']>;
  gt2k5?: Maybe<Scalars['Float']>;
  gt5k?: Maybe<Scalars['Float']>;
  gt10k?: Maybe<Scalars['Float']>;
  gt50k?: Maybe<Scalars['Float']>;
  gt500?: Maybe<Scalars['Float']>;
  gt600?: Maybe<Scalars['Float']>;
  gt850?: Maybe<Scalars['Float']>;
  rank?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "public_dbt.autoalex_snapshot_config" */
export type PublicDbtAutoalexSnapshotConfig = {
  __typename?: 'public_dbt_autoalex_snapshot_config';
  block_height?: Maybe<Scalars['Int']>;
  gt650?: Maybe<Scalars['float8']>;
  gt850?: Maybe<Scalars['float8']>;
  gt1200?: Maybe<Scalars['float8']>;
  gt1800?: Maybe<Scalars['float8']>;
  gt2500?: Maybe<Scalars['float8']>;
  rank?: Maybe<Scalars['Int']>;
};

/** aggregated selection of "public_dbt.autoalex_snapshot_config" */
export type PublicDbtAutoalexSnapshotConfigAggregate = {
  __typename?: 'public_dbt_autoalex_snapshot_config_aggregate';
  aggregate?: Maybe<PublicDbtAutoalexSnapshotConfigAggregateFields>;
  nodes: Array<PublicDbtAutoalexSnapshotConfig>;
};

/** aggregate fields of "public_dbt.autoalex_snapshot_config" */
export type PublicDbtAutoalexSnapshotConfigAggregateFields = {
  __typename?: 'public_dbt_autoalex_snapshot_config_aggregate_fields';
  avg?: Maybe<PublicDbtAutoalexSnapshotConfigAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<PublicDbtAutoalexSnapshotConfigMaxFields>;
  min?: Maybe<PublicDbtAutoalexSnapshotConfigMinFields>;
  stddev?: Maybe<PublicDbtAutoalexSnapshotConfigStddevFields>;
  stddev_pop?: Maybe<PublicDbtAutoalexSnapshotConfigStddevPopFields>;
  stddev_samp?: Maybe<PublicDbtAutoalexSnapshotConfigStddevSampFields>;
  sum?: Maybe<PublicDbtAutoalexSnapshotConfigSumFields>;
  var_pop?: Maybe<PublicDbtAutoalexSnapshotConfigVarPopFields>;
  var_samp?: Maybe<PublicDbtAutoalexSnapshotConfigVarSampFields>;
  variance?: Maybe<PublicDbtAutoalexSnapshotConfigVarianceFields>;
};


/** aggregate fields of "public_dbt.autoalex_snapshot_config" */
export type PublicDbtAutoalexSnapshotConfigAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PublicDbtAutoalexSnapshotConfigSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type PublicDbtAutoalexSnapshotConfigAvgFields = {
  __typename?: 'public_dbt_autoalex_snapshot_config_avg_fields';
  block_height?: Maybe<Scalars['Float']>;
  gt650?: Maybe<Scalars['Float']>;
  gt850?: Maybe<Scalars['Float']>;
  gt1200?: Maybe<Scalars['Float']>;
  gt1800?: Maybe<Scalars['Float']>;
  gt2500?: Maybe<Scalars['Float']>;
  rank?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "public_dbt.autoalex_snapshot_config". All fields are combined with a logical 'AND'. */
export type PublicDbtAutoalexSnapshotConfigBoolExp = {
  _and?: InputMaybe<Array<PublicDbtAutoalexSnapshotConfigBoolExp>>;
  _not?: InputMaybe<PublicDbtAutoalexSnapshotConfigBoolExp>;
  _or?: InputMaybe<Array<PublicDbtAutoalexSnapshotConfigBoolExp>>;
  block_height?: InputMaybe<IntComparisonExp>;
  gt650?: InputMaybe<Float8ComparisonExp>;
  gt850?: InputMaybe<Float8ComparisonExp>;
  gt1200?: InputMaybe<Float8ComparisonExp>;
  gt1800?: InputMaybe<Float8ComparisonExp>;
  gt2500?: InputMaybe<Float8ComparisonExp>;
  rank?: InputMaybe<IntComparisonExp>;
};

/** input type for incrementing numeric columns in table "public_dbt.autoalex_snapshot_config" */
export type PublicDbtAutoalexSnapshotConfigIncInput = {
  block_height?: InputMaybe<Scalars['Int']>;
  gt650?: InputMaybe<Scalars['float8']>;
  gt850?: InputMaybe<Scalars['float8']>;
  gt1200?: InputMaybe<Scalars['float8']>;
  gt1800?: InputMaybe<Scalars['float8']>;
  gt2500?: InputMaybe<Scalars['float8']>;
  rank?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "public_dbt.autoalex_snapshot_config" */
export type PublicDbtAutoalexSnapshotConfigInsertInput = {
  block_height?: InputMaybe<Scalars['Int']>;
  gt650?: InputMaybe<Scalars['float8']>;
  gt850?: InputMaybe<Scalars['float8']>;
  gt1200?: InputMaybe<Scalars['float8']>;
  gt1800?: InputMaybe<Scalars['float8']>;
  gt2500?: InputMaybe<Scalars['float8']>;
  rank?: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type PublicDbtAutoalexSnapshotConfigMaxFields = {
  __typename?: 'public_dbt_autoalex_snapshot_config_max_fields';
  block_height?: Maybe<Scalars['Int']>;
  gt650?: Maybe<Scalars['float8']>;
  gt850?: Maybe<Scalars['float8']>;
  gt1200?: Maybe<Scalars['float8']>;
  gt1800?: Maybe<Scalars['float8']>;
  gt2500?: Maybe<Scalars['float8']>;
  rank?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type PublicDbtAutoalexSnapshotConfigMinFields = {
  __typename?: 'public_dbt_autoalex_snapshot_config_min_fields';
  block_height?: Maybe<Scalars['Int']>;
  gt650?: Maybe<Scalars['float8']>;
  gt850?: Maybe<Scalars['float8']>;
  gt1200?: Maybe<Scalars['float8']>;
  gt1800?: Maybe<Scalars['float8']>;
  gt2500?: Maybe<Scalars['float8']>;
  rank?: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "public_dbt.autoalex_snapshot_config" */
export type PublicDbtAutoalexSnapshotConfigMutationResponse = {
  __typename?: 'public_dbt_autoalex_snapshot_config_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<PublicDbtAutoalexSnapshotConfig>;
};

/** Ordering options when selecting data from "public_dbt.autoalex_snapshot_config". */
export type PublicDbtAutoalexSnapshotConfigOrderBy = {
  block_height?: InputMaybe<OrderBy>;
  gt650?: InputMaybe<OrderBy>;
  gt850?: InputMaybe<OrderBy>;
  gt1200?: InputMaybe<OrderBy>;
  gt1800?: InputMaybe<OrderBy>;
  gt2500?: InputMaybe<OrderBy>;
  rank?: InputMaybe<OrderBy>;
};

/** select columns of table "public_dbt.autoalex_snapshot_config" */
export enum PublicDbtAutoalexSnapshotConfigSelectColumn {
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  Gt650 = 'gt650',
  /** column name */
  Gt850 = 'gt850',
  /** column name */
  Gt1200 = 'gt1200',
  /** column name */
  Gt1800 = 'gt1800',
  /** column name */
  Gt2500 = 'gt2500',
  /** column name */
  Rank = 'rank'
}

/** input type for updating data in table "public_dbt.autoalex_snapshot_config" */
export type PublicDbtAutoalexSnapshotConfigSetInput = {
  block_height?: InputMaybe<Scalars['Int']>;
  gt650?: InputMaybe<Scalars['float8']>;
  gt850?: InputMaybe<Scalars['float8']>;
  gt1200?: InputMaybe<Scalars['float8']>;
  gt1800?: InputMaybe<Scalars['float8']>;
  gt2500?: InputMaybe<Scalars['float8']>;
  rank?: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type PublicDbtAutoalexSnapshotConfigStddevFields = {
  __typename?: 'public_dbt_autoalex_snapshot_config_stddev_fields';
  block_height?: Maybe<Scalars['Float']>;
  gt650?: Maybe<Scalars['Float']>;
  gt850?: Maybe<Scalars['Float']>;
  gt1200?: Maybe<Scalars['Float']>;
  gt1800?: Maybe<Scalars['Float']>;
  gt2500?: Maybe<Scalars['Float']>;
  rank?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type PublicDbtAutoalexSnapshotConfigStddevPopFields = {
  __typename?: 'public_dbt_autoalex_snapshot_config_stddev_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  gt650?: Maybe<Scalars['Float']>;
  gt850?: Maybe<Scalars['Float']>;
  gt1200?: Maybe<Scalars['Float']>;
  gt1800?: Maybe<Scalars['Float']>;
  gt2500?: Maybe<Scalars['Float']>;
  rank?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type PublicDbtAutoalexSnapshotConfigStddevSampFields = {
  __typename?: 'public_dbt_autoalex_snapshot_config_stddev_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  gt650?: Maybe<Scalars['Float']>;
  gt850?: Maybe<Scalars['Float']>;
  gt1200?: Maybe<Scalars['Float']>;
  gt1800?: Maybe<Scalars['Float']>;
  gt2500?: Maybe<Scalars['Float']>;
  rank?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "public_dbt_autoalex_snapshot_config" */
export type PublicDbtAutoalexSnapshotConfigStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: PublicDbtAutoalexSnapshotConfigStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PublicDbtAutoalexSnapshotConfigStreamCursorValueInput = {
  block_height?: InputMaybe<Scalars['Int']>;
  gt650?: InputMaybe<Scalars['float8']>;
  gt850?: InputMaybe<Scalars['float8']>;
  gt1200?: InputMaybe<Scalars['float8']>;
  gt1800?: InputMaybe<Scalars['float8']>;
  gt2500?: InputMaybe<Scalars['float8']>;
  rank?: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type PublicDbtAutoalexSnapshotConfigSumFields = {
  __typename?: 'public_dbt_autoalex_snapshot_config_sum_fields';
  block_height?: Maybe<Scalars['Int']>;
  gt650?: Maybe<Scalars['float8']>;
  gt850?: Maybe<Scalars['float8']>;
  gt1200?: Maybe<Scalars['float8']>;
  gt1800?: Maybe<Scalars['float8']>;
  gt2500?: Maybe<Scalars['float8']>;
  rank?: Maybe<Scalars['Int']>;
};

export type PublicDbtAutoalexSnapshotConfigUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<PublicDbtAutoalexSnapshotConfigIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PublicDbtAutoalexSnapshotConfigSetInput>;
  where: PublicDbtAutoalexSnapshotConfigBoolExp;
};

/** aggregate var_pop on columns */
export type PublicDbtAutoalexSnapshotConfigVarPopFields = {
  __typename?: 'public_dbt_autoalex_snapshot_config_var_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  gt650?: Maybe<Scalars['Float']>;
  gt850?: Maybe<Scalars['Float']>;
  gt1200?: Maybe<Scalars['Float']>;
  gt1800?: Maybe<Scalars['Float']>;
  gt2500?: Maybe<Scalars['Float']>;
  rank?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type PublicDbtAutoalexSnapshotConfigVarSampFields = {
  __typename?: 'public_dbt_autoalex_snapshot_config_var_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  gt650?: Maybe<Scalars['Float']>;
  gt850?: Maybe<Scalars['Float']>;
  gt1200?: Maybe<Scalars['Float']>;
  gt1800?: Maybe<Scalars['Float']>;
  gt2500?: Maybe<Scalars['Float']>;
  rank?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type PublicDbtAutoalexSnapshotConfigVarianceFields = {
  __typename?: 'public_dbt_autoalex_snapshot_config_variance_fields';
  block_height?: Maybe<Scalars['Float']>;
  gt650?: Maybe<Scalars['Float']>;
  gt850?: Maybe<Scalars['Float']>;
  gt1200?: Maybe<Scalars['Float']>;
  gt1800?: Maybe<Scalars['Float']>;
  gt2500?: Maybe<Scalars['Float']>;
  rank?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "public_dbt.dim_autoalex_apower_cycle_reward_status" */
export type PublicDbtDimAutoalexApowerCycleRewardStatus = {
  __typename?: 'public_dbt_dim_autoalex_apower_cycle_reward_status';
  cycle?: Maybe<Scalars['Int']>;
  is_cycle_rewards_sent?: Maybe<Scalars['Boolean']>;
  total_recipients_count?: Maybe<Scalars['bigint']>;
  total_sent_batchs?: Maybe<Scalars['bigint']>;
  total_sent_recipients_count?: Maybe<Scalars['bigint']>;
};

/** aggregated selection of "public_dbt.dim_autoalex_apower_cycle_reward_status" */
export type PublicDbtDimAutoalexApowerCycleRewardStatusAggregate = {
  __typename?: 'public_dbt_dim_autoalex_apower_cycle_reward_status_aggregate';
  aggregate?: Maybe<PublicDbtDimAutoalexApowerCycleRewardStatusAggregateFields>;
  nodes: Array<PublicDbtDimAutoalexApowerCycleRewardStatus>;
};

/** aggregate fields of "public_dbt.dim_autoalex_apower_cycle_reward_status" */
export type PublicDbtDimAutoalexApowerCycleRewardStatusAggregateFields = {
  __typename?: 'public_dbt_dim_autoalex_apower_cycle_reward_status_aggregate_fields';
  avg?: Maybe<PublicDbtDimAutoalexApowerCycleRewardStatusAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<PublicDbtDimAutoalexApowerCycleRewardStatusMaxFields>;
  min?: Maybe<PublicDbtDimAutoalexApowerCycleRewardStatusMinFields>;
  stddev?: Maybe<PublicDbtDimAutoalexApowerCycleRewardStatusStddevFields>;
  stddev_pop?: Maybe<PublicDbtDimAutoalexApowerCycleRewardStatusStddevPopFields>;
  stddev_samp?: Maybe<PublicDbtDimAutoalexApowerCycleRewardStatusStddevSampFields>;
  sum?: Maybe<PublicDbtDimAutoalexApowerCycleRewardStatusSumFields>;
  var_pop?: Maybe<PublicDbtDimAutoalexApowerCycleRewardStatusVarPopFields>;
  var_samp?: Maybe<PublicDbtDimAutoalexApowerCycleRewardStatusVarSampFields>;
  variance?: Maybe<PublicDbtDimAutoalexApowerCycleRewardStatusVarianceFields>;
};


/** aggregate fields of "public_dbt.dim_autoalex_apower_cycle_reward_status" */
export type PublicDbtDimAutoalexApowerCycleRewardStatusAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PublicDbtDimAutoalexApowerCycleRewardStatusSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type PublicDbtDimAutoalexApowerCycleRewardStatusAvgFields = {
  __typename?: 'public_dbt_dim_autoalex_apower_cycle_reward_status_avg_fields';
  cycle?: Maybe<Scalars['Float']>;
  total_recipients_count?: Maybe<Scalars['Float']>;
  total_sent_batchs?: Maybe<Scalars['Float']>;
  total_sent_recipients_count?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "public_dbt.dim_autoalex_apower_cycle_reward_status". All fields are combined with a logical 'AND'. */
export type PublicDbtDimAutoalexApowerCycleRewardStatusBoolExp = {
  _and?: InputMaybe<Array<PublicDbtDimAutoalexApowerCycleRewardStatusBoolExp>>;
  _not?: InputMaybe<PublicDbtDimAutoalexApowerCycleRewardStatusBoolExp>;
  _or?: InputMaybe<Array<PublicDbtDimAutoalexApowerCycleRewardStatusBoolExp>>;
  cycle?: InputMaybe<IntComparisonExp>;
  is_cycle_rewards_sent?: InputMaybe<BooleanComparisonExp>;
  total_recipients_count?: InputMaybe<BigintComparisonExp>;
  total_sent_batchs?: InputMaybe<BigintComparisonExp>;
  total_sent_recipients_count?: InputMaybe<BigintComparisonExp>;
};

/** aggregate max on columns */
export type PublicDbtDimAutoalexApowerCycleRewardStatusMaxFields = {
  __typename?: 'public_dbt_dim_autoalex_apower_cycle_reward_status_max_fields';
  cycle?: Maybe<Scalars['Int']>;
  total_recipients_count?: Maybe<Scalars['bigint']>;
  total_sent_batchs?: Maybe<Scalars['bigint']>;
  total_sent_recipients_count?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type PublicDbtDimAutoalexApowerCycleRewardStatusMinFields = {
  __typename?: 'public_dbt_dim_autoalex_apower_cycle_reward_status_min_fields';
  cycle?: Maybe<Scalars['Int']>;
  total_recipients_count?: Maybe<Scalars['bigint']>;
  total_sent_batchs?: Maybe<Scalars['bigint']>;
  total_sent_recipients_count?: Maybe<Scalars['bigint']>;
};

/** Ordering options when selecting data from "public_dbt.dim_autoalex_apower_cycle_reward_status". */
export type PublicDbtDimAutoalexApowerCycleRewardStatusOrderBy = {
  cycle?: InputMaybe<OrderBy>;
  is_cycle_rewards_sent?: InputMaybe<OrderBy>;
  total_recipients_count?: InputMaybe<OrderBy>;
  total_sent_batchs?: InputMaybe<OrderBy>;
  total_sent_recipients_count?: InputMaybe<OrderBy>;
};

/** select columns of table "public_dbt.dim_autoalex_apower_cycle_reward_status" */
export enum PublicDbtDimAutoalexApowerCycleRewardStatusSelectColumn {
  /** column name */
  Cycle = 'cycle',
  /** column name */
  IsCycleRewardsSent = 'is_cycle_rewards_sent',
  /** column name */
  TotalRecipientsCount = 'total_recipients_count',
  /** column name */
  TotalSentBatchs = 'total_sent_batchs',
  /** column name */
  TotalSentRecipientsCount = 'total_sent_recipients_count'
}

/** aggregate stddev on columns */
export type PublicDbtDimAutoalexApowerCycleRewardStatusStddevFields = {
  __typename?: 'public_dbt_dim_autoalex_apower_cycle_reward_status_stddev_fields';
  cycle?: Maybe<Scalars['Float']>;
  total_recipients_count?: Maybe<Scalars['Float']>;
  total_sent_batchs?: Maybe<Scalars['Float']>;
  total_sent_recipients_count?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type PublicDbtDimAutoalexApowerCycleRewardStatusStddevPopFields = {
  __typename?: 'public_dbt_dim_autoalex_apower_cycle_reward_status_stddev_pop_fields';
  cycle?: Maybe<Scalars['Float']>;
  total_recipients_count?: Maybe<Scalars['Float']>;
  total_sent_batchs?: Maybe<Scalars['Float']>;
  total_sent_recipients_count?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type PublicDbtDimAutoalexApowerCycleRewardStatusStddevSampFields = {
  __typename?: 'public_dbt_dim_autoalex_apower_cycle_reward_status_stddev_samp_fields';
  cycle?: Maybe<Scalars['Float']>;
  total_recipients_count?: Maybe<Scalars['Float']>;
  total_sent_batchs?: Maybe<Scalars['Float']>;
  total_sent_recipients_count?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "public_dbt_dim_autoalex_apower_cycle_reward_status" */
export type PublicDbtDimAutoalexApowerCycleRewardStatusStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: PublicDbtDimAutoalexApowerCycleRewardStatusStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PublicDbtDimAutoalexApowerCycleRewardStatusStreamCursorValueInput = {
  cycle?: InputMaybe<Scalars['Int']>;
  is_cycle_rewards_sent?: InputMaybe<Scalars['Boolean']>;
  total_recipients_count?: InputMaybe<Scalars['bigint']>;
  total_sent_batchs?: InputMaybe<Scalars['bigint']>;
  total_sent_recipients_count?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type PublicDbtDimAutoalexApowerCycleRewardStatusSumFields = {
  __typename?: 'public_dbt_dim_autoalex_apower_cycle_reward_status_sum_fields';
  cycle?: Maybe<Scalars['Int']>;
  total_recipients_count?: Maybe<Scalars['bigint']>;
  total_sent_batchs?: Maybe<Scalars['bigint']>;
  total_sent_recipients_count?: Maybe<Scalars['bigint']>;
};

/** aggregate var_pop on columns */
export type PublicDbtDimAutoalexApowerCycleRewardStatusVarPopFields = {
  __typename?: 'public_dbt_dim_autoalex_apower_cycle_reward_status_var_pop_fields';
  cycle?: Maybe<Scalars['Float']>;
  total_recipients_count?: Maybe<Scalars['Float']>;
  total_sent_batchs?: Maybe<Scalars['Float']>;
  total_sent_recipients_count?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type PublicDbtDimAutoalexApowerCycleRewardStatusVarSampFields = {
  __typename?: 'public_dbt_dim_autoalex_apower_cycle_reward_status_var_samp_fields';
  cycle?: Maybe<Scalars['Float']>;
  total_recipients_count?: Maybe<Scalars['Float']>;
  total_sent_batchs?: Maybe<Scalars['Float']>;
  total_sent_recipients_count?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type PublicDbtDimAutoalexApowerCycleRewardStatusVarianceFields = {
  __typename?: 'public_dbt_dim_autoalex_apower_cycle_reward_status_variance_fields';
  cycle?: Maybe<Scalars['Float']>;
  total_recipients_count?: Maybe<Scalars['Float']>;
  total_sent_batchs?: Maybe<Scalars['Float']>;
  total_sent_recipients_count?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "public_dbt.dim_balance_alex_staked_lockdrop_offets" */
export type PublicDbtDimBalanceAlexStakedLockdropOffets = {
  __typename?: 'public_dbt_dim_balance_alex_staked_lockdrop_offets';
  address?: Maybe<Scalars['String']>;
  block_height?: Maybe<Scalars['Int']>;
  staked_alex_amount?: Maybe<Scalars['float8']>;
};

/** aggregated selection of "public_dbt.dim_balance_alex_staked_lockdrop_offets" */
export type PublicDbtDimBalanceAlexStakedLockdropOffetsAggregate = {
  __typename?: 'public_dbt_dim_balance_alex_staked_lockdrop_offets_aggregate';
  aggregate?: Maybe<PublicDbtDimBalanceAlexStakedLockdropOffetsAggregateFields>;
  nodes: Array<PublicDbtDimBalanceAlexStakedLockdropOffets>;
};

/** aggregate fields of "public_dbt.dim_balance_alex_staked_lockdrop_offets" */
export type PublicDbtDimBalanceAlexStakedLockdropOffetsAggregateFields = {
  __typename?: 'public_dbt_dim_balance_alex_staked_lockdrop_offets_aggregate_fields';
  avg?: Maybe<PublicDbtDimBalanceAlexStakedLockdropOffetsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<PublicDbtDimBalanceAlexStakedLockdropOffetsMaxFields>;
  min?: Maybe<PublicDbtDimBalanceAlexStakedLockdropOffetsMinFields>;
  stddev?: Maybe<PublicDbtDimBalanceAlexStakedLockdropOffetsStddevFields>;
  stddev_pop?: Maybe<PublicDbtDimBalanceAlexStakedLockdropOffetsStddevPopFields>;
  stddev_samp?: Maybe<PublicDbtDimBalanceAlexStakedLockdropOffetsStddevSampFields>;
  sum?: Maybe<PublicDbtDimBalanceAlexStakedLockdropOffetsSumFields>;
  var_pop?: Maybe<PublicDbtDimBalanceAlexStakedLockdropOffetsVarPopFields>;
  var_samp?: Maybe<PublicDbtDimBalanceAlexStakedLockdropOffetsVarSampFields>;
  variance?: Maybe<PublicDbtDimBalanceAlexStakedLockdropOffetsVarianceFields>;
};


/** aggregate fields of "public_dbt.dim_balance_alex_staked_lockdrop_offets" */
export type PublicDbtDimBalanceAlexStakedLockdropOffetsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PublicDbtDimBalanceAlexStakedLockdropOffetsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type PublicDbtDimBalanceAlexStakedLockdropOffetsAvgFields = {
  __typename?: 'public_dbt_dim_balance_alex_staked_lockdrop_offets_avg_fields';
  block_height?: Maybe<Scalars['Float']>;
  staked_alex_amount?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "public_dbt.dim_balance_alex_staked_lockdrop_offets". All fields are combined with a logical 'AND'. */
export type PublicDbtDimBalanceAlexStakedLockdropOffetsBoolExp = {
  _and?: InputMaybe<Array<PublicDbtDimBalanceAlexStakedLockdropOffetsBoolExp>>;
  _not?: InputMaybe<PublicDbtDimBalanceAlexStakedLockdropOffetsBoolExp>;
  _or?: InputMaybe<Array<PublicDbtDimBalanceAlexStakedLockdropOffetsBoolExp>>;
  address?: InputMaybe<StringComparisonExp>;
  block_height?: InputMaybe<IntComparisonExp>;
  staked_alex_amount?: InputMaybe<Float8ComparisonExp>;
};

/** aggregate max on columns */
export type PublicDbtDimBalanceAlexStakedLockdropOffetsMaxFields = {
  __typename?: 'public_dbt_dim_balance_alex_staked_lockdrop_offets_max_fields';
  address?: Maybe<Scalars['String']>;
  block_height?: Maybe<Scalars['Int']>;
  staked_alex_amount?: Maybe<Scalars['float8']>;
};

/** aggregate min on columns */
export type PublicDbtDimBalanceAlexStakedLockdropOffetsMinFields = {
  __typename?: 'public_dbt_dim_balance_alex_staked_lockdrop_offets_min_fields';
  address?: Maybe<Scalars['String']>;
  block_height?: Maybe<Scalars['Int']>;
  staked_alex_amount?: Maybe<Scalars['float8']>;
};

/** Ordering options when selecting data from "public_dbt.dim_balance_alex_staked_lockdrop_offets". */
export type PublicDbtDimBalanceAlexStakedLockdropOffetsOrderBy = {
  address?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  staked_alex_amount?: InputMaybe<OrderBy>;
};

/** select columns of table "public_dbt.dim_balance_alex_staked_lockdrop_offets" */
export enum PublicDbtDimBalanceAlexStakedLockdropOffetsSelectColumn {
  /** column name */
  Address = 'address',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  StakedAlexAmount = 'staked_alex_amount'
}

/** aggregate stddev on columns */
export type PublicDbtDimBalanceAlexStakedLockdropOffetsStddevFields = {
  __typename?: 'public_dbt_dim_balance_alex_staked_lockdrop_offets_stddev_fields';
  block_height?: Maybe<Scalars['Float']>;
  staked_alex_amount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type PublicDbtDimBalanceAlexStakedLockdropOffetsStddevPopFields = {
  __typename?: 'public_dbt_dim_balance_alex_staked_lockdrop_offets_stddev_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  staked_alex_amount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type PublicDbtDimBalanceAlexStakedLockdropOffetsStddevSampFields = {
  __typename?: 'public_dbt_dim_balance_alex_staked_lockdrop_offets_stddev_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  staked_alex_amount?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "public_dbt_dim_balance_alex_staked_lockdrop_offets" */
export type PublicDbtDimBalanceAlexStakedLockdropOffetsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: PublicDbtDimBalanceAlexStakedLockdropOffetsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PublicDbtDimBalanceAlexStakedLockdropOffetsStreamCursorValueInput = {
  address?: InputMaybe<Scalars['String']>;
  block_height?: InputMaybe<Scalars['Int']>;
  staked_alex_amount?: InputMaybe<Scalars['float8']>;
};

/** aggregate sum on columns */
export type PublicDbtDimBalanceAlexStakedLockdropOffetsSumFields = {
  __typename?: 'public_dbt_dim_balance_alex_staked_lockdrop_offets_sum_fields';
  block_height?: Maybe<Scalars['Int']>;
  staked_alex_amount?: Maybe<Scalars['float8']>;
};

/** aggregate var_pop on columns */
export type PublicDbtDimBalanceAlexStakedLockdropOffetsVarPopFields = {
  __typename?: 'public_dbt_dim_balance_alex_staked_lockdrop_offets_var_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  staked_alex_amount?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type PublicDbtDimBalanceAlexStakedLockdropOffetsVarSampFields = {
  __typename?: 'public_dbt_dim_balance_alex_staked_lockdrop_offets_var_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  staked_alex_amount?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type PublicDbtDimBalanceAlexStakedLockdropOffetsVarianceFields = {
  __typename?: 'public_dbt_dim_balance_alex_staked_lockdrop_offets_variance_fields';
  block_height?: Maybe<Scalars['Float']>;
  staked_alex_amount?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "public_dbt.dim_balance_autoalex_apower_distribution" */
export type PublicDbtDimBalanceAutoalexApowerDistribution = {
  __typename?: 'public_dbt_dim_balance_autoalex_apower_distribution';
  address?: Maybe<Scalars['String']>;
  apower_distribution?: Maybe<Scalars['numeric']>;
  autoalex_weight?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['Int']>;
  changed_block_height?: Maybe<Scalars['Int']>;
  cycle_index?: Maybe<Scalars['Int']>;
  total_autoalex_balance?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "public_dbt.dim_balance_autoalex_apower_distribution" */
export type PublicDbtDimBalanceAutoalexApowerDistributionAggregate = {
  __typename?: 'public_dbt_dim_balance_autoalex_apower_distribution_aggregate';
  aggregate?: Maybe<PublicDbtDimBalanceAutoalexApowerDistributionAggregateFields>;
  nodes: Array<PublicDbtDimBalanceAutoalexApowerDistribution>;
};

/** aggregate fields of "public_dbt.dim_balance_autoalex_apower_distribution" */
export type PublicDbtDimBalanceAutoalexApowerDistributionAggregateFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_apower_distribution_aggregate_fields';
  avg?: Maybe<PublicDbtDimBalanceAutoalexApowerDistributionAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<PublicDbtDimBalanceAutoalexApowerDistributionMaxFields>;
  min?: Maybe<PublicDbtDimBalanceAutoalexApowerDistributionMinFields>;
  stddev?: Maybe<PublicDbtDimBalanceAutoalexApowerDistributionStddevFields>;
  stddev_pop?: Maybe<PublicDbtDimBalanceAutoalexApowerDistributionStddevPopFields>;
  stddev_samp?: Maybe<PublicDbtDimBalanceAutoalexApowerDistributionStddevSampFields>;
  sum?: Maybe<PublicDbtDimBalanceAutoalexApowerDistributionSumFields>;
  var_pop?: Maybe<PublicDbtDimBalanceAutoalexApowerDistributionVarPopFields>;
  var_samp?: Maybe<PublicDbtDimBalanceAutoalexApowerDistributionVarSampFields>;
  variance?: Maybe<PublicDbtDimBalanceAutoalexApowerDistributionVarianceFields>;
};


/** aggregate fields of "public_dbt.dim_balance_autoalex_apower_distribution" */
export type PublicDbtDimBalanceAutoalexApowerDistributionAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PublicDbtDimBalanceAutoalexApowerDistributionSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type PublicDbtDimBalanceAutoalexApowerDistributionAvgFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_apower_distribution_avg_fields';
  apower_distribution?: Maybe<Scalars['Float']>;
  autoalex_weight?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  changed_block_height?: Maybe<Scalars['Float']>;
  cycle_index?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "public_dbt.dim_balance_autoalex_apower_distribution". All fields are combined with a logical 'AND'. */
export type PublicDbtDimBalanceAutoalexApowerDistributionBoolExp = {
  _and?: InputMaybe<Array<PublicDbtDimBalanceAutoalexApowerDistributionBoolExp>>;
  _not?: InputMaybe<PublicDbtDimBalanceAutoalexApowerDistributionBoolExp>;
  _or?: InputMaybe<Array<PublicDbtDimBalanceAutoalexApowerDistributionBoolExp>>;
  address?: InputMaybe<StringComparisonExp>;
  apower_distribution?: InputMaybe<NumericComparisonExp>;
  autoalex_weight?: InputMaybe<NumericComparisonExp>;
  block_height?: InputMaybe<IntComparisonExp>;
  changed_block_height?: InputMaybe<IntComparisonExp>;
  cycle_index?: InputMaybe<IntComparisonExp>;
  total_autoalex_balance?: InputMaybe<NumericComparisonExp>;
};

/** aggregate max on columns */
export type PublicDbtDimBalanceAutoalexApowerDistributionMaxFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_apower_distribution_max_fields';
  address?: Maybe<Scalars['String']>;
  apower_distribution?: Maybe<Scalars['numeric']>;
  autoalex_weight?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['Int']>;
  changed_block_height?: Maybe<Scalars['Int']>;
  cycle_index?: Maybe<Scalars['Int']>;
  total_autoalex_balance?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type PublicDbtDimBalanceAutoalexApowerDistributionMinFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_apower_distribution_min_fields';
  address?: Maybe<Scalars['String']>;
  apower_distribution?: Maybe<Scalars['numeric']>;
  autoalex_weight?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['Int']>;
  changed_block_height?: Maybe<Scalars['Int']>;
  cycle_index?: Maybe<Scalars['Int']>;
  total_autoalex_balance?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "public_dbt.dim_balance_autoalex_apower_distribution". */
export type PublicDbtDimBalanceAutoalexApowerDistributionOrderBy = {
  address?: InputMaybe<OrderBy>;
  apower_distribution?: InputMaybe<OrderBy>;
  autoalex_weight?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  changed_block_height?: InputMaybe<OrderBy>;
  cycle_index?: InputMaybe<OrderBy>;
  total_autoalex_balance?: InputMaybe<OrderBy>;
};

/** select columns of table "public_dbt.dim_balance_autoalex_apower_distribution" */
export enum PublicDbtDimBalanceAutoalexApowerDistributionSelectColumn {
  /** column name */
  Address = 'address',
  /** column name */
  ApowerDistribution = 'apower_distribution',
  /** column name */
  AutoalexWeight = 'autoalex_weight',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  ChangedBlockHeight = 'changed_block_height',
  /** column name */
  CycleIndex = 'cycle_index',
  /** column name */
  TotalAutoalexBalance = 'total_autoalex_balance'
}

/** aggregate stddev on columns */
export type PublicDbtDimBalanceAutoalexApowerDistributionStddevFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_apower_distribution_stddev_fields';
  apower_distribution?: Maybe<Scalars['Float']>;
  autoalex_weight?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  changed_block_height?: Maybe<Scalars['Float']>;
  cycle_index?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type PublicDbtDimBalanceAutoalexApowerDistributionStddevPopFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_apower_distribution_stddev_pop_fields';
  apower_distribution?: Maybe<Scalars['Float']>;
  autoalex_weight?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  changed_block_height?: Maybe<Scalars['Float']>;
  cycle_index?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type PublicDbtDimBalanceAutoalexApowerDistributionStddevSampFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_apower_distribution_stddev_samp_fields';
  apower_distribution?: Maybe<Scalars['Float']>;
  autoalex_weight?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  changed_block_height?: Maybe<Scalars['Float']>;
  cycle_index?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "public_dbt_dim_balance_autoalex_apower_distribution" */
export type PublicDbtDimBalanceAutoalexApowerDistributionStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: PublicDbtDimBalanceAutoalexApowerDistributionStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PublicDbtDimBalanceAutoalexApowerDistributionStreamCursorValueInput = {
  address?: InputMaybe<Scalars['String']>;
  apower_distribution?: InputMaybe<Scalars['numeric']>;
  autoalex_weight?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['Int']>;
  changed_block_height?: InputMaybe<Scalars['Int']>;
  cycle_index?: InputMaybe<Scalars['Int']>;
  total_autoalex_balance?: InputMaybe<Scalars['numeric']>;
};

/** aggregate sum on columns */
export type PublicDbtDimBalanceAutoalexApowerDistributionSumFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_apower_distribution_sum_fields';
  apower_distribution?: Maybe<Scalars['numeric']>;
  autoalex_weight?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['Int']>;
  changed_block_height?: Maybe<Scalars['Int']>;
  cycle_index?: Maybe<Scalars['Int']>;
  total_autoalex_balance?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type PublicDbtDimBalanceAutoalexApowerDistributionVarPopFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_apower_distribution_var_pop_fields';
  apower_distribution?: Maybe<Scalars['Float']>;
  autoalex_weight?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  changed_block_height?: Maybe<Scalars['Float']>;
  cycle_index?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type PublicDbtDimBalanceAutoalexApowerDistributionVarSampFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_apower_distribution_var_samp_fields';
  apower_distribution?: Maybe<Scalars['Float']>;
  autoalex_weight?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  changed_block_height?: Maybe<Scalars['Float']>;
  cycle_index?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type PublicDbtDimBalanceAutoalexApowerDistributionVarianceFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_apower_distribution_variance_fields';
  apower_distribution?: Maybe<Scalars['Float']>;
  autoalex_weight?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  changed_block_height?: Maybe<Scalars['Float']>;
  cycle_index?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "public_dbt.dim_balance_autoalex_lockdrop2_rank_snapshot_view" */
export type PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotView = {
  __typename?: 'public_dbt_dim_balance_autoalex_lockdrop2_rank_snapshot_view';
  address?: Maybe<Scalars['String']>;
  balance_block_height?: Maybe<Scalars['Int']>;
  multiplier?: Maybe<Scalars['float8']>;
  snapshot_rank?: Maybe<Scalars['Int']>;
  target_block_height?: Maybe<Scalars['Int']>;
  total_autoalex_balance?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "public_dbt.dim_balance_autoalex_lockdrop2_rank_snapshot_view" */
export type PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewAggregate = {
  __typename?: 'public_dbt_dim_balance_autoalex_lockdrop2_rank_snapshot_view_aggregate';
  aggregate?: Maybe<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewAggregateFields>;
  nodes: Array<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotView>;
};

/** aggregate fields of "public_dbt.dim_balance_autoalex_lockdrop2_rank_snapshot_view" */
export type PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewAggregateFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_lockdrop2_rank_snapshot_view_aggregate_fields';
  avg?: Maybe<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewMaxFields>;
  min?: Maybe<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewMinFields>;
  stddev?: Maybe<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewStddevFields>;
  stddev_pop?: Maybe<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewStddevPopFields>;
  stddev_samp?: Maybe<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewStddevSampFields>;
  sum?: Maybe<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewSumFields>;
  var_pop?: Maybe<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewVarPopFields>;
  var_samp?: Maybe<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewVarSampFields>;
  variance?: Maybe<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewVarianceFields>;
};


/** aggregate fields of "public_dbt.dim_balance_autoalex_lockdrop2_rank_snapshot_view" */
export type PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewAvgFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_lockdrop2_rank_snapshot_view_avg_fields';
  balance_block_height?: Maybe<Scalars['Float']>;
  multiplier?: Maybe<Scalars['Float']>;
  snapshot_rank?: Maybe<Scalars['Float']>;
  target_block_height?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "public_dbt.dim_balance_autoalex_lockdrop2_rank_snapshot_view". All fields are combined with a logical 'AND'. */
export type PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewBoolExp = {
  _and?: InputMaybe<Array<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewBoolExp>>;
  _not?: InputMaybe<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewBoolExp>;
  _or?: InputMaybe<Array<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewBoolExp>>;
  address?: InputMaybe<StringComparisonExp>;
  balance_block_height?: InputMaybe<IntComparisonExp>;
  multiplier?: InputMaybe<Float8ComparisonExp>;
  snapshot_rank?: InputMaybe<IntComparisonExp>;
  target_block_height?: InputMaybe<IntComparisonExp>;
  total_autoalex_balance?: InputMaybe<NumericComparisonExp>;
};

/** aggregate max on columns */
export type PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewMaxFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_lockdrop2_rank_snapshot_view_max_fields';
  address?: Maybe<Scalars['String']>;
  balance_block_height?: Maybe<Scalars['Int']>;
  multiplier?: Maybe<Scalars['float8']>;
  snapshot_rank?: Maybe<Scalars['Int']>;
  target_block_height?: Maybe<Scalars['Int']>;
  total_autoalex_balance?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewMinFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_lockdrop2_rank_snapshot_view_min_fields';
  address?: Maybe<Scalars['String']>;
  balance_block_height?: Maybe<Scalars['Int']>;
  multiplier?: Maybe<Scalars['float8']>;
  snapshot_rank?: Maybe<Scalars['Int']>;
  target_block_height?: Maybe<Scalars['Int']>;
  total_autoalex_balance?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "public_dbt.dim_balance_autoalex_lockdrop2_rank_snapshot_view". */
export type PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewOrderBy = {
  address?: InputMaybe<OrderBy>;
  balance_block_height?: InputMaybe<OrderBy>;
  multiplier?: InputMaybe<OrderBy>;
  snapshot_rank?: InputMaybe<OrderBy>;
  target_block_height?: InputMaybe<OrderBy>;
  total_autoalex_balance?: InputMaybe<OrderBy>;
};

/** select columns of table "public_dbt.dim_balance_autoalex_lockdrop2_rank_snapshot_view" */
export enum PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewSelectColumn {
  /** column name */
  Address = 'address',
  /** column name */
  BalanceBlockHeight = 'balance_block_height',
  /** column name */
  Multiplier = 'multiplier',
  /** column name */
  SnapshotRank = 'snapshot_rank',
  /** column name */
  TargetBlockHeight = 'target_block_height',
  /** column name */
  TotalAutoalexBalance = 'total_autoalex_balance'
}

/** aggregate stddev on columns */
export type PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewStddevFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_lockdrop2_rank_snapshot_view_stddev_fields';
  balance_block_height?: Maybe<Scalars['Float']>;
  multiplier?: Maybe<Scalars['Float']>;
  snapshot_rank?: Maybe<Scalars['Float']>;
  target_block_height?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewStddevPopFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_lockdrop2_rank_snapshot_view_stddev_pop_fields';
  balance_block_height?: Maybe<Scalars['Float']>;
  multiplier?: Maybe<Scalars['Float']>;
  snapshot_rank?: Maybe<Scalars['Float']>;
  target_block_height?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewStddevSampFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_lockdrop2_rank_snapshot_view_stddev_samp_fields';
  balance_block_height?: Maybe<Scalars['Float']>;
  multiplier?: Maybe<Scalars['Float']>;
  snapshot_rank?: Maybe<Scalars['Float']>;
  target_block_height?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "public_dbt_dim_balance_autoalex_lockdrop2_rank_snapshot_view" */
export type PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewStreamCursorValueInput = {
  address?: InputMaybe<Scalars['String']>;
  balance_block_height?: InputMaybe<Scalars['Int']>;
  multiplier?: InputMaybe<Scalars['float8']>;
  snapshot_rank?: InputMaybe<Scalars['Int']>;
  target_block_height?: InputMaybe<Scalars['Int']>;
  total_autoalex_balance?: InputMaybe<Scalars['numeric']>;
};

/** aggregate sum on columns */
export type PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewSumFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_lockdrop2_rank_snapshot_view_sum_fields';
  balance_block_height?: Maybe<Scalars['Int']>;
  multiplier?: Maybe<Scalars['float8']>;
  snapshot_rank?: Maybe<Scalars['Int']>;
  target_block_height?: Maybe<Scalars['Int']>;
  total_autoalex_balance?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewVarPopFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_lockdrop2_rank_snapshot_view_var_pop_fields';
  balance_block_height?: Maybe<Scalars['Float']>;
  multiplier?: Maybe<Scalars['Float']>;
  snapshot_rank?: Maybe<Scalars['Float']>;
  target_block_height?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewVarSampFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_lockdrop2_rank_snapshot_view_var_samp_fields';
  balance_block_height?: Maybe<Scalars['Float']>;
  multiplier?: Maybe<Scalars['Float']>;
  snapshot_rank?: Maybe<Scalars['Float']>;
  target_block_height?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewVarianceFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_lockdrop2_rank_snapshot_view_variance_fields';
  balance_block_height?: Maybe<Scalars['Float']>;
  multiplier?: Maybe<Scalars['Float']>;
  snapshot_rank?: Maybe<Scalars['Float']>;
  target_block_height?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "public_dbt.dim_balance_autoalex_lockdrop2_rank_view" */
export type PublicDbtDimBalanceAutoalexLockdrop2RankView = {
  __typename?: 'public_dbt_dim_balance_autoalex_lockdrop2_rank_view';
  address?: Maybe<Scalars['String']>;
  current_multiplier?: Maybe<Scalars['float8']>;
  name?: Maybe<Scalars['String']>;
  rank_no?: Maybe<Scalars['bigint']>;
  total_autoalex_balance?: Maybe<Scalars['float8']>;
};

/** aggregated selection of "public_dbt.dim_balance_autoalex_lockdrop2_rank_view" */
export type PublicDbtDimBalanceAutoalexLockdrop2RankViewAggregate = {
  __typename?: 'public_dbt_dim_balance_autoalex_lockdrop2_rank_view_aggregate';
  aggregate?: Maybe<PublicDbtDimBalanceAutoalexLockdrop2RankViewAggregateFields>;
  nodes: Array<PublicDbtDimBalanceAutoalexLockdrop2RankView>;
};

/** aggregate fields of "public_dbt.dim_balance_autoalex_lockdrop2_rank_view" */
export type PublicDbtDimBalanceAutoalexLockdrop2RankViewAggregateFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_lockdrop2_rank_view_aggregate_fields';
  avg?: Maybe<PublicDbtDimBalanceAutoalexLockdrop2RankViewAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<PublicDbtDimBalanceAutoalexLockdrop2RankViewMaxFields>;
  min?: Maybe<PublicDbtDimBalanceAutoalexLockdrop2RankViewMinFields>;
  stddev?: Maybe<PublicDbtDimBalanceAutoalexLockdrop2RankViewStddevFields>;
  stddev_pop?: Maybe<PublicDbtDimBalanceAutoalexLockdrop2RankViewStddevPopFields>;
  stddev_samp?: Maybe<PublicDbtDimBalanceAutoalexLockdrop2RankViewStddevSampFields>;
  sum?: Maybe<PublicDbtDimBalanceAutoalexLockdrop2RankViewSumFields>;
  var_pop?: Maybe<PublicDbtDimBalanceAutoalexLockdrop2RankViewVarPopFields>;
  var_samp?: Maybe<PublicDbtDimBalanceAutoalexLockdrop2RankViewVarSampFields>;
  variance?: Maybe<PublicDbtDimBalanceAutoalexLockdrop2RankViewVarianceFields>;
};


/** aggregate fields of "public_dbt.dim_balance_autoalex_lockdrop2_rank_view" */
export type PublicDbtDimBalanceAutoalexLockdrop2RankViewAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PublicDbtDimBalanceAutoalexLockdrop2RankViewSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type PublicDbtDimBalanceAutoalexLockdrop2RankViewAvgFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_lockdrop2_rank_view_avg_fields';
  current_multiplier?: Maybe<Scalars['Float']>;
  rank_no?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "public_dbt.dim_balance_autoalex_lockdrop2_rank_view". All fields are combined with a logical 'AND'. */
export type PublicDbtDimBalanceAutoalexLockdrop2RankViewBoolExp = {
  _and?: InputMaybe<Array<PublicDbtDimBalanceAutoalexLockdrop2RankViewBoolExp>>;
  _not?: InputMaybe<PublicDbtDimBalanceAutoalexLockdrop2RankViewBoolExp>;
  _or?: InputMaybe<Array<PublicDbtDimBalanceAutoalexLockdrop2RankViewBoolExp>>;
  address?: InputMaybe<StringComparisonExp>;
  current_multiplier?: InputMaybe<Float8ComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  rank_no?: InputMaybe<BigintComparisonExp>;
  total_autoalex_balance?: InputMaybe<Float8ComparisonExp>;
};

/** aggregate max on columns */
export type PublicDbtDimBalanceAutoalexLockdrop2RankViewMaxFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_lockdrop2_rank_view_max_fields';
  address?: Maybe<Scalars['String']>;
  current_multiplier?: Maybe<Scalars['float8']>;
  name?: Maybe<Scalars['String']>;
  rank_no?: Maybe<Scalars['bigint']>;
  total_autoalex_balance?: Maybe<Scalars['float8']>;
};

/** aggregate min on columns */
export type PublicDbtDimBalanceAutoalexLockdrop2RankViewMinFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_lockdrop2_rank_view_min_fields';
  address?: Maybe<Scalars['String']>;
  current_multiplier?: Maybe<Scalars['float8']>;
  name?: Maybe<Scalars['String']>;
  rank_no?: Maybe<Scalars['bigint']>;
  total_autoalex_balance?: Maybe<Scalars['float8']>;
};

/** Ordering options when selecting data from "public_dbt.dim_balance_autoalex_lockdrop2_rank_view". */
export type PublicDbtDimBalanceAutoalexLockdrop2RankViewOrderBy = {
  address?: InputMaybe<OrderBy>;
  current_multiplier?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  rank_no?: InputMaybe<OrderBy>;
  total_autoalex_balance?: InputMaybe<OrderBy>;
};

/** select columns of table "public_dbt.dim_balance_autoalex_lockdrop2_rank_view" */
export enum PublicDbtDimBalanceAutoalexLockdrop2RankViewSelectColumn {
  /** column name */
  Address = 'address',
  /** column name */
  CurrentMultiplier = 'current_multiplier',
  /** column name */
  Name = 'name',
  /** column name */
  RankNo = 'rank_no',
  /** column name */
  TotalAutoalexBalance = 'total_autoalex_balance'
}

/** aggregate stddev on columns */
export type PublicDbtDimBalanceAutoalexLockdrop2RankViewStddevFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_lockdrop2_rank_view_stddev_fields';
  current_multiplier?: Maybe<Scalars['Float']>;
  rank_no?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type PublicDbtDimBalanceAutoalexLockdrop2RankViewStddevPopFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_lockdrop2_rank_view_stddev_pop_fields';
  current_multiplier?: Maybe<Scalars['Float']>;
  rank_no?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type PublicDbtDimBalanceAutoalexLockdrop2RankViewStddevSampFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_lockdrop2_rank_view_stddev_samp_fields';
  current_multiplier?: Maybe<Scalars['Float']>;
  rank_no?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "public_dbt_dim_balance_autoalex_lockdrop2_rank_view" */
export type PublicDbtDimBalanceAutoalexLockdrop2RankViewStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: PublicDbtDimBalanceAutoalexLockdrop2RankViewStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PublicDbtDimBalanceAutoalexLockdrop2RankViewStreamCursorValueInput = {
  address?: InputMaybe<Scalars['String']>;
  current_multiplier?: InputMaybe<Scalars['float8']>;
  name?: InputMaybe<Scalars['String']>;
  rank_no?: InputMaybe<Scalars['bigint']>;
  total_autoalex_balance?: InputMaybe<Scalars['float8']>;
};

/** aggregate sum on columns */
export type PublicDbtDimBalanceAutoalexLockdrop2RankViewSumFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_lockdrop2_rank_view_sum_fields';
  current_multiplier?: Maybe<Scalars['float8']>;
  rank_no?: Maybe<Scalars['bigint']>;
  total_autoalex_balance?: Maybe<Scalars['float8']>;
};

/** aggregate var_pop on columns */
export type PublicDbtDimBalanceAutoalexLockdrop2RankViewVarPopFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_lockdrop2_rank_view_var_pop_fields';
  current_multiplier?: Maybe<Scalars['Float']>;
  rank_no?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type PublicDbtDimBalanceAutoalexLockdrop2RankViewVarSampFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_lockdrop2_rank_view_var_samp_fields';
  current_multiplier?: Maybe<Scalars['Float']>;
  rank_no?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type PublicDbtDimBalanceAutoalexLockdrop2RankViewVarianceFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_lockdrop2_rank_view_variance_fields';
  current_multiplier?: Maybe<Scalars['Float']>;
  rank_no?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "public_dbt.dim_balance_autoalex_rank_on_height_view" */
export type PublicDbtDimBalanceAutoalexRankOnHeightView = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_on_height_view';
  address?: Maybe<Scalars['String']>;
  autoalex_balance?: Maybe<Scalars['float8']>;
  autoalex_price?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['String']>;
  lp_alex_autoalex_balance?: Maybe<Scalars['float8']>;
  lp_price_in_alex?: Maybe<Scalars['numeric']>;
  total_autoalex_balance?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "public_dbt.dim_balance_autoalex_rank_on_height_view" */
export type PublicDbtDimBalanceAutoalexRankOnHeightViewAggregate = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_on_height_view_aggregate';
  aggregate?: Maybe<PublicDbtDimBalanceAutoalexRankOnHeightViewAggregateFields>;
  nodes: Array<PublicDbtDimBalanceAutoalexRankOnHeightView>;
};

/** aggregate fields of "public_dbt.dim_balance_autoalex_rank_on_height_view" */
export type PublicDbtDimBalanceAutoalexRankOnHeightViewAggregateFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_on_height_view_aggregate_fields';
  avg?: Maybe<PublicDbtDimBalanceAutoalexRankOnHeightViewAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<PublicDbtDimBalanceAutoalexRankOnHeightViewMaxFields>;
  min?: Maybe<PublicDbtDimBalanceAutoalexRankOnHeightViewMinFields>;
  stddev?: Maybe<PublicDbtDimBalanceAutoalexRankOnHeightViewStddevFields>;
  stddev_pop?: Maybe<PublicDbtDimBalanceAutoalexRankOnHeightViewStddevPopFields>;
  stddev_samp?: Maybe<PublicDbtDimBalanceAutoalexRankOnHeightViewStddevSampFields>;
  sum?: Maybe<PublicDbtDimBalanceAutoalexRankOnHeightViewSumFields>;
  var_pop?: Maybe<PublicDbtDimBalanceAutoalexRankOnHeightViewVarPopFields>;
  var_samp?: Maybe<PublicDbtDimBalanceAutoalexRankOnHeightViewVarSampFields>;
  variance?: Maybe<PublicDbtDimBalanceAutoalexRankOnHeightViewVarianceFields>;
};


/** aggregate fields of "public_dbt.dim_balance_autoalex_rank_on_height_view" */
export type PublicDbtDimBalanceAutoalexRankOnHeightViewAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankOnHeightViewSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type PublicDbtDimBalanceAutoalexRankOnHeightViewAvgFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_on_height_view_avg_fields';
  autoalex_balance?: Maybe<Scalars['Float']>;
  autoalex_price?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  lp_alex_autoalex_balance?: Maybe<Scalars['Float']>;
  lp_price_in_alex?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "public_dbt.dim_balance_autoalex_rank_on_height_view". All fields are combined with a logical 'AND'. */
export type PublicDbtDimBalanceAutoalexRankOnHeightViewBoolExp = {
  _and?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankOnHeightViewBoolExp>>;
  _not?: InputMaybe<PublicDbtDimBalanceAutoalexRankOnHeightViewBoolExp>;
  _or?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankOnHeightViewBoolExp>>;
  address?: InputMaybe<StringComparisonExp>;
  autoalex_balance?: InputMaybe<Float8ComparisonExp>;
  autoalex_price?: InputMaybe<NumericComparisonExp>;
  block_height?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<StringComparisonExp>;
  lp_alex_autoalex_balance?: InputMaybe<Float8ComparisonExp>;
  lp_price_in_alex?: InputMaybe<NumericComparisonExp>;
  total_autoalex_balance?: InputMaybe<NumericComparisonExp>;
};

/** input type for incrementing numeric columns in table "public_dbt.dim_balance_autoalex_rank_on_height_view" */
export type PublicDbtDimBalanceAutoalexRankOnHeightViewIncInput = {
  autoalex_balance?: InputMaybe<Scalars['float8']>;
  autoalex_price?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['Int']>;
  lp_alex_autoalex_balance?: InputMaybe<Scalars['float8']>;
  lp_price_in_alex?: InputMaybe<Scalars['numeric']>;
  total_autoalex_balance?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "public_dbt.dim_balance_autoalex_rank_on_height_view" */
export type PublicDbtDimBalanceAutoalexRankOnHeightViewInsertInput = {
  address?: InputMaybe<Scalars['String']>;
  autoalex_balance?: InputMaybe<Scalars['float8']>;
  autoalex_price?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['String']>;
  lp_alex_autoalex_balance?: InputMaybe<Scalars['float8']>;
  lp_price_in_alex?: InputMaybe<Scalars['numeric']>;
  total_autoalex_balance?: InputMaybe<Scalars['numeric']>;
};

/** aggregate max on columns */
export type PublicDbtDimBalanceAutoalexRankOnHeightViewMaxFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_on_height_view_max_fields';
  address?: Maybe<Scalars['String']>;
  autoalex_balance?: Maybe<Scalars['float8']>;
  autoalex_price?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['String']>;
  lp_alex_autoalex_balance?: Maybe<Scalars['float8']>;
  lp_price_in_alex?: Maybe<Scalars['numeric']>;
  total_autoalex_balance?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type PublicDbtDimBalanceAutoalexRankOnHeightViewMinFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_on_height_view_min_fields';
  address?: Maybe<Scalars['String']>;
  autoalex_balance?: Maybe<Scalars['float8']>;
  autoalex_price?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['String']>;
  lp_alex_autoalex_balance?: Maybe<Scalars['float8']>;
  lp_price_in_alex?: Maybe<Scalars['numeric']>;
  total_autoalex_balance?: Maybe<Scalars['numeric']>;
};

/** response of any mutation on the table "public_dbt.dim_balance_autoalex_rank_on_height_view" */
export type PublicDbtDimBalanceAutoalexRankOnHeightViewMutationResponse = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_on_height_view_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<PublicDbtDimBalanceAutoalexRankOnHeightView>;
};

/** Ordering options when selecting data from "public_dbt.dim_balance_autoalex_rank_on_height_view". */
export type PublicDbtDimBalanceAutoalexRankOnHeightViewOrderBy = {
  address?: InputMaybe<OrderBy>;
  autoalex_balance?: InputMaybe<OrderBy>;
  autoalex_price?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lp_alex_autoalex_balance?: InputMaybe<OrderBy>;
  lp_price_in_alex?: InputMaybe<OrderBy>;
  total_autoalex_balance?: InputMaybe<OrderBy>;
};

/** select columns of table "public_dbt.dim_balance_autoalex_rank_on_height_view" */
export enum PublicDbtDimBalanceAutoalexRankOnHeightViewSelectColumn {
  /** column name */
  Address = 'address',
  /** column name */
  AutoalexBalance = 'autoalex_balance',
  /** column name */
  AutoalexPrice = 'autoalex_price',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  Id = 'id',
  /** column name */
  LpAlexAutoalexBalance = 'lp_alex_autoalex_balance',
  /** column name */
  LpPriceInAlex = 'lp_price_in_alex',
  /** column name */
  TotalAutoalexBalance = 'total_autoalex_balance'
}

/** input type for updating data in table "public_dbt.dim_balance_autoalex_rank_on_height_view" */
export type PublicDbtDimBalanceAutoalexRankOnHeightViewSetInput = {
  address?: InputMaybe<Scalars['String']>;
  autoalex_balance?: InputMaybe<Scalars['float8']>;
  autoalex_price?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['String']>;
  lp_alex_autoalex_balance?: InputMaybe<Scalars['float8']>;
  lp_price_in_alex?: InputMaybe<Scalars['numeric']>;
  total_autoalex_balance?: InputMaybe<Scalars['numeric']>;
};

/** aggregate stddev on columns */
export type PublicDbtDimBalanceAutoalexRankOnHeightViewStddevFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_on_height_view_stddev_fields';
  autoalex_balance?: Maybe<Scalars['Float']>;
  autoalex_price?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  lp_alex_autoalex_balance?: Maybe<Scalars['Float']>;
  lp_price_in_alex?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type PublicDbtDimBalanceAutoalexRankOnHeightViewStddevPopFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_on_height_view_stddev_pop_fields';
  autoalex_balance?: Maybe<Scalars['Float']>;
  autoalex_price?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  lp_alex_autoalex_balance?: Maybe<Scalars['Float']>;
  lp_price_in_alex?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type PublicDbtDimBalanceAutoalexRankOnHeightViewStddevSampFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_on_height_view_stddev_samp_fields';
  autoalex_balance?: Maybe<Scalars['Float']>;
  autoalex_price?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  lp_alex_autoalex_balance?: Maybe<Scalars['Float']>;
  lp_price_in_alex?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "public_dbt_dim_balance_autoalex_rank_on_height_view" */
export type PublicDbtDimBalanceAutoalexRankOnHeightViewStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: PublicDbtDimBalanceAutoalexRankOnHeightViewStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PublicDbtDimBalanceAutoalexRankOnHeightViewStreamCursorValueInput = {
  address?: InputMaybe<Scalars['String']>;
  autoalex_balance?: InputMaybe<Scalars['float8']>;
  autoalex_price?: InputMaybe<Scalars['numeric']>;
  block_height?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['String']>;
  lp_alex_autoalex_balance?: InputMaybe<Scalars['float8']>;
  lp_price_in_alex?: InputMaybe<Scalars['numeric']>;
  total_autoalex_balance?: InputMaybe<Scalars['numeric']>;
};

/** aggregate sum on columns */
export type PublicDbtDimBalanceAutoalexRankOnHeightViewSumFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_on_height_view_sum_fields';
  autoalex_balance?: Maybe<Scalars['float8']>;
  autoalex_price?: Maybe<Scalars['numeric']>;
  block_height?: Maybe<Scalars['Int']>;
  lp_alex_autoalex_balance?: Maybe<Scalars['float8']>;
  lp_price_in_alex?: Maybe<Scalars['numeric']>;
  total_autoalex_balance?: Maybe<Scalars['numeric']>;
};

export type PublicDbtDimBalanceAutoalexRankOnHeightViewUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<PublicDbtDimBalanceAutoalexRankOnHeightViewIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PublicDbtDimBalanceAutoalexRankOnHeightViewSetInput>;
  where: PublicDbtDimBalanceAutoalexRankOnHeightViewBoolExp;
};

/** aggregate var_pop on columns */
export type PublicDbtDimBalanceAutoalexRankOnHeightViewVarPopFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_on_height_view_var_pop_fields';
  autoalex_balance?: Maybe<Scalars['Float']>;
  autoalex_price?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  lp_alex_autoalex_balance?: Maybe<Scalars['Float']>;
  lp_price_in_alex?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type PublicDbtDimBalanceAutoalexRankOnHeightViewVarSampFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_on_height_view_var_samp_fields';
  autoalex_balance?: Maybe<Scalars['Float']>;
  autoalex_price?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  lp_alex_autoalex_balance?: Maybe<Scalars['Float']>;
  lp_price_in_alex?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type PublicDbtDimBalanceAutoalexRankOnHeightViewVarianceFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_on_height_view_variance_fields';
  autoalex_balance?: Maybe<Scalars['Float']>;
  autoalex_price?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  lp_alex_autoalex_balance?: Maybe<Scalars['Float']>;
  lp_price_in_alex?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "public_dbt.dim_balance_autoalex_rank_snapshot_view" */
export type PublicDbtDimBalanceAutoalexRankSnapshotView = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_snapshot_view';
  address?: Maybe<Scalars['String']>;
  balance_block_height?: Maybe<Scalars['Int']>;
  multiplier?: Maybe<Scalars['float8']>;
  snapshot_rank?: Maybe<Scalars['Int']>;
  target_block_height?: Maybe<Scalars['Int']>;
  total_autoalex_balance?: Maybe<Scalars['float8']>;
};

/** aggregated selection of "public_dbt.dim_balance_autoalex_rank_snapshot_view" */
export type PublicDbtDimBalanceAutoalexRankSnapshotViewAggregate = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_snapshot_view_aggregate';
  aggregate?: Maybe<PublicDbtDimBalanceAutoalexRankSnapshotViewAggregateFields>;
  nodes: Array<PublicDbtDimBalanceAutoalexRankSnapshotView>;
};

/** aggregate fields of "public_dbt.dim_balance_autoalex_rank_snapshot_view" */
export type PublicDbtDimBalanceAutoalexRankSnapshotViewAggregateFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_snapshot_view_aggregate_fields';
  avg?: Maybe<PublicDbtDimBalanceAutoalexRankSnapshotViewAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<PublicDbtDimBalanceAutoalexRankSnapshotViewMaxFields>;
  min?: Maybe<PublicDbtDimBalanceAutoalexRankSnapshotViewMinFields>;
  stddev?: Maybe<PublicDbtDimBalanceAutoalexRankSnapshotViewStddevFields>;
  stddev_pop?: Maybe<PublicDbtDimBalanceAutoalexRankSnapshotViewStddevPopFields>;
  stddev_samp?: Maybe<PublicDbtDimBalanceAutoalexRankSnapshotViewStddevSampFields>;
  sum?: Maybe<PublicDbtDimBalanceAutoalexRankSnapshotViewSumFields>;
  var_pop?: Maybe<PublicDbtDimBalanceAutoalexRankSnapshotViewVarPopFields>;
  var_samp?: Maybe<PublicDbtDimBalanceAutoalexRankSnapshotViewVarSampFields>;
  variance?: Maybe<PublicDbtDimBalanceAutoalexRankSnapshotViewVarianceFields>;
};


/** aggregate fields of "public_dbt.dim_balance_autoalex_rank_snapshot_view" */
export type PublicDbtDimBalanceAutoalexRankSnapshotViewAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankSnapshotViewSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type PublicDbtDimBalanceAutoalexRankSnapshotViewAvgFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_snapshot_view_avg_fields';
  balance_block_height?: Maybe<Scalars['Float']>;
  multiplier?: Maybe<Scalars['Float']>;
  snapshot_rank?: Maybe<Scalars['Float']>;
  target_block_height?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "public_dbt.dim_balance_autoalex_rank_snapshot_view". All fields are combined with a logical 'AND'. */
export type PublicDbtDimBalanceAutoalexRankSnapshotViewBoolExp = {
  _and?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankSnapshotViewBoolExp>>;
  _not?: InputMaybe<PublicDbtDimBalanceAutoalexRankSnapshotViewBoolExp>;
  _or?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankSnapshotViewBoolExp>>;
  address?: InputMaybe<StringComparisonExp>;
  balance_block_height?: InputMaybe<IntComparisonExp>;
  multiplier?: InputMaybe<Float8ComparisonExp>;
  snapshot_rank?: InputMaybe<IntComparisonExp>;
  target_block_height?: InputMaybe<IntComparisonExp>;
  total_autoalex_balance?: InputMaybe<Float8ComparisonExp>;
};

/** aggregate max on columns */
export type PublicDbtDimBalanceAutoalexRankSnapshotViewMaxFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_snapshot_view_max_fields';
  address?: Maybe<Scalars['String']>;
  balance_block_height?: Maybe<Scalars['Int']>;
  multiplier?: Maybe<Scalars['float8']>;
  snapshot_rank?: Maybe<Scalars['Int']>;
  target_block_height?: Maybe<Scalars['Int']>;
  total_autoalex_balance?: Maybe<Scalars['float8']>;
};

/** aggregate min on columns */
export type PublicDbtDimBalanceAutoalexRankSnapshotViewMinFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_snapshot_view_min_fields';
  address?: Maybe<Scalars['String']>;
  balance_block_height?: Maybe<Scalars['Int']>;
  multiplier?: Maybe<Scalars['float8']>;
  snapshot_rank?: Maybe<Scalars['Int']>;
  target_block_height?: Maybe<Scalars['Int']>;
  total_autoalex_balance?: Maybe<Scalars['float8']>;
};

/** Ordering options when selecting data from "public_dbt.dim_balance_autoalex_rank_snapshot_view". */
export type PublicDbtDimBalanceAutoalexRankSnapshotViewOrderBy = {
  address?: InputMaybe<OrderBy>;
  balance_block_height?: InputMaybe<OrderBy>;
  multiplier?: InputMaybe<OrderBy>;
  snapshot_rank?: InputMaybe<OrderBy>;
  target_block_height?: InputMaybe<OrderBy>;
  total_autoalex_balance?: InputMaybe<OrderBy>;
};

/** select columns of table "public_dbt.dim_balance_autoalex_rank_snapshot_view" */
export enum PublicDbtDimBalanceAutoalexRankSnapshotViewSelectColumn {
  /** column name */
  Address = 'address',
  /** column name */
  BalanceBlockHeight = 'balance_block_height',
  /** column name */
  Multiplier = 'multiplier',
  /** column name */
  SnapshotRank = 'snapshot_rank',
  /** column name */
  TargetBlockHeight = 'target_block_height',
  /** column name */
  TotalAutoalexBalance = 'total_autoalex_balance'
}

/** aggregate stddev on columns */
export type PublicDbtDimBalanceAutoalexRankSnapshotViewStddevFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_snapshot_view_stddev_fields';
  balance_block_height?: Maybe<Scalars['Float']>;
  multiplier?: Maybe<Scalars['Float']>;
  snapshot_rank?: Maybe<Scalars['Float']>;
  target_block_height?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type PublicDbtDimBalanceAutoalexRankSnapshotViewStddevPopFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_snapshot_view_stddev_pop_fields';
  balance_block_height?: Maybe<Scalars['Float']>;
  multiplier?: Maybe<Scalars['Float']>;
  snapshot_rank?: Maybe<Scalars['Float']>;
  target_block_height?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type PublicDbtDimBalanceAutoalexRankSnapshotViewStddevSampFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_snapshot_view_stddev_samp_fields';
  balance_block_height?: Maybe<Scalars['Float']>;
  multiplier?: Maybe<Scalars['Float']>;
  snapshot_rank?: Maybe<Scalars['Float']>;
  target_block_height?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "public_dbt_dim_balance_autoalex_rank_snapshot_view" */
export type PublicDbtDimBalanceAutoalexRankSnapshotViewStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: PublicDbtDimBalanceAutoalexRankSnapshotViewStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PublicDbtDimBalanceAutoalexRankSnapshotViewStreamCursorValueInput = {
  address?: InputMaybe<Scalars['String']>;
  balance_block_height?: InputMaybe<Scalars['Int']>;
  multiplier?: InputMaybe<Scalars['float8']>;
  snapshot_rank?: InputMaybe<Scalars['Int']>;
  target_block_height?: InputMaybe<Scalars['Int']>;
  total_autoalex_balance?: InputMaybe<Scalars['float8']>;
};

/** aggregate sum on columns */
export type PublicDbtDimBalanceAutoalexRankSnapshotViewSumFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_snapshot_view_sum_fields';
  balance_block_height?: Maybe<Scalars['Int']>;
  multiplier?: Maybe<Scalars['float8']>;
  snapshot_rank?: Maybe<Scalars['Int']>;
  target_block_height?: Maybe<Scalars['Int']>;
  total_autoalex_balance?: Maybe<Scalars['float8']>;
};

/** aggregate var_pop on columns */
export type PublicDbtDimBalanceAutoalexRankSnapshotViewVarPopFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_snapshot_view_var_pop_fields';
  balance_block_height?: Maybe<Scalars['Float']>;
  multiplier?: Maybe<Scalars['Float']>;
  snapshot_rank?: Maybe<Scalars['Float']>;
  target_block_height?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type PublicDbtDimBalanceAutoalexRankSnapshotViewVarSampFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_snapshot_view_var_samp_fields';
  balance_block_height?: Maybe<Scalars['Float']>;
  multiplier?: Maybe<Scalars['Float']>;
  snapshot_rank?: Maybe<Scalars['Float']>;
  target_block_height?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type PublicDbtDimBalanceAutoalexRankSnapshotViewVarianceFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_snapshot_view_variance_fields';
  balance_block_height?: Maybe<Scalars['Float']>;
  multiplier?: Maybe<Scalars['Float']>;
  snapshot_rank?: Maybe<Scalars['Float']>;
  target_block_height?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "public_dbt.dim_balance_autoalex_rank_view" */
export type PublicDbtDimBalanceAutoalexRankView = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_view';
  address?: Maybe<Scalars['String']>;
  current_multiplier?: Maybe<Scalars['float8']>;
  name?: Maybe<Scalars['String']>;
  rank_no?: Maybe<Scalars['bigint']>;
  total_autoalex_balance?: Maybe<Scalars['float8']>;
};

/** aggregated selection of "public_dbt.dim_balance_autoalex_rank_view" */
export type PublicDbtDimBalanceAutoalexRankViewAggregate = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_view_aggregate';
  aggregate?: Maybe<PublicDbtDimBalanceAutoalexRankViewAggregateFields>;
  nodes: Array<PublicDbtDimBalanceAutoalexRankView>;
};

/** aggregate fields of "public_dbt.dim_balance_autoalex_rank_view" */
export type PublicDbtDimBalanceAutoalexRankViewAggregateFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_view_aggregate_fields';
  avg?: Maybe<PublicDbtDimBalanceAutoalexRankViewAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<PublicDbtDimBalanceAutoalexRankViewMaxFields>;
  min?: Maybe<PublicDbtDimBalanceAutoalexRankViewMinFields>;
  stddev?: Maybe<PublicDbtDimBalanceAutoalexRankViewStddevFields>;
  stddev_pop?: Maybe<PublicDbtDimBalanceAutoalexRankViewStddevPopFields>;
  stddev_samp?: Maybe<PublicDbtDimBalanceAutoalexRankViewStddevSampFields>;
  sum?: Maybe<PublicDbtDimBalanceAutoalexRankViewSumFields>;
  var_pop?: Maybe<PublicDbtDimBalanceAutoalexRankViewVarPopFields>;
  var_samp?: Maybe<PublicDbtDimBalanceAutoalexRankViewVarSampFields>;
  variance?: Maybe<PublicDbtDimBalanceAutoalexRankViewVarianceFields>;
};


/** aggregate fields of "public_dbt.dim_balance_autoalex_rank_view" */
export type PublicDbtDimBalanceAutoalexRankViewAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankViewSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type PublicDbtDimBalanceAutoalexRankViewAvgFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_view_avg_fields';
  current_multiplier?: Maybe<Scalars['Float']>;
  rank_no?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "public_dbt.dim_balance_autoalex_rank_view". All fields are combined with a logical 'AND'. */
export type PublicDbtDimBalanceAutoalexRankViewBoolExp = {
  _and?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankViewBoolExp>>;
  _not?: InputMaybe<PublicDbtDimBalanceAutoalexRankViewBoolExp>;
  _or?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankViewBoolExp>>;
  address?: InputMaybe<StringComparisonExp>;
  current_multiplier?: InputMaybe<Float8ComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  rank_no?: InputMaybe<BigintComparisonExp>;
  total_autoalex_balance?: InputMaybe<Float8ComparisonExp>;
};

/** input type for incrementing numeric columns in table "public_dbt.dim_balance_autoalex_rank_view" */
export type PublicDbtDimBalanceAutoalexRankViewIncInput = {
  current_multiplier?: InputMaybe<Scalars['float8']>;
  rank_no?: InputMaybe<Scalars['bigint']>;
  total_autoalex_balance?: InputMaybe<Scalars['float8']>;
};

/** input type for inserting data into table "public_dbt.dim_balance_autoalex_rank_view" */
export type PublicDbtDimBalanceAutoalexRankViewInsertInput = {
  address?: InputMaybe<Scalars['String']>;
  current_multiplier?: InputMaybe<Scalars['float8']>;
  name?: InputMaybe<Scalars['String']>;
  rank_no?: InputMaybe<Scalars['bigint']>;
  total_autoalex_balance?: InputMaybe<Scalars['float8']>;
};

/** aggregate max on columns */
export type PublicDbtDimBalanceAutoalexRankViewMaxFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_view_max_fields';
  address?: Maybe<Scalars['String']>;
  current_multiplier?: Maybe<Scalars['float8']>;
  name?: Maybe<Scalars['String']>;
  rank_no?: Maybe<Scalars['bigint']>;
  total_autoalex_balance?: Maybe<Scalars['float8']>;
};

/** aggregate min on columns */
export type PublicDbtDimBalanceAutoalexRankViewMinFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_view_min_fields';
  address?: Maybe<Scalars['String']>;
  current_multiplier?: Maybe<Scalars['float8']>;
  name?: Maybe<Scalars['String']>;
  rank_no?: Maybe<Scalars['bigint']>;
  total_autoalex_balance?: Maybe<Scalars['float8']>;
};

/** response of any mutation on the table "public_dbt.dim_balance_autoalex_rank_view" */
export type PublicDbtDimBalanceAutoalexRankViewMutationResponse = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_view_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<PublicDbtDimBalanceAutoalexRankView>;
};

/** Ordering options when selecting data from "public_dbt.dim_balance_autoalex_rank_view". */
export type PublicDbtDimBalanceAutoalexRankViewOrderBy = {
  address?: InputMaybe<OrderBy>;
  current_multiplier?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  rank_no?: InputMaybe<OrderBy>;
  total_autoalex_balance?: InputMaybe<OrderBy>;
};

/** select columns of table "public_dbt.dim_balance_autoalex_rank_view" */
export enum PublicDbtDimBalanceAutoalexRankViewSelectColumn {
  /** column name */
  Address = 'address',
  /** column name */
  CurrentMultiplier = 'current_multiplier',
  /** column name */
  Name = 'name',
  /** column name */
  RankNo = 'rank_no',
  /** column name */
  TotalAutoalexBalance = 'total_autoalex_balance'
}

/** input type for updating data in table "public_dbt.dim_balance_autoalex_rank_view" */
export type PublicDbtDimBalanceAutoalexRankViewSetInput = {
  address?: InputMaybe<Scalars['String']>;
  current_multiplier?: InputMaybe<Scalars['float8']>;
  name?: InputMaybe<Scalars['String']>;
  rank_no?: InputMaybe<Scalars['bigint']>;
  total_autoalex_balance?: InputMaybe<Scalars['float8']>;
};

/** aggregate stddev on columns */
export type PublicDbtDimBalanceAutoalexRankViewStddevFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_view_stddev_fields';
  current_multiplier?: Maybe<Scalars['Float']>;
  rank_no?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type PublicDbtDimBalanceAutoalexRankViewStddevPopFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_view_stddev_pop_fields';
  current_multiplier?: Maybe<Scalars['Float']>;
  rank_no?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type PublicDbtDimBalanceAutoalexRankViewStddevSampFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_view_stddev_samp_fields';
  current_multiplier?: Maybe<Scalars['Float']>;
  rank_no?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "public_dbt_dim_balance_autoalex_rank_view" */
export type PublicDbtDimBalanceAutoalexRankViewStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: PublicDbtDimBalanceAutoalexRankViewStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PublicDbtDimBalanceAutoalexRankViewStreamCursorValueInput = {
  address?: InputMaybe<Scalars['String']>;
  current_multiplier?: InputMaybe<Scalars['float8']>;
  name?: InputMaybe<Scalars['String']>;
  rank_no?: InputMaybe<Scalars['bigint']>;
  total_autoalex_balance?: InputMaybe<Scalars['float8']>;
};

/** aggregate sum on columns */
export type PublicDbtDimBalanceAutoalexRankViewSumFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_view_sum_fields';
  current_multiplier?: Maybe<Scalars['float8']>;
  rank_no?: Maybe<Scalars['bigint']>;
  total_autoalex_balance?: Maybe<Scalars['float8']>;
};

export type PublicDbtDimBalanceAutoalexRankViewUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<PublicDbtDimBalanceAutoalexRankViewIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PublicDbtDimBalanceAutoalexRankViewSetInput>;
  where: PublicDbtDimBalanceAutoalexRankViewBoolExp;
};

/** aggregate var_pop on columns */
export type PublicDbtDimBalanceAutoalexRankViewVarPopFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_view_var_pop_fields';
  current_multiplier?: Maybe<Scalars['Float']>;
  rank_no?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type PublicDbtDimBalanceAutoalexRankViewVarSampFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_view_var_samp_fields';
  current_multiplier?: Maybe<Scalars['Float']>;
  rank_no?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type PublicDbtDimBalanceAutoalexRankViewVarianceFields = {
  __typename?: 'public_dbt_dim_balance_autoalex_rank_view_variance_fields';
  current_multiplier?: Maybe<Scalars['Float']>;
  rank_no?: Maybe<Scalars['Float']>;
  total_autoalex_balance?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "public_dbt.dim_idos_info" */
export type PublicDbtDimIdosInfo = {
  __typename?: 'public_dbt_dim_idos_info';
  ido_alex_participants_count?: Maybe<Scalars['bigint']>;
  ido_banana_participants_count?: Maybe<Scalars['bigint']>;
  max_alex_wban_ratio?: Maybe<Scalars['float8']>;
  max_wstx_alex_ratio?: Maybe<Scalars['float8']>;
};

/** aggregated selection of "public_dbt.dim_idos_info" */
export type PublicDbtDimIdosInfoAggregate = {
  __typename?: 'public_dbt_dim_idos_info_aggregate';
  aggregate?: Maybe<PublicDbtDimIdosInfoAggregateFields>;
  nodes: Array<PublicDbtDimIdosInfo>;
};

/** aggregate fields of "public_dbt.dim_idos_info" */
export type PublicDbtDimIdosInfoAggregateFields = {
  __typename?: 'public_dbt_dim_idos_info_aggregate_fields';
  avg?: Maybe<PublicDbtDimIdosInfoAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<PublicDbtDimIdosInfoMaxFields>;
  min?: Maybe<PublicDbtDimIdosInfoMinFields>;
  stddev?: Maybe<PublicDbtDimIdosInfoStddevFields>;
  stddev_pop?: Maybe<PublicDbtDimIdosInfoStddevPopFields>;
  stddev_samp?: Maybe<PublicDbtDimIdosInfoStddevSampFields>;
  sum?: Maybe<PublicDbtDimIdosInfoSumFields>;
  var_pop?: Maybe<PublicDbtDimIdosInfoVarPopFields>;
  var_samp?: Maybe<PublicDbtDimIdosInfoVarSampFields>;
  variance?: Maybe<PublicDbtDimIdosInfoVarianceFields>;
};


/** aggregate fields of "public_dbt.dim_idos_info" */
export type PublicDbtDimIdosInfoAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PublicDbtDimIdosInfoSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type PublicDbtDimIdosInfoAvgFields = {
  __typename?: 'public_dbt_dim_idos_info_avg_fields';
  ido_alex_participants_count?: Maybe<Scalars['Float']>;
  ido_banana_participants_count?: Maybe<Scalars['Float']>;
  max_alex_wban_ratio?: Maybe<Scalars['Float']>;
  max_wstx_alex_ratio?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "public_dbt.dim_idos_info". All fields are combined with a logical 'AND'. */
export type PublicDbtDimIdosInfoBoolExp = {
  _and?: InputMaybe<Array<PublicDbtDimIdosInfoBoolExp>>;
  _not?: InputMaybe<PublicDbtDimIdosInfoBoolExp>;
  _or?: InputMaybe<Array<PublicDbtDimIdosInfoBoolExp>>;
  ido_alex_participants_count?: InputMaybe<BigintComparisonExp>;
  ido_banana_participants_count?: InputMaybe<BigintComparisonExp>;
  max_alex_wban_ratio?: InputMaybe<Float8ComparisonExp>;
  max_wstx_alex_ratio?: InputMaybe<Float8ComparisonExp>;
};

/** aggregate max on columns */
export type PublicDbtDimIdosInfoMaxFields = {
  __typename?: 'public_dbt_dim_idos_info_max_fields';
  ido_alex_participants_count?: Maybe<Scalars['bigint']>;
  ido_banana_participants_count?: Maybe<Scalars['bigint']>;
  max_alex_wban_ratio?: Maybe<Scalars['float8']>;
  max_wstx_alex_ratio?: Maybe<Scalars['float8']>;
};

/** aggregate min on columns */
export type PublicDbtDimIdosInfoMinFields = {
  __typename?: 'public_dbt_dim_idos_info_min_fields';
  ido_alex_participants_count?: Maybe<Scalars['bigint']>;
  ido_banana_participants_count?: Maybe<Scalars['bigint']>;
  max_alex_wban_ratio?: Maybe<Scalars['float8']>;
  max_wstx_alex_ratio?: Maybe<Scalars['float8']>;
};

/** Ordering options when selecting data from "public_dbt.dim_idos_info". */
export type PublicDbtDimIdosInfoOrderBy = {
  ido_alex_participants_count?: InputMaybe<OrderBy>;
  ido_banana_participants_count?: InputMaybe<OrderBy>;
  max_alex_wban_ratio?: InputMaybe<OrderBy>;
  max_wstx_alex_ratio?: InputMaybe<OrderBy>;
};

/** select columns of table "public_dbt.dim_idos_info" */
export enum PublicDbtDimIdosInfoSelectColumn {
  /** column name */
  IdoAlexParticipantsCount = 'ido_alex_participants_count',
  /** column name */
  IdoBananaParticipantsCount = 'ido_banana_participants_count',
  /** column name */
  MaxAlexWbanRatio = 'max_alex_wban_ratio',
  /** column name */
  MaxWstxAlexRatio = 'max_wstx_alex_ratio'
}

/** aggregate stddev on columns */
export type PublicDbtDimIdosInfoStddevFields = {
  __typename?: 'public_dbt_dim_idos_info_stddev_fields';
  ido_alex_participants_count?: Maybe<Scalars['Float']>;
  ido_banana_participants_count?: Maybe<Scalars['Float']>;
  max_alex_wban_ratio?: Maybe<Scalars['Float']>;
  max_wstx_alex_ratio?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type PublicDbtDimIdosInfoStddevPopFields = {
  __typename?: 'public_dbt_dim_idos_info_stddev_pop_fields';
  ido_alex_participants_count?: Maybe<Scalars['Float']>;
  ido_banana_participants_count?: Maybe<Scalars['Float']>;
  max_alex_wban_ratio?: Maybe<Scalars['Float']>;
  max_wstx_alex_ratio?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type PublicDbtDimIdosInfoStddevSampFields = {
  __typename?: 'public_dbt_dim_idos_info_stddev_samp_fields';
  ido_alex_participants_count?: Maybe<Scalars['Float']>;
  ido_banana_participants_count?: Maybe<Scalars['Float']>;
  max_alex_wban_ratio?: Maybe<Scalars['Float']>;
  max_wstx_alex_ratio?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "public_dbt_dim_idos_info" */
export type PublicDbtDimIdosInfoStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: PublicDbtDimIdosInfoStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PublicDbtDimIdosInfoStreamCursorValueInput = {
  ido_alex_participants_count?: InputMaybe<Scalars['bigint']>;
  ido_banana_participants_count?: InputMaybe<Scalars['bigint']>;
  max_alex_wban_ratio?: InputMaybe<Scalars['float8']>;
  max_wstx_alex_ratio?: InputMaybe<Scalars['float8']>;
};

/** aggregate sum on columns */
export type PublicDbtDimIdosInfoSumFields = {
  __typename?: 'public_dbt_dim_idos_info_sum_fields';
  ido_alex_participants_count?: Maybe<Scalars['bigint']>;
  ido_banana_participants_count?: Maybe<Scalars['bigint']>;
  max_alex_wban_ratio?: Maybe<Scalars['float8']>;
  max_wstx_alex_ratio?: Maybe<Scalars['float8']>;
};

/** aggregate var_pop on columns */
export type PublicDbtDimIdosInfoVarPopFields = {
  __typename?: 'public_dbt_dim_idos_info_var_pop_fields';
  ido_alex_participants_count?: Maybe<Scalars['Float']>;
  ido_banana_participants_count?: Maybe<Scalars['Float']>;
  max_alex_wban_ratio?: Maybe<Scalars['Float']>;
  max_wstx_alex_ratio?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type PublicDbtDimIdosInfoVarSampFields = {
  __typename?: 'public_dbt_dim_idos_info_var_samp_fields';
  ido_alex_participants_count?: Maybe<Scalars['Float']>;
  ido_banana_participants_count?: Maybe<Scalars['Float']>;
  max_alex_wban_ratio?: Maybe<Scalars['Float']>;
  max_wstx_alex_ratio?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type PublicDbtDimIdosInfoVarianceFields = {
  __typename?: 'public_dbt_dim_idos_info_variance_fields';
  ido_alex_participants_count?: Maybe<Scalars['Float']>;
  ido_banana_participants_count?: Maybe<Scalars['Float']>;
  max_alex_wban_ratio?: Maybe<Scalars['Float']>;
  max_wstx_alex_ratio?: Maybe<Scalars['Float']>;
};

export type QueryRoot = {
  __typename?: 'query_root';
  analyticsTabs?: Maybe<AnalyticsTabs>;
  analyticsTabsCollection?: Maybe<AnalyticsTabsCollection>;
  appConfig?: Maybe<AppConfig>;
  appConfigCollection?: Maybe<AppConfigCollection>;
  asset?: Maybe<Asset>;
  assetCollection?: Maybe<AssetCollection>;
  banner?: Maybe<Banner>;
  bannerCollection?: Maybe<BannerCollection>;
  /** fetch data from the table: "blocks" */
  blocks: Array<Blocks>;
  /** fetch aggregated fields from the table: "blocks" */
  blocks_aggregate: BlocksAggregate;
  /** fetch data from the table: "blocks" using primary key columns */
  blocks_by_pk?: Maybe<Blocks>;
  /** fetch data from the table: "contract_logs" */
  contract_logs: Array<ContractLogs>;
  /** fetch aggregated fields from the table: "contract_logs" */
  contract_logs_aggregate: ContractLogsAggregate;
  /** fetch data from the table: "contract_logs" using primary key columns */
  contract_logs_by_pk?: Maybe<ContractLogs>;
  entryCollection?: Maybe<EntryCollection>;
  /** fetch data from the table: "ft_events" */
  ft_events: Array<FtEvents>;
  /** fetch aggregated fields from the table: "ft_events" */
  ft_events_aggregate: FtEventsAggregate;
  /** fetch data from the table: "ft_events" using primary key columns */
  ft_events_by_pk?: Maybe<FtEvents>;
  get_crp_simulation?: Maybe<CrpSimulationOutput>;
  ido?: Maybe<Ido>;
  idoCollection?: Maybe<IdoCollection>;
  /** fetch data from the table: "laplace.alex_reserve_pools" */
  laplace_alex_reserve_pools: Array<LaplaceAlexReservePools>;
  /** fetch aggregated fields from the table: "laplace.alex_reserve_pools" */
  laplace_alex_reserve_pools_aggregate: LaplaceAlexReservePoolsAggregate;
  /** fetch data from the table: "laplace.alex_reserve_pools" using primary key columns */
  laplace_alex_reserve_pools_by_pk?: Maybe<LaplaceAlexReservePools>;
  /** fetch data from the table: "laplace.alex_usd_pricing" */
  laplace_alex_usd_pricing: Array<LaplaceAlexUsdPricing>;
  /** fetch aggregated fields from the table: "laplace.alex_usd_pricing" */
  laplace_alex_usd_pricing_aggregate: LaplaceAlexUsdPricingAggregate;
  /** fetch data from the table: "laplace.borrow_deposit_daily_stats" */
  laplace_borrow_deposit_daily_stats: Array<LaplaceBorrowDepositDailyStats>;
  /** fetch aggregated fields from the table: "laplace.borrow_deposit_daily_stats" */
  laplace_borrow_deposit_daily_stats_aggregate: LaplaceBorrowDepositDailyStatsAggregate;
  /** fetch data from the table: "laplace.borrow_deposit_daily_stats" using primary key columns */
  laplace_borrow_deposit_daily_stats_by_pk?: Maybe<LaplaceBorrowDepositDailyStats>;
  /** fetch data from the table: "laplace.borrow_deposit_hourly_stats" */
  laplace_borrow_deposit_hourly_stats: Array<LaplaceBorrowDepositHourlyStats>;
  /** fetch aggregated fields from the table: "laplace.borrow_deposit_hourly_stats" */
  laplace_borrow_deposit_hourly_stats_aggregate: LaplaceBorrowDepositHourlyStatsAggregate;
  /** fetch data from the table: "laplace.borrow_deposit_hourly_stats" using primary key columns */
  laplace_borrow_deposit_hourly_stats_by_pk?: Maybe<LaplaceBorrowDepositHourlyStats>;
  /** fetch data from the table: "laplace.borrow_deposit_stats" */
  laplace_borrow_deposit_stats: Array<LaplaceBorrowDepositStats>;
  /** fetch aggregated fields from the table: "laplace.borrow_deposit_stats" */
  laplace_borrow_deposit_stats_aggregate: LaplaceBorrowDepositStatsAggregate;
  /** fetch data from the table: "laplace.borrow_deposit_stats" using primary key columns */
  laplace_borrow_deposit_stats_by_pk?: Maybe<LaplaceBorrowDepositStats>;
  /** fetch data from the table: "laplace.coin_gecko" */
  laplace_coin_gecko: Array<LaplaceCoinGecko>;
  /** fetch aggregated fields from the table: "laplace.coin_gecko" */
  laplace_coin_gecko_aggregate: LaplaceCoinGeckoAggregate;
  /** fetch data from the table: "laplace.coin_gecko_archive" */
  laplace_coin_gecko_archive: Array<LaplaceCoinGeckoArchive>;
  /** fetch aggregated fields from the table: "laplace.coin_gecko_archive" */
  laplace_coin_gecko_archive_aggregate: LaplaceCoinGeckoArchiveAggregate;
  /** fetch data from the table: "laplace.coin_gecko_archive" using primary key columns */
  laplace_coin_gecko_archive_by_pk?: Maybe<LaplaceCoinGeckoArchive>;
  /** fetch data from the table: "laplace.coin_gecko" using primary key columns */
  laplace_coin_gecko_by_pk?: Maybe<LaplaceCoinGecko>;
  /** fetch data from the table: "laplace.collateral_rebalancing_pool" */
  laplace_collateral_rebalancing_pool: Array<LaplaceCollateralRebalancingPool>;
  /** fetch aggregated fields from the table: "laplace.collateral_rebalancing_pool" */
  laplace_collateral_rebalancing_pool_aggregate: LaplaceCollateralRebalancingPoolAggregate;
  /** fetch data from the table: "laplace.collateral_rebalancing_pool" using primary key columns */
  laplace_collateral_rebalancing_pool_by_pk?: Maybe<LaplaceCollateralRebalancingPool>;
  /** fetch data from the table: "laplace.config_contracts" */
  laplace_config_contracts: Array<LaplaceConfigContracts>;
  /** fetch aggregated fields from the table: "laplace.config_contracts" */
  laplace_config_contracts_aggregate: LaplaceConfigContractsAggregate;
  /** fetch data from the table: "laplace.config_contracts" using primary key columns */
  laplace_config_contracts_by_pk?: Maybe<LaplaceConfigContracts>;
  /** fetch data from the table: "laplace.contract_calls" */
  laplace_contract_calls: Array<LaplaceContractCalls>;
  /** fetch aggregated fields from the table: "laplace.contract_calls" */
  laplace_contract_calls_aggregate: LaplaceContractCallsAggregate;
  /** fetch data from the table: "laplace.contract_calls" using primary key columns */
  laplace_contract_calls_by_pk?: Maybe<LaplaceContractCalls>;
  /** fetch data from the table: "laplace.current_token_price" */
  laplace_current_token_price: Array<LaplaceCurrentTokenPrice>;
  /** fetch aggregated fields from the table: "laplace.current_token_price" */
  laplace_current_token_price_aggregate: LaplaceCurrentTokenPriceAggregate;
  /** fetch data from the table: "laplace.deployed_contracts" */
  laplace_deployed_contracts: Array<LaplaceDeployedContracts>;
  /** fetch aggregated fields from the table: "laplace.deployed_contracts" */
  laplace_deployed_contracts_aggregate: LaplaceDeployedContractsAggregate;
  /** fetch data from the table: "laplace.deployed_contracts" using primary key columns */
  laplace_deployed_contracts_by_pk?: Maybe<LaplaceDeployedContracts>;
  /** fetch data from the table: "laplace.external_token_price" */
  laplace_external_token_price: Array<LaplaceExternalTokenPrice>;
  /** fetch aggregated fields from the table: "laplace.external_token_price" */
  laplace_external_token_price_aggregate: LaplaceExternalTokenPriceAggregate;
  /** fetch data from the table: "laplace.external_token_price" using primary key columns */
  laplace_external_token_price_by_pk?: Maybe<LaplaceExternalTokenPrice>;
  /** fetch data from the table: "laplace.fixed_weight_pool_v1_01" */
  laplace_fixed_weight_pool_v1_01: Array<LaplaceFixedWeightPoolV1_01>;
  /** fetch aggregated fields from the table: "laplace.fixed_weight_pool_v1_01" */
  laplace_fixed_weight_pool_v1_01_aggregate: LaplaceFixedWeightPoolV1_01Aggregate;
  /** fetch data from the table: "laplace.fixed_weight_pool_v1_01" using primary key columns */
  laplace_fixed_weight_pool_v1_01_by_pk?: Maybe<LaplaceFixedWeightPoolV1_01>;
  /** fetch data from the table: "laplace.history_price_data" */
  laplace_history_price_data: Array<LaplaceHistoryPriceData>;
  /** fetch aggregated fields from the table: "laplace.history_price_data" */
  laplace_history_price_data_aggregate: LaplaceHistoryPriceDataAggregate;
  /** fetch data from the table: "laplace.history_price_data" using primary key columns */
  laplace_history_price_data_by_pk?: Maybe<LaplaceHistoryPriceData>;
  /** fetch data from the table: "laplace.history_staking_stats" */
  laplace_history_staking_stats: Array<LaplaceHistoryStakingStats>;
  /** fetch aggregated fields from the table: "laplace.history_staking_stats" */
  laplace_history_staking_stats_aggregate: LaplaceHistoryStakingStatsAggregate;
  /** fetch data from the table: "laplace.history_staking_stats" using primary key columns */
  laplace_history_staking_stats_by_pk?: Maybe<LaplaceHistoryStakingStats>;
  /** fetch data from the table: "laplace.ido_pool_creation" */
  laplace_ido_pool_creation: Array<LaplaceIdoPoolCreation>;
  /** fetch aggregated fields from the table: "laplace.ido_pool_creation" */
  laplace_ido_pool_creation_aggregate: LaplaceIdoPoolCreationAggregate;
  /** fetch data from the table: "laplace.ido_pool_creation" using primary key columns */
  laplace_ido_pool_creation_by_pk?: Maybe<LaplaceIdoPoolCreation>;
  /** fetch data from the table: "laplace.ido_register" */
  laplace_ido_register: Array<LaplaceIdoRegister>;
  /** fetch aggregated fields from the table: "laplace.ido_register" */
  laplace_ido_register_aggregate: LaplaceIdoRegisterAggregate;
  /** fetch data from the table: "laplace.ido_register" using primary key columns */
  laplace_ido_register_by_pk?: Maybe<LaplaceIdoRegister>;
  /** fetch data from the table: "laplace.latest_alex_reserve_pools" */
  laplace_latest_alex_reserve_pools: Array<LaplaceLatestAlexReservePools>;
  /** fetch aggregated fields from the table: "laplace.latest_alex_reserve_pools" */
  laplace_latest_alex_reserve_pools_aggregate: LaplaceLatestAlexReservePoolsAggregate;
  /** fetch data from the table: "laplace.latest_alex_reserve_pools" using primary key columns */
  laplace_latest_alex_reserve_pools_by_pk?: Maybe<LaplaceLatestAlexReservePools>;
  /** fetch data from the table: "laplace.latest_auto_alex" */
  laplace_latest_auto_alex: Array<LaplaceLatestAutoAlex>;
  /** fetch aggregated fields from the table: "laplace.latest_auto_alex" */
  laplace_latest_auto_alex_aggregate: LaplaceLatestAutoAlexAggregate;
  /** fetch data from the table: "laplace.latest_auto_alex" using primary key columns */
  laplace_latest_auto_alex_by_pk?: Maybe<LaplaceLatestAutoAlex>;
  /** fetch data from the table: "laplace.latest_collateral_per_share" */
  laplace_latest_collateral_per_share: Array<LaplaceLatestCollateralPerShare>;
  /** fetch aggregated fields from the table: "laplace.latest_collateral_per_share" */
  laplace_latest_collateral_per_share_aggregate: LaplaceLatestCollateralPerShareAggregate;
  /** fetch data from the table: "laplace.latest_collateral_per_share" using primary key columns */
  laplace_latest_collateral_per_share_by_pk?: Maybe<LaplaceLatestCollateralPerShare>;
  /** fetch data from the table: "laplace.latest_collateral_rebalancing_pool" */
  laplace_latest_collateral_rebalancing_pool: Array<LaplaceLatestCollateralRebalancingPool>;
  /** fetch aggregated fields from the table: "laplace.latest_collateral_rebalancing_pool" */
  laplace_latest_collateral_rebalancing_pool_aggregate: LaplaceLatestCollateralRebalancingPoolAggregate;
  /** fetch data from the table: "laplace.latest_collateral_rebalancing_pool" using primary key columns */
  laplace_latest_collateral_rebalancing_pool_by_pk?: Maybe<LaplaceLatestCollateralRebalancingPool>;
  /** fetch data from the table: "laplace.latest_fixed_weight_pool_v1_01" */
  laplace_latest_fixed_weight_pool_v1_01: Array<LaplaceLatestFixedWeightPoolV1_01>;
  /** fetch aggregated fields from the table: "laplace.latest_fixed_weight_pool_v1_01" */
  laplace_latest_fixed_weight_pool_v1_01_aggregate: LaplaceLatestFixedWeightPoolV1_01Aggregate;
  /** fetch data from the table: "laplace.latest_fixed_weight_pool_v1_01" using primary key columns */
  laplace_latest_fixed_weight_pool_v1_01_by_pk?: Maybe<LaplaceLatestFixedWeightPoolV1_01>;
  /** fetch data from the table: "laplace.latest_pool_stats" */
  laplace_latest_pool_stats: Array<LaplaceLatestPoolStats>;
  /** fetch aggregated fields from the table: "laplace.latest_pool_stats" */
  laplace_latest_pool_stats_aggregate: LaplaceLatestPoolStatsAggregate;
  /** fetch data from the table: "laplace.latest_pool_stats" using primary key columns */
  laplace_latest_pool_stats_by_pk?: Maybe<LaplaceLatestPoolStats>;
  /** fetch data from the table: "laplace.latest_simple_weight_pool_alex" */
  laplace_latest_simple_weight_pool_alex: Array<LaplaceLatestSimpleWeightPoolAlex>;
  /** fetch aggregated fields from the table: "laplace.latest_simple_weight_pool_alex" */
  laplace_latest_simple_weight_pool_alex_aggregate: LaplaceLatestSimpleWeightPoolAlexAggregate;
  /** fetch data from the table: "laplace.latest_simple_weight_pool_alex" using primary key columns */
  laplace_latest_simple_weight_pool_alex_by_pk?: Maybe<LaplaceLatestSimpleWeightPoolAlex>;
  /** fetch data from the table: "laplace.latest_yield_token_pool" */
  laplace_latest_yield_token_pool: Array<LaplaceLatestYieldTokenPool>;
  /** fetch aggregated fields from the table: "laplace.latest_yield_token_pool" */
  laplace_latest_yield_token_pool_aggregate: LaplaceLatestYieldTokenPoolAggregate;
  /** fetch data from the table: "laplace.latest_yield_token_pool" using primary key columns */
  laplace_latest_yield_token_pool_by_pk?: Maybe<LaplaceLatestYieldTokenPool>;
  /** fetch data from the table: "laplace.oracle_instant_price" */
  laplace_oracle_instant_price: Array<LaplaceOracleInstantPrice>;
  /** fetch aggregated fields from the table: "laplace.oracle_instant_price" */
  laplace_oracle_instant_price_aggregate: LaplaceOracleInstantPriceAggregate;
  /** fetch data from the table: "laplace.oracle_instant_price" using primary key columns */
  laplace_oracle_instant_price_by_pk?: Maybe<LaplaceOracleInstantPrice>;
  /** fetch data from the table: "laplace.oracle_resilient_price" */
  laplace_oracle_resilient_price: Array<LaplaceOracleResilientPrice>;
  /** fetch aggregated fields from the table: "laplace.oracle_resilient_price" */
  laplace_oracle_resilient_price_aggregate: LaplaceOracleResilientPriceAggregate;
  /** fetch data from the table: "laplace.oracle_resilient_price" using primary key columns */
  laplace_oracle_resilient_price_by_pk?: Maybe<LaplaceOracleResilientPrice>;
  /** fetch data from the table: "laplace.oracle_token_price" */
  laplace_oracle_token_price: Array<LaplaceOracleTokenPrice>;
  /** fetch aggregated fields from the table: "laplace.oracle_token_price" */
  laplace_oracle_token_price_aggregate: LaplaceOracleTokenPriceAggregate;
  /** fetch data from the table: "laplace.oracle_token_price_resilient" */
  laplace_oracle_token_price_resilient: Array<LaplaceOracleTokenPriceResilient>;
  /** fetch aggregated fields from the table: "laplace.oracle_token_price_resilient" */
  laplace_oracle_token_price_resilient_aggregate: LaplaceOracleTokenPriceResilientAggregate;
  /** fetch data from the table: "laplace.pool_stats" */
  laplace_pool_stats: Array<LaplacePoolStats>;
  /** fetch aggregated fields from the table: "laplace.pool_stats" */
  laplace_pool_stats_aggregate: LaplacePoolStatsAggregate;
  /** fetch data from the table: "laplace.pool_stats" using primary key columns */
  laplace_pool_stats_by_pk?: Maybe<LaplacePoolStats>;
  /** fetch data from the table: "laplace.reward_cycle_stats" */
  laplace_reward_cycle_stats: Array<LaplaceRewardCycleStats>;
  /** fetch aggregated fields from the table: "laplace.reward_cycle_stats" */
  laplace_reward_cycle_stats_aggregate: LaplaceRewardCycleStatsAggregate;
  /** fetch data from the table: "laplace.reward_cycle_stats" using primary key columns */
  laplace_reward_cycle_stats_by_pk?: Maybe<LaplaceRewardCycleStats>;
  /** fetch data from the table: "laplace.simple_weight_pool_alex" */
  laplace_simple_weight_pool_alex: Array<LaplaceSimpleWeightPoolAlex>;
  /** fetch aggregated fields from the table: "laplace.simple_weight_pool_alex" */
  laplace_simple_weight_pool_alex_aggregate: LaplaceSimpleWeightPoolAlexAggregate;
  /** fetch data from the table: "laplace.simple_weight_pool_alex" using primary key columns */
  laplace_simple_weight_pool_alex_by_pk?: Maybe<LaplaceSimpleWeightPoolAlex>;
  /** fetch data from the table: "laplace.stacks_blockchain_events" */
  laplace_stacks_blockchain_events: Array<LaplaceStacksBlockchainEvents>;
  /** fetch aggregated fields from the table: "laplace.stacks_blockchain_events" */
  laplace_stacks_blockchain_events_aggregate: LaplaceStacksBlockchainEventsAggregate;
  /** fetch data from the table: "laplace.swap_records" */
  laplace_swap_records: Array<LaplaceSwapRecords>;
  /** fetch aggregated fields from the table: "laplace.swap_records" */
  laplace_swap_records_aggregate: LaplaceSwapRecordsAggregate;
  /** fetch data from the table: "laplace.swap_records" using primary key columns */
  laplace_swap_records_by_pk?: Maybe<LaplaceSwapRecords>;
  /** fetch data from the table: "laplace.sync_status" */
  laplace_sync_status: Array<LaplaceSyncStatus>;
  /** fetch aggregated fields from the table: "laplace.sync_status" */
  laplace_sync_status_aggregate: LaplaceSyncStatusAggregate;
  /** fetch data from the table: "laplace.sync_status" using primary key columns */
  laplace_sync_status_by_pk?: Maybe<LaplaceSyncStatus>;
  /** fetch data from the table: "laplace.synced_blocks" */
  laplace_synced_blocks: Array<LaplaceSyncedBlocks>;
  /** fetch aggregated fields from the table: "laplace.synced_blocks" */
  laplace_synced_blocks_aggregate: LaplaceSyncedBlocksAggregate;
  /** fetch data from the table: "laplace.synced_blocks" using primary key columns */
  laplace_synced_blocks_by_pk?: Maybe<LaplaceSyncedBlocks>;
  /** fetch data from the table: "laplace.token_stats" */
  laplace_token_stats: Array<LaplaceTokenStats>;
  /** fetch aggregated fields from the table: "laplace.token_stats" */
  laplace_token_stats_aggregate: LaplaceTokenStatsAggregate;
  /** fetch data from the table: "laplace.token_stats" using primary key columns */
  laplace_token_stats_by_pk?: Maybe<LaplaceTokenStats>;
  /** fetch data from the table: "laplace.token_tvl" */
  laplace_token_tvl: Array<LaplaceTokenTvl>;
  /** fetch aggregated fields from the table: "laplace.token_tvl" */
  laplace_token_tvl_aggregate: LaplaceTokenTvlAggregate;
  /** fetch data from the table: "laplace.token_tvl" using primary key columns */
  laplace_token_tvl_by_pk?: Maybe<LaplaceTokenTvl>;
  /** fetch data from the table: "laplace.yield_token_pool" */
  laplace_yield_token_pool: Array<LaplaceYieldTokenPool>;
  /** fetch aggregated fields from the table: "laplace.yield_token_pool" */
  laplace_yield_token_pool_aggregate: LaplaceYieldTokenPoolAggregate;
  /** fetch data from the table: "laplace.yield_token_pool" using primary key columns */
  laplace_yield_token_pool_by_pk?: Maybe<LaplaceYieldTokenPool>;
  lockdrop?: Maybe<Lockdrop>;
  lockdropCollection?: Maybe<LockdropCollection>;
  longText?: Maybe<LongText>;
  longTextCollection?: Maybe<LongTextCollection>;
  /** fetch data from the table: "public_dbt.autoalex_apower_distribution" */
  public_dbt_autoalex_apower_distribution: Array<PublicDbtAutoalexApowerDistribution>;
  /** fetch aggregated fields from the table: "public_dbt.autoalex_apower_distribution" */
  public_dbt_autoalex_apower_distribution_aggregate: PublicDbtAutoalexApowerDistributionAggregate;
  /** fetch data from the table: "public_dbt.autoalex_claim_and_stake" */
  public_dbt_autoalex_claim_and_stake: Array<PublicDbtAutoalexClaimAndStake>;
  /** fetch aggregated fields from the table: "public_dbt.autoalex_claim_and_stake" */
  public_dbt_autoalex_claim_and_stake_aggregate: PublicDbtAutoalexClaimAndStakeAggregate;
  /** fetch data from the table: "public_dbt.autoalex_lockdrop_snapshot_config" */
  public_dbt_autoalex_lockdrop_snapshot_config: Array<PublicDbtAutoalexLockdropSnapshotConfig>;
  /** fetch aggregated fields from the table: "public_dbt.autoalex_lockdrop_snapshot_config" */
  public_dbt_autoalex_lockdrop_snapshot_config_aggregate: PublicDbtAutoalexLockdropSnapshotConfigAggregate;
  /** fetch data from the table: "public_dbt.autoalex_snapshot_config" */
  public_dbt_autoalex_snapshot_config: Array<PublicDbtAutoalexSnapshotConfig>;
  /** fetch aggregated fields from the table: "public_dbt.autoalex_snapshot_config" */
  public_dbt_autoalex_snapshot_config_aggregate: PublicDbtAutoalexSnapshotConfigAggregate;
  /** fetch data from the table: "public_dbt.dim_autoalex_apower_cycle_reward_status" */
  public_dbt_dim_autoalex_apower_cycle_reward_status: Array<PublicDbtDimAutoalexApowerCycleRewardStatus>;
  /** fetch aggregated fields from the table: "public_dbt.dim_autoalex_apower_cycle_reward_status" */
  public_dbt_dim_autoalex_apower_cycle_reward_status_aggregate: PublicDbtDimAutoalexApowerCycleRewardStatusAggregate;
  /** fetch data from the table: "public_dbt.dim_balance_alex_staked_lockdrop_offets" */
  public_dbt_dim_balance_alex_staked_lockdrop_offets: Array<PublicDbtDimBalanceAlexStakedLockdropOffets>;
  /** fetch aggregated fields from the table: "public_dbt.dim_balance_alex_staked_lockdrop_offets" */
  public_dbt_dim_balance_alex_staked_lockdrop_offets_aggregate: PublicDbtDimBalanceAlexStakedLockdropOffetsAggregate;
  /** fetch data from the table: "public_dbt.dim_balance_autoalex_apower_distribution" */
  public_dbt_dim_balance_autoalex_apower_distribution: Array<PublicDbtDimBalanceAutoalexApowerDistribution>;
  /** fetch aggregated fields from the table: "public_dbt.dim_balance_autoalex_apower_distribution" */
  public_dbt_dim_balance_autoalex_apower_distribution_aggregate: PublicDbtDimBalanceAutoalexApowerDistributionAggregate;
  /** fetch data from the table: "public_dbt.dim_balance_autoalex_lockdrop2_rank_snapshot_view" */
  public_dbt_dim_balance_autoalex_lockdrop2_rank_snapshot_view: Array<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotView>;
  /** fetch aggregated fields from the table: "public_dbt.dim_balance_autoalex_lockdrop2_rank_snapshot_view" */
  public_dbt_dim_balance_autoalex_lockdrop2_rank_snapshot_view_aggregate: PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewAggregate;
  /** fetch data from the table: "public_dbt.dim_balance_autoalex_lockdrop2_rank_view" */
  public_dbt_dim_balance_autoalex_lockdrop2_rank_view: Array<PublicDbtDimBalanceAutoalexLockdrop2RankView>;
  /** fetch aggregated fields from the table: "public_dbt.dim_balance_autoalex_lockdrop2_rank_view" */
  public_dbt_dim_balance_autoalex_lockdrop2_rank_view_aggregate: PublicDbtDimBalanceAutoalexLockdrop2RankViewAggregate;
  /** fetch data from the table: "public_dbt.dim_balance_autoalex_rank_on_height_view" */
  public_dbt_dim_balance_autoalex_rank_on_height_view: Array<PublicDbtDimBalanceAutoalexRankOnHeightView>;
  /** fetch aggregated fields from the table: "public_dbt.dim_balance_autoalex_rank_on_height_view" */
  public_dbt_dim_balance_autoalex_rank_on_height_view_aggregate: PublicDbtDimBalanceAutoalexRankOnHeightViewAggregate;
  /** fetch data from the table: "public_dbt.dim_balance_autoalex_rank_snapshot_view" */
  public_dbt_dim_balance_autoalex_rank_snapshot_view: Array<PublicDbtDimBalanceAutoalexRankSnapshotView>;
  /** fetch aggregated fields from the table: "public_dbt.dim_balance_autoalex_rank_snapshot_view" */
  public_dbt_dim_balance_autoalex_rank_snapshot_view_aggregate: PublicDbtDimBalanceAutoalexRankSnapshotViewAggregate;
  /** fetch data from the table: "public_dbt.dim_balance_autoalex_rank_view" */
  public_dbt_dim_balance_autoalex_rank_view: Array<PublicDbtDimBalanceAutoalexRankView>;
  /** fetch aggregated fields from the table: "public_dbt.dim_balance_autoalex_rank_view" */
  public_dbt_dim_balance_autoalex_rank_view_aggregate: PublicDbtDimBalanceAutoalexRankViewAggregate;
  /** fetch data from the table: "public_dbt.dim_idos_info" */
  public_dbt_dim_idos_info: Array<PublicDbtDimIdosInfo>;
  /** fetch aggregated fields from the table: "public_dbt.dim_idos_info" */
  public_dbt_dim_idos_info_aggregate: PublicDbtDimIdosInfoAggregate;
  /** fetch data from the table: "smart_contracts" */
  smart_contracts: Array<SmartContracts>;
  /** fetch aggregated fields from the table: "smart_contracts" */
  smart_contracts_aggregate: SmartContractsAggregate;
  /** fetch data from the table: "smart_contracts" using primary key columns */
  smart_contracts_by_pk?: Maybe<SmartContracts>;
  /** fetch data from the table: "stx_events" */
  stx_events: Array<StxEvents>;
  /** fetch aggregated fields from the table: "stx_events" */
  stx_events_aggregate: StxEventsAggregate;
  /** fetch data from the table: "stx_events" using primary key columns */
  stx_events_by_pk?: Maybe<StxEvents>;
  token?: Maybe<Token>;
  tokenCollection?: Maybe<TokenCollection>;
  tokenListItem?: Maybe<TokenListItem>;
  tokenListItemCollection?: Maybe<TokenListItemCollection>;
  /** fetch data from the table: "txs" */
  txs: Array<Txs>;
  /** fetch aggregated fields from the table: "txs" */
  txs_aggregate: TxsAggregate;
  /** fetch data from the table: "txs" using primary key columns */
  txs_by_pk?: Maybe<Txs>;
};


export type QueryRootAnalyticsTabsArgs = {
  id: Scalars['String'];
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
};


export type QueryRootAnalyticsTabsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  order?: InputMaybe<Array<InputMaybe<AnalyticsTabsOrder>>>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AnalyticsTabsFilter>;
};


export type QueryRootAppConfigArgs = {
  id: Scalars['String'];
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
};


export type QueryRootAppConfigCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  order?: InputMaybe<Array<InputMaybe<AppConfigOrder>>>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AppConfigFilter>;
};


export type QueryRootAssetArgs = {
  id: Scalars['String'];
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
};


export type QueryRootAssetCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  order?: InputMaybe<Array<InputMaybe<AssetOrder>>>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AssetFilter>;
};


export type QueryRootBannerArgs = {
  id: Scalars['String'];
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
};


export type QueryRootBannerCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  order?: InputMaybe<Array<InputMaybe<BannerOrder>>>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<BannerFilter>;
};


export type QueryRootBlocksArgs = {
  distinct_on?: InputMaybe<Array<BlocksSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<BlocksOrderBy>>;
  where?: InputMaybe<BlocksBoolExp>;
};


export type QueryRootBlocksAggregateArgs = {
  distinct_on?: InputMaybe<Array<BlocksSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<BlocksOrderBy>>;
  where?: InputMaybe<BlocksBoolExp>;
};


export type QueryRootBlocksByPkArgs = {
  index_block_hash: Scalars['bytea'];
};


export type QueryRootContractLogsArgs = {
  distinct_on?: InputMaybe<Array<ContractLogsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<ContractLogsOrderBy>>;
  where?: InputMaybe<ContractLogsBoolExp>;
};


export type QueryRootContractLogsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ContractLogsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<ContractLogsOrderBy>>;
  where?: InputMaybe<ContractLogsBoolExp>;
};


export type QueryRootContractLogsByPkArgs = {
  id: Scalars['Int'];
};


export type QueryRootEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  order?: InputMaybe<Array<InputMaybe<EntryOrder>>>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<EntryFilter>;
};


export type QueryRootFtEventsArgs = {
  distinct_on?: InputMaybe<Array<FtEventsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<FtEventsOrderBy>>;
  where?: InputMaybe<FtEventsBoolExp>;
};


export type QueryRootFtEventsAggregateArgs = {
  distinct_on?: InputMaybe<Array<FtEventsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<FtEventsOrderBy>>;
  where?: InputMaybe<FtEventsBoolExp>;
};


export type QueryRootFtEventsByPkArgs = {
  id: Scalars['Int'];
};


export type QueryRootGetCrpSimulationArgs = {
  args: CrpSimulationInput;
};


export type QueryRootIdoArgs = {
  id: Scalars['String'];
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
};


export type QueryRootIdoCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  order?: InputMaybe<Array<InputMaybe<IdoOrder>>>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<IdoFilter>;
};


export type QueryRootLaplaceAlexReservePoolsArgs = {
  distinct_on?: InputMaybe<Array<LaplaceAlexReservePoolsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceAlexReservePoolsOrderBy>>;
  where?: InputMaybe<LaplaceAlexReservePoolsBoolExp>;
};


export type QueryRootLaplaceAlexReservePoolsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceAlexReservePoolsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceAlexReservePoolsOrderBy>>;
  where?: InputMaybe<LaplaceAlexReservePoolsBoolExp>;
};


export type QueryRootLaplaceAlexReservePoolsByPkArgs = {
  block_height: Scalars['Int'];
  token_deployer_address: Scalars['String'];
  token_name: Scalars['String'];
};


export type QueryRootLaplaceAlexUsdPricingArgs = {
  distinct_on?: InputMaybe<Array<LaplaceAlexUsdPricingSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceAlexUsdPricingOrderBy>>;
  where?: InputMaybe<LaplaceAlexUsdPricingBoolExp>;
};


export type QueryRootLaplaceAlexUsdPricingAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceAlexUsdPricingSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceAlexUsdPricingOrderBy>>;
  where?: InputMaybe<LaplaceAlexUsdPricingBoolExp>;
};


export type QueryRootLaplaceBorrowDepositDailyStatsArgs = {
  distinct_on?: InputMaybe<Array<LaplaceBorrowDepositDailyStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceBorrowDepositDailyStatsOrderBy>>;
  where?: InputMaybe<LaplaceBorrowDepositDailyStatsBoolExp>;
};


export type QueryRootLaplaceBorrowDepositDailyStatsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceBorrowDepositDailyStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceBorrowDepositDailyStatsOrderBy>>;
  where?: InputMaybe<LaplaceBorrowDepositDailyStatsBoolExp>;
};


export type QueryRootLaplaceBorrowDepositDailyStatsByPkArgs = {
  day: Scalars['numeric'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};


export type QueryRootLaplaceBorrowDepositHourlyStatsArgs = {
  distinct_on?: InputMaybe<Array<LaplaceBorrowDepositHourlyStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceBorrowDepositHourlyStatsOrderBy>>;
  where?: InputMaybe<LaplaceBorrowDepositHourlyStatsBoolExp>;
};


export type QueryRootLaplaceBorrowDepositHourlyStatsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceBorrowDepositHourlyStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceBorrowDepositHourlyStatsOrderBy>>;
  where?: InputMaybe<LaplaceBorrowDepositHourlyStatsBoolExp>;
};


export type QueryRootLaplaceBorrowDepositHourlyStatsByPkArgs = {
  expiry: Scalars['numeric'];
  hour: Scalars['numeric'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};


export type QueryRootLaplaceBorrowDepositStatsArgs = {
  distinct_on?: InputMaybe<Array<LaplaceBorrowDepositStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceBorrowDepositStatsOrderBy>>;
  where?: InputMaybe<LaplaceBorrowDepositStatsBoolExp>;
};


export type QueryRootLaplaceBorrowDepositStatsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceBorrowDepositStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceBorrowDepositStatsOrderBy>>;
  where?: InputMaybe<LaplaceBorrowDepositStatsBoolExp>;
};


export type QueryRootLaplaceBorrowDepositStatsByPkArgs = {
  block_height: Scalars['numeric'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};


export type QueryRootLaplaceCoinGeckoArgs = {
  distinct_on?: InputMaybe<Array<LaplaceCoinGeckoSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceCoinGeckoOrderBy>>;
  where?: InputMaybe<LaplaceCoinGeckoBoolExp>;
};


export type QueryRootLaplaceCoinGeckoAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceCoinGeckoSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceCoinGeckoOrderBy>>;
  where?: InputMaybe<LaplaceCoinGeckoBoolExp>;
};


export type QueryRootLaplaceCoinGeckoArchiveArgs = {
  distinct_on?: InputMaybe<Array<LaplaceCoinGeckoArchiveSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceCoinGeckoArchiveOrderBy>>;
  where?: InputMaybe<LaplaceCoinGeckoArchiveBoolExp>;
};


export type QueryRootLaplaceCoinGeckoArchiveAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceCoinGeckoArchiveSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceCoinGeckoArchiveOrderBy>>;
  where?: InputMaybe<LaplaceCoinGeckoArchiveBoolExp>;
};


export type QueryRootLaplaceCoinGeckoArchiveByPkArgs = {
  timestamp: Scalars['timestamptz'];
  token: Scalars['String'];
};


export type QueryRootLaplaceCoinGeckoByPkArgs = {
  token: Scalars['String'];
};


export type QueryRootLaplaceCollateralRebalancingPoolArgs = {
  distinct_on?: InputMaybe<Array<LaplaceCollateralRebalancingPoolSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceCollateralRebalancingPoolOrderBy>>;
  where?: InputMaybe<LaplaceCollateralRebalancingPoolBoolExp>;
};


export type QueryRootLaplaceCollateralRebalancingPoolAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceCollateralRebalancingPoolSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceCollateralRebalancingPoolOrderBy>>;
  where?: InputMaybe<LaplaceCollateralRebalancingPoolBoolExp>;
};


export type QueryRootLaplaceCollateralRebalancingPoolByPkArgs = {
  block_height: Scalars['numeric'];
  expiry: Scalars['numeric'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};


export type QueryRootLaplaceConfigContractsArgs = {
  distinct_on?: InputMaybe<Array<LaplaceConfigContractsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceConfigContractsOrderBy>>;
  where?: InputMaybe<LaplaceConfigContractsBoolExp>;
};


export type QueryRootLaplaceConfigContractsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceConfigContractsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceConfigContractsOrderBy>>;
  where?: InputMaybe<LaplaceConfigContractsBoolExp>;
};


export type QueryRootLaplaceConfigContractsByPkArgs = {
  contract: Scalars['String'];
};


export type QueryRootLaplaceContractCallsArgs = {
  distinct_on?: InputMaybe<Array<LaplaceContractCallsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceContractCallsOrderBy>>;
  where?: InputMaybe<LaplaceContractCallsBoolExp>;
};


export type QueryRootLaplaceContractCallsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceContractCallsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceContractCallsOrderBy>>;
  where?: InputMaybe<LaplaceContractCallsBoolExp>;
};


export type QueryRootLaplaceContractCallsByPkArgs = {
  block_height: Scalars['Int'];
  tx_id: Scalars['bytea'];
};


export type QueryRootLaplaceCurrentTokenPriceArgs = {
  distinct_on?: InputMaybe<Array<LaplaceCurrentTokenPriceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceCurrentTokenPriceOrderBy>>;
  where?: InputMaybe<LaplaceCurrentTokenPriceBoolExp>;
};


export type QueryRootLaplaceCurrentTokenPriceAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceCurrentTokenPriceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceCurrentTokenPriceOrderBy>>;
  where?: InputMaybe<LaplaceCurrentTokenPriceBoolExp>;
};


export type QueryRootLaplaceDeployedContractsArgs = {
  distinct_on?: InputMaybe<Array<LaplaceDeployedContractsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceDeployedContractsOrderBy>>;
  where?: InputMaybe<LaplaceDeployedContractsBoolExp>;
};


export type QueryRootLaplaceDeployedContractsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceDeployedContractsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceDeployedContractsOrderBy>>;
  where?: InputMaybe<LaplaceDeployedContractsBoolExp>;
};


export type QueryRootLaplaceDeployedContractsByPkArgs = {
  contract_name: Scalars['String'];
  deployer_address: Scalars['String'];
  tx_id: Scalars['String'];
};


export type QueryRootLaplaceExternalTokenPriceArgs = {
  distinct_on?: InputMaybe<Array<LaplaceExternalTokenPriceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceExternalTokenPriceOrderBy>>;
  where?: InputMaybe<LaplaceExternalTokenPriceBoolExp>;
};


export type QueryRootLaplaceExternalTokenPriceAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceExternalTokenPriceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceExternalTokenPriceOrderBy>>;
  where?: InputMaybe<LaplaceExternalTokenPriceBoolExp>;
};


export type QueryRootLaplaceExternalTokenPriceByPkArgs = {
  token_name: Scalars['String'];
};


export type QueryRootLaplaceFixedWeightPoolV1_01Args = {
  distinct_on?: InputMaybe<Array<LaplaceFixedWeightPoolV1_01SelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceFixedWeightPoolV1_01OrderBy>>;
  where?: InputMaybe<LaplaceFixedWeightPoolV1_01BoolExp>;
};


export type QueryRootLaplaceFixedWeightPoolV1_01AggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceFixedWeightPoolV1_01SelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceFixedWeightPoolV1_01OrderBy>>;
  where?: InputMaybe<LaplaceFixedWeightPoolV1_01BoolExp>;
};


export type QueryRootLaplaceFixedWeightPoolV1_01ByPkArgs = {
  block_height: Scalars['Int'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
  weight_x: Scalars['bigint'];
  weight_y: Scalars['bigint'];
};


export type QueryRootLaplaceHistoryPriceDataArgs = {
  distinct_on?: InputMaybe<Array<LaplaceHistoryPriceDataSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceHistoryPriceDataOrderBy>>;
  where?: InputMaybe<LaplaceHistoryPriceDataBoolExp>;
};


export type QueryRootLaplaceHistoryPriceDataAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceHistoryPriceDataSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceHistoryPriceDataOrderBy>>;
  where?: InputMaybe<LaplaceHistoryPriceDataBoolExp>;
};


export type QueryRootLaplaceHistoryPriceDataByPkArgs = {
  block_height: Scalars['numeric'];
  token: Scalars['String'];
};


export type QueryRootLaplaceHistoryStakingStatsArgs = {
  distinct_on?: InputMaybe<Array<LaplaceHistoryStakingStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceHistoryStakingStatsOrderBy>>;
  where?: InputMaybe<LaplaceHistoryStakingStatsBoolExp>;
};


export type QueryRootLaplaceHistoryStakingStatsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceHistoryStakingStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceHistoryStakingStatsOrderBy>>;
  where?: InputMaybe<LaplaceHistoryStakingStatsBoolExp>;
};


export type QueryRootLaplaceHistoryStakingStatsByPkArgs = {
  cycle: Scalars['Int'];
  token: Scalars['String'];
};


export type QueryRootLaplaceIdoPoolCreationArgs = {
  distinct_on?: InputMaybe<Array<LaplaceIdoPoolCreationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceIdoPoolCreationOrderBy>>;
  where?: InputMaybe<LaplaceIdoPoolCreationBoolExp>;
};


export type QueryRootLaplaceIdoPoolCreationAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceIdoPoolCreationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceIdoPoolCreationOrderBy>>;
  where?: InputMaybe<LaplaceIdoPoolCreationBoolExp>;
};


export type QueryRootLaplaceIdoPoolCreationByPkArgs = {
  activation_threshold: Scalars['Int'];
  apower_per_ticket_in_fixed: Scalars['bigint'];
  claim_end_height: Scalars['Int'];
  ido_owner: Scalars['String'];
  ido_token: Scalars['String'];
  ido_tokens_per_ticket: Scalars['Int'];
  payment_token: Scalars['String'];
  registration_end_height: Scalars['Int'];
  registration_start_height: Scalars['Int'];
  tx_id: Scalars['String'];
};


export type QueryRootLaplaceIdoRegisterArgs = {
  distinct_on?: InputMaybe<Array<LaplaceIdoRegisterSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceIdoRegisterOrderBy>>;
  where?: InputMaybe<LaplaceIdoRegisterBoolExp>;
};


export type QueryRootLaplaceIdoRegisterAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceIdoRegisterSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceIdoRegisterOrderBy>>;
  where?: InputMaybe<LaplaceIdoRegisterBoolExp>;
};


export type QueryRootLaplaceIdoRegisterByPkArgs = {
  block_height: Scalars['Int'];
  tx_id: Scalars['bytea'];
};


export type QueryRootLaplaceLatestAlexReservePoolsArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestAlexReservePoolsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestAlexReservePoolsOrderBy>>;
  where?: InputMaybe<LaplaceLatestAlexReservePoolsBoolExp>;
};


export type QueryRootLaplaceLatestAlexReservePoolsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestAlexReservePoolsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestAlexReservePoolsOrderBy>>;
  where?: InputMaybe<LaplaceLatestAlexReservePoolsBoolExp>;
};


export type QueryRootLaplaceLatestAlexReservePoolsByPkArgs = {
  token_deployer_address: Scalars['String'];
  token_name: Scalars['String'];
};


export type QueryRootLaplaceLatestAutoAlexArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestAutoAlexSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestAutoAlexOrderBy>>;
  where?: InputMaybe<LaplaceLatestAutoAlexBoolExp>;
};


export type QueryRootLaplaceLatestAutoAlexAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestAutoAlexSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestAutoAlexOrderBy>>;
  where?: InputMaybe<LaplaceLatestAutoAlexBoolExp>;
};


export type QueryRootLaplaceLatestAutoAlexByPkArgs = {
  token_name: Scalars['String'];
};


export type QueryRootLaplaceLatestCollateralPerShareArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestCollateralPerShareSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestCollateralPerShareOrderBy>>;
  where?: InputMaybe<LaplaceLatestCollateralPerShareBoolExp>;
};


export type QueryRootLaplaceLatestCollateralPerShareAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestCollateralPerShareSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestCollateralPerShareOrderBy>>;
  where?: InputMaybe<LaplaceLatestCollateralPerShareBoolExp>;
};


export type QueryRootLaplaceLatestCollateralPerShareByPkArgs = {
  expiry: Scalars['numeric'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};


export type QueryRootLaplaceLatestCollateralRebalancingPoolArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestCollateralRebalancingPoolSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestCollateralRebalancingPoolOrderBy>>;
  where?: InputMaybe<LaplaceLatestCollateralRebalancingPoolBoolExp>;
};


export type QueryRootLaplaceLatestCollateralRebalancingPoolAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestCollateralRebalancingPoolSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestCollateralRebalancingPoolOrderBy>>;
  where?: InputMaybe<LaplaceLatestCollateralRebalancingPoolBoolExp>;
};


export type QueryRootLaplaceLatestCollateralRebalancingPoolByPkArgs = {
  expiry: Scalars['numeric'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};


export type QueryRootLaplaceLatestFixedWeightPoolV1_01Args = {
  distinct_on?: InputMaybe<Array<LaplaceLatestFixedWeightPoolV1_01SelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestFixedWeightPoolV1_01OrderBy>>;
  where?: InputMaybe<LaplaceLatestFixedWeightPoolV1_01BoolExp>;
};


export type QueryRootLaplaceLatestFixedWeightPoolV1_01AggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestFixedWeightPoolV1_01SelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestFixedWeightPoolV1_01OrderBy>>;
  where?: InputMaybe<LaplaceLatestFixedWeightPoolV1_01BoolExp>;
};


export type QueryRootLaplaceLatestFixedWeightPoolV1_01ByPkArgs = {
  token_x: Scalars['String'];
  token_y: Scalars['String'];
  weight_x: Scalars['bigint'];
  weight_y: Scalars['bigint'];
};


export type QueryRootLaplaceLatestPoolStatsArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestPoolStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestPoolStatsOrderBy>>;
  where?: InputMaybe<LaplaceLatestPoolStatsBoolExp>;
};


export type QueryRootLaplaceLatestPoolStatsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestPoolStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestPoolStatsOrderBy>>;
  where?: InputMaybe<LaplaceLatestPoolStatsBoolExp>;
};


export type QueryRootLaplaceLatestPoolStatsByPkArgs = {
  pool_token: Scalars['String'];
};


export type QueryRootLaplaceLatestSimpleWeightPoolAlexArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestSimpleWeightPoolAlexSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestSimpleWeightPoolAlexOrderBy>>;
  where?: InputMaybe<LaplaceLatestSimpleWeightPoolAlexBoolExp>;
};


export type QueryRootLaplaceLatestSimpleWeightPoolAlexAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestSimpleWeightPoolAlexSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestSimpleWeightPoolAlexOrderBy>>;
  where?: InputMaybe<LaplaceLatestSimpleWeightPoolAlexBoolExp>;
};


export type QueryRootLaplaceLatestSimpleWeightPoolAlexByPkArgs = {
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};


export type QueryRootLaplaceLatestYieldTokenPoolArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestYieldTokenPoolSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestYieldTokenPoolOrderBy>>;
  where?: InputMaybe<LaplaceLatestYieldTokenPoolBoolExp>;
};


export type QueryRootLaplaceLatestYieldTokenPoolAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestYieldTokenPoolSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestYieldTokenPoolOrderBy>>;
  where?: InputMaybe<LaplaceLatestYieldTokenPoolBoolExp>;
};


export type QueryRootLaplaceLatestYieldTokenPoolByPkArgs = {
  expiry: Scalars['numeric'];
  yield_token: Scalars['String'];
};


export type QueryRootLaplaceOracleInstantPriceArgs = {
  distinct_on?: InputMaybe<Array<LaplaceOracleInstantPriceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceOracleInstantPriceOrderBy>>;
  where?: InputMaybe<LaplaceOracleInstantPriceBoolExp>;
};


export type QueryRootLaplaceOracleInstantPriceAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceOracleInstantPriceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceOracleInstantPriceOrderBy>>;
  where?: InputMaybe<LaplaceOracleInstantPriceBoolExp>;
};


export type QueryRootLaplaceOracleInstantPriceByPkArgs = {
  block_height: Scalars['numeric'];
  pool_token: Scalars['String'];
  token: Scalars['String'];
};


export type QueryRootLaplaceOracleResilientPriceArgs = {
  distinct_on?: InputMaybe<Array<LaplaceOracleResilientPriceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceOracleResilientPriceOrderBy>>;
  where?: InputMaybe<LaplaceOracleResilientPriceBoolExp>;
};


export type QueryRootLaplaceOracleResilientPriceAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceOracleResilientPriceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceOracleResilientPriceOrderBy>>;
  where?: InputMaybe<LaplaceOracleResilientPriceBoolExp>;
};


export type QueryRootLaplaceOracleResilientPriceByPkArgs = {
  block_height: Scalars['numeric'];
  pool_token: Scalars['String'];
  token: Scalars['String'];
};


export type QueryRootLaplaceOracleTokenPriceArgs = {
  distinct_on?: InputMaybe<Array<LaplaceOracleTokenPriceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceOracleTokenPriceOrderBy>>;
  where?: InputMaybe<LaplaceOracleTokenPriceBoolExp>;
};


export type QueryRootLaplaceOracleTokenPriceAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceOracleTokenPriceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceOracleTokenPriceOrderBy>>;
  where?: InputMaybe<LaplaceOracleTokenPriceBoolExp>;
};


export type QueryRootLaplaceOracleTokenPriceResilientArgs = {
  distinct_on?: InputMaybe<Array<LaplaceOracleTokenPriceResilientSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceOracleTokenPriceResilientOrderBy>>;
  where?: InputMaybe<LaplaceOracleTokenPriceResilientBoolExp>;
};


export type QueryRootLaplaceOracleTokenPriceResilientAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceOracleTokenPriceResilientSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceOracleTokenPriceResilientOrderBy>>;
  where?: InputMaybe<LaplaceOracleTokenPriceResilientBoolExp>;
};


export type QueryRootLaplacePoolStatsArgs = {
  distinct_on?: InputMaybe<Array<LaplacePoolStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplacePoolStatsOrderBy>>;
  where?: InputMaybe<LaplacePoolStatsBoolExp>;
};


export type QueryRootLaplacePoolStatsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplacePoolStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplacePoolStatsOrderBy>>;
  where?: InputMaybe<LaplacePoolStatsBoolExp>;
};


export type QueryRootLaplacePoolStatsByPkArgs = {
  block_height: Scalars['numeric'];
  pool_token: Scalars['String'];
};


export type QueryRootLaplaceRewardCycleStatsArgs = {
  distinct_on?: InputMaybe<Array<LaplaceRewardCycleStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceRewardCycleStatsOrderBy>>;
  where?: InputMaybe<LaplaceRewardCycleStatsBoolExp>;
};


export type QueryRootLaplaceRewardCycleStatsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceRewardCycleStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceRewardCycleStatsOrderBy>>;
  where?: InputMaybe<LaplaceRewardCycleStatsBoolExp>;
};


export type QueryRootLaplaceRewardCycleStatsByPkArgs = {
  block_height: Scalars['bigint'];
  token: Scalars['String'];
};


export type QueryRootLaplaceSimpleWeightPoolAlexArgs = {
  distinct_on?: InputMaybe<Array<LaplaceSimpleWeightPoolAlexSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceSimpleWeightPoolAlexOrderBy>>;
  where?: InputMaybe<LaplaceSimpleWeightPoolAlexBoolExp>;
};


export type QueryRootLaplaceSimpleWeightPoolAlexAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceSimpleWeightPoolAlexSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceSimpleWeightPoolAlexOrderBy>>;
  where?: InputMaybe<LaplaceSimpleWeightPoolAlexBoolExp>;
};


export type QueryRootLaplaceSimpleWeightPoolAlexByPkArgs = {
  block_height: Scalars['Int'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};


export type QueryRootLaplaceStacksBlockchainEventsArgs = {
  distinct_on?: InputMaybe<Array<LaplaceStacksBlockchainEventsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceStacksBlockchainEventsOrderBy>>;
  where?: InputMaybe<LaplaceStacksBlockchainEventsBoolExp>;
};


export type QueryRootLaplaceStacksBlockchainEventsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceStacksBlockchainEventsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceStacksBlockchainEventsOrderBy>>;
  where?: InputMaybe<LaplaceStacksBlockchainEventsBoolExp>;
};


export type QueryRootLaplaceSwapRecordsArgs = {
  distinct_on?: InputMaybe<Array<LaplaceSwapRecordsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceSwapRecordsOrderBy>>;
  where?: InputMaybe<LaplaceSwapRecordsBoolExp>;
};


export type QueryRootLaplaceSwapRecordsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceSwapRecordsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceSwapRecordsOrderBy>>;
  where?: InputMaybe<LaplaceSwapRecordsBoolExp>;
};


export type QueryRootLaplaceSwapRecordsByPkArgs = {
  event_index: Scalars['numeric'];
  tx_id: Scalars['String'];
};


export type QueryRootLaplaceSyncStatusArgs = {
  distinct_on?: InputMaybe<Array<LaplaceSyncStatusSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceSyncStatusOrderBy>>;
  where?: InputMaybe<LaplaceSyncStatusBoolExp>;
};


export type QueryRootLaplaceSyncStatusAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceSyncStatusSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceSyncStatusOrderBy>>;
  where?: InputMaybe<LaplaceSyncStatusBoolExp>;
};


export type QueryRootLaplaceSyncStatusByPkArgs = {
  key: Scalars['String'];
};


export type QueryRootLaplaceSyncedBlocksArgs = {
  distinct_on?: InputMaybe<Array<LaplaceSyncedBlocksSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceSyncedBlocksOrderBy>>;
  where?: InputMaybe<LaplaceSyncedBlocksBoolExp>;
};


export type QueryRootLaplaceSyncedBlocksAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceSyncedBlocksSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceSyncedBlocksOrderBy>>;
  where?: InputMaybe<LaplaceSyncedBlocksBoolExp>;
};


export type QueryRootLaplaceSyncedBlocksByPkArgs = {
  block_height: Scalars['Int'];
};


export type QueryRootLaplaceTokenStatsArgs = {
  distinct_on?: InputMaybe<Array<LaplaceTokenStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceTokenStatsOrderBy>>;
  where?: InputMaybe<LaplaceTokenStatsBoolExp>;
};


export type QueryRootLaplaceTokenStatsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceTokenStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceTokenStatsOrderBy>>;
  where?: InputMaybe<LaplaceTokenStatsBoolExp>;
};


export type QueryRootLaplaceTokenStatsByPkArgs = {
  token_name: Scalars['String'];
};


export type QueryRootLaplaceTokenTvlArgs = {
  distinct_on?: InputMaybe<Array<LaplaceTokenTvlSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceTokenTvlOrderBy>>;
  where?: InputMaybe<LaplaceTokenTvlBoolExp>;
};


export type QueryRootLaplaceTokenTvlAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceTokenTvlSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceTokenTvlOrderBy>>;
  where?: InputMaybe<LaplaceTokenTvlBoolExp>;
};


export type QueryRootLaplaceTokenTvlByPkArgs = {
  block_height: Scalars['numeric'];
  token: Scalars['String'];
};


export type QueryRootLaplaceYieldTokenPoolArgs = {
  distinct_on?: InputMaybe<Array<LaplaceYieldTokenPoolSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceYieldTokenPoolOrderBy>>;
  where?: InputMaybe<LaplaceYieldTokenPoolBoolExp>;
};


export type QueryRootLaplaceYieldTokenPoolAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceYieldTokenPoolSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceYieldTokenPoolOrderBy>>;
  where?: InputMaybe<LaplaceYieldTokenPoolBoolExp>;
};


export type QueryRootLaplaceYieldTokenPoolByPkArgs = {
  block_height: Scalars['numeric'];
  expiry: Scalars['numeric'];
  yield_token: Scalars['String'];
};


export type QueryRootLockdropArgs = {
  id: Scalars['String'];
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
};


export type QueryRootLockdropCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  order?: InputMaybe<Array<InputMaybe<LockdropOrder>>>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<LockdropFilter>;
};


export type QueryRootLongTextArgs = {
  id: Scalars['String'];
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
};


export type QueryRootLongTextCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  order?: InputMaybe<Array<InputMaybe<LongTextOrder>>>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<LongTextFilter>;
};


export type QueryRootPublicDbtAutoalexApowerDistributionArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtAutoalexApowerDistributionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtAutoalexApowerDistributionOrderBy>>;
  where?: InputMaybe<PublicDbtAutoalexApowerDistributionBoolExp>;
};


export type QueryRootPublicDbtAutoalexApowerDistributionAggregateArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtAutoalexApowerDistributionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtAutoalexApowerDistributionOrderBy>>;
  where?: InputMaybe<PublicDbtAutoalexApowerDistributionBoolExp>;
};


export type QueryRootPublicDbtAutoalexClaimAndStakeArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtAutoalexClaimAndStakeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtAutoalexClaimAndStakeOrderBy>>;
  where?: InputMaybe<PublicDbtAutoalexClaimAndStakeBoolExp>;
};


export type QueryRootPublicDbtAutoalexClaimAndStakeAggregateArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtAutoalexClaimAndStakeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtAutoalexClaimAndStakeOrderBy>>;
  where?: InputMaybe<PublicDbtAutoalexClaimAndStakeBoolExp>;
};


export type QueryRootPublicDbtAutoalexLockdropSnapshotConfigArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtAutoalexLockdropSnapshotConfigSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtAutoalexLockdropSnapshotConfigOrderBy>>;
  where?: InputMaybe<PublicDbtAutoalexLockdropSnapshotConfigBoolExp>;
};


export type QueryRootPublicDbtAutoalexLockdropSnapshotConfigAggregateArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtAutoalexLockdropSnapshotConfigSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtAutoalexLockdropSnapshotConfigOrderBy>>;
  where?: InputMaybe<PublicDbtAutoalexLockdropSnapshotConfigBoolExp>;
};


export type QueryRootPublicDbtAutoalexSnapshotConfigArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtAutoalexSnapshotConfigSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtAutoalexSnapshotConfigOrderBy>>;
  where?: InputMaybe<PublicDbtAutoalexSnapshotConfigBoolExp>;
};


export type QueryRootPublicDbtAutoalexSnapshotConfigAggregateArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtAutoalexSnapshotConfigSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtAutoalexSnapshotConfigOrderBy>>;
  where?: InputMaybe<PublicDbtAutoalexSnapshotConfigBoolExp>;
};


export type QueryRootPublicDbtDimAutoalexApowerCycleRewardStatusArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimAutoalexApowerCycleRewardStatusSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimAutoalexApowerCycleRewardStatusOrderBy>>;
  where?: InputMaybe<PublicDbtDimAutoalexApowerCycleRewardStatusBoolExp>;
};


export type QueryRootPublicDbtDimAutoalexApowerCycleRewardStatusAggregateArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimAutoalexApowerCycleRewardStatusSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimAutoalexApowerCycleRewardStatusOrderBy>>;
  where?: InputMaybe<PublicDbtDimAutoalexApowerCycleRewardStatusBoolExp>;
};


export type QueryRootPublicDbtDimBalanceAlexStakedLockdropOffetsArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimBalanceAlexStakedLockdropOffetsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimBalanceAlexStakedLockdropOffetsOrderBy>>;
  where?: InputMaybe<PublicDbtDimBalanceAlexStakedLockdropOffetsBoolExp>;
};


export type QueryRootPublicDbtDimBalanceAlexStakedLockdropOffetsAggregateArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimBalanceAlexStakedLockdropOffetsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimBalanceAlexStakedLockdropOffetsOrderBy>>;
  where?: InputMaybe<PublicDbtDimBalanceAlexStakedLockdropOffetsBoolExp>;
};


export type QueryRootPublicDbtDimBalanceAutoalexApowerDistributionArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimBalanceAutoalexApowerDistributionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimBalanceAutoalexApowerDistributionOrderBy>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexApowerDistributionBoolExp>;
};


export type QueryRootPublicDbtDimBalanceAutoalexApowerDistributionAggregateArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimBalanceAutoalexApowerDistributionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimBalanceAutoalexApowerDistributionOrderBy>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexApowerDistributionBoolExp>;
};


export type QueryRootPublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewOrderBy>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewBoolExp>;
};


export type QueryRootPublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewAggregateArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewOrderBy>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewBoolExp>;
};


export type QueryRootPublicDbtDimBalanceAutoalexLockdrop2RankViewArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimBalanceAutoalexLockdrop2RankViewSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimBalanceAutoalexLockdrop2RankViewOrderBy>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexLockdrop2RankViewBoolExp>;
};


export type QueryRootPublicDbtDimBalanceAutoalexLockdrop2RankViewAggregateArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimBalanceAutoalexLockdrop2RankViewSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimBalanceAutoalexLockdrop2RankViewOrderBy>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexLockdrop2RankViewBoolExp>;
};


export type QueryRootPublicDbtDimBalanceAutoalexRankOnHeightViewArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankOnHeightViewSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankOnHeightViewOrderBy>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexRankOnHeightViewBoolExp>;
};


export type QueryRootPublicDbtDimBalanceAutoalexRankOnHeightViewAggregateArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankOnHeightViewSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankOnHeightViewOrderBy>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexRankOnHeightViewBoolExp>;
};


export type QueryRootPublicDbtDimBalanceAutoalexRankSnapshotViewArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankSnapshotViewSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankSnapshotViewOrderBy>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexRankSnapshotViewBoolExp>;
};


export type QueryRootPublicDbtDimBalanceAutoalexRankSnapshotViewAggregateArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankSnapshotViewSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankSnapshotViewOrderBy>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexRankSnapshotViewBoolExp>;
};


export type QueryRootPublicDbtDimBalanceAutoalexRankViewArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankViewSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankViewOrderBy>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexRankViewBoolExp>;
};


export type QueryRootPublicDbtDimBalanceAutoalexRankViewAggregateArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankViewSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankViewOrderBy>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexRankViewBoolExp>;
};


export type QueryRootPublicDbtDimIdosInfoArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimIdosInfoSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimIdosInfoOrderBy>>;
  where?: InputMaybe<PublicDbtDimIdosInfoBoolExp>;
};


export type QueryRootPublicDbtDimIdosInfoAggregateArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimIdosInfoSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimIdosInfoOrderBy>>;
  where?: InputMaybe<PublicDbtDimIdosInfoBoolExp>;
};


export type QueryRootSmartContractsArgs = {
  distinct_on?: InputMaybe<Array<SmartContractsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<SmartContractsOrderBy>>;
  where?: InputMaybe<SmartContractsBoolExp>;
};


export type QueryRootSmartContractsAggregateArgs = {
  distinct_on?: InputMaybe<Array<SmartContractsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<SmartContractsOrderBy>>;
  where?: InputMaybe<SmartContractsBoolExp>;
};


export type QueryRootSmartContractsByPkArgs = {
  id: Scalars['Int'];
};


export type QueryRootStxEventsArgs = {
  distinct_on?: InputMaybe<Array<StxEventsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StxEventsOrderBy>>;
  where?: InputMaybe<StxEventsBoolExp>;
};


export type QueryRootStxEventsAggregateArgs = {
  distinct_on?: InputMaybe<Array<StxEventsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StxEventsOrderBy>>;
  where?: InputMaybe<StxEventsBoolExp>;
};


export type QueryRootStxEventsByPkArgs = {
  id: Scalars['Int'];
};


export type QueryRootTokenArgs = {
  id: Scalars['String'];
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
};


export type QueryRootTokenCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  order?: InputMaybe<Array<InputMaybe<TokenOrder>>>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<TokenFilter>;
};


export type QueryRootTokenListItemArgs = {
  id: Scalars['String'];
  locale?: InputMaybe<Scalars['String']>;
  preview?: InputMaybe<Scalars['Boolean']>;
};


export type QueryRootTokenListItemCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  order?: InputMaybe<Array<InputMaybe<TokenListItemOrder>>>;
  preview?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<TokenListItemFilter>;
};


export type QueryRootTxsArgs = {
  distinct_on?: InputMaybe<Array<TxsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<TxsOrderBy>>;
  where?: InputMaybe<TxsBoolExp>;
};


export type QueryRootTxsAggregateArgs = {
  distinct_on?: InputMaybe<Array<TxsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<TxsOrderBy>>;
  where?: InputMaybe<TxsBoolExp>;
};


export type QueryRootTxsByPkArgs = {
  id: Scalars['Int'];
};

/** Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'. */
export type SmallintComparisonExp = {
  _eq?: InputMaybe<Scalars['smallint']>;
  _gt?: InputMaybe<Scalars['smallint']>;
  _gte?: InputMaybe<Scalars['smallint']>;
  _in?: InputMaybe<Array<Scalars['smallint']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['smallint']>;
  _lte?: InputMaybe<Scalars['smallint']>;
  _neq?: InputMaybe<Scalars['smallint']>;
  _nin?: InputMaybe<Array<Scalars['smallint']>>;
};

/** columns and relationships of "smart_contracts" */
export type SmartContracts = {
  __typename?: 'smart_contracts';
  abi: Scalars['jsonb'];
  block_height: Scalars['Int'];
  canonical: Scalars['Boolean'];
  contract_id: Scalars['String'];
  id: Scalars['Int'];
  index_block_hash: Scalars['bytea'];
  microblock_canonical: Scalars['Boolean'];
  microblock_hash: Scalars['bytea'];
  microblock_sequence: Scalars['Int'];
  parent_index_block_hash: Scalars['bytea'];
  source_code: Scalars['String'];
  tx_id: Scalars['bytea'];
};


/** columns and relationships of "smart_contracts" */
export type SmartContractsAbiArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "smart_contracts" */
export type SmartContractsAggregate = {
  __typename?: 'smart_contracts_aggregate';
  aggregate?: Maybe<SmartContractsAggregateFields>;
  nodes: Array<SmartContracts>;
};

/** aggregate fields of "smart_contracts" */
export type SmartContractsAggregateFields = {
  __typename?: 'smart_contracts_aggregate_fields';
  avg?: Maybe<SmartContractsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<SmartContractsMaxFields>;
  min?: Maybe<SmartContractsMinFields>;
  stddev?: Maybe<SmartContractsStddevFields>;
  stddev_pop?: Maybe<SmartContractsStddevPopFields>;
  stddev_samp?: Maybe<SmartContractsStddevSampFields>;
  sum?: Maybe<SmartContractsSumFields>;
  var_pop?: Maybe<SmartContractsVarPopFields>;
  var_samp?: Maybe<SmartContractsVarSampFields>;
  variance?: Maybe<SmartContractsVarianceFields>;
};


/** aggregate fields of "smart_contracts" */
export type SmartContractsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<SmartContractsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type SmartContractsAppendInput = {
  abi?: InputMaybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type SmartContractsAvgFields = {
  __typename?: 'smart_contracts_avg_fields';
  block_height?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "smart_contracts". All fields are combined with a logical 'AND'. */
export type SmartContractsBoolExp = {
  _and?: InputMaybe<Array<SmartContractsBoolExp>>;
  _not?: InputMaybe<SmartContractsBoolExp>;
  _or?: InputMaybe<Array<SmartContractsBoolExp>>;
  abi?: InputMaybe<JsonbComparisonExp>;
  block_height?: InputMaybe<IntComparisonExp>;
  canonical?: InputMaybe<BooleanComparisonExp>;
  contract_id?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  index_block_hash?: InputMaybe<ByteaComparisonExp>;
  microblock_canonical?: InputMaybe<BooleanComparisonExp>;
  microblock_hash?: InputMaybe<ByteaComparisonExp>;
  microblock_sequence?: InputMaybe<IntComparisonExp>;
  parent_index_block_hash?: InputMaybe<ByteaComparisonExp>;
  source_code?: InputMaybe<StringComparisonExp>;
  tx_id?: InputMaybe<ByteaComparisonExp>;
};

/** unique or primary key constraints on table "smart_contracts" */
export enum SmartContractsConstraint {
  /** unique or primary key constraint on columns "id" */
  SmartContractsPkey = 'smart_contracts_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type SmartContractsDeleteAtPathInput = {
  abi?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type SmartContractsDeleteElemInput = {
  abi?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type SmartContractsDeleteKeyInput = {
  abi?: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "smart_contracts" */
export type SmartContractsIncInput = {
  block_height?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['Int']>;
  microblock_sequence?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "smart_contracts" */
export type SmartContractsInsertInput = {
  abi?: InputMaybe<Scalars['jsonb']>;
  block_height?: InputMaybe<Scalars['Int']>;
  canonical?: InputMaybe<Scalars['Boolean']>;
  contract_id?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['Int']>;
  index_block_hash?: InputMaybe<Scalars['bytea']>;
  microblock_canonical?: InputMaybe<Scalars['Boolean']>;
  microblock_hash?: InputMaybe<Scalars['bytea']>;
  microblock_sequence?: InputMaybe<Scalars['Int']>;
  parent_index_block_hash?: InputMaybe<Scalars['bytea']>;
  source_code?: InputMaybe<Scalars['String']>;
  tx_id?: InputMaybe<Scalars['bytea']>;
};

/** aggregate max on columns */
export type SmartContractsMaxFields = {
  __typename?: 'smart_contracts_max_fields';
  block_height?: Maybe<Scalars['Int']>;
  contract_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  microblock_sequence?: Maybe<Scalars['Int']>;
  source_code?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type SmartContractsMinFields = {
  __typename?: 'smart_contracts_min_fields';
  block_height?: Maybe<Scalars['Int']>;
  contract_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  microblock_sequence?: Maybe<Scalars['Int']>;
  source_code?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "smart_contracts" */
export type SmartContractsMutationResponse = {
  __typename?: 'smart_contracts_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<SmartContracts>;
};

/** on_conflict condition type for table "smart_contracts" */
export type SmartContractsOnConflict = {
  constraint: SmartContractsConstraint;
  update_columns?: Array<SmartContractsUpdateColumn>;
  where?: InputMaybe<SmartContractsBoolExp>;
};

/** Ordering options when selecting data from "smart_contracts". */
export type SmartContractsOrderBy = {
  abi?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  canonical?: InputMaybe<OrderBy>;
  contract_id?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  index_block_hash?: InputMaybe<OrderBy>;
  microblock_canonical?: InputMaybe<OrderBy>;
  microblock_hash?: InputMaybe<OrderBy>;
  microblock_sequence?: InputMaybe<OrderBy>;
  parent_index_block_hash?: InputMaybe<OrderBy>;
  source_code?: InputMaybe<OrderBy>;
  tx_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: smart_contracts */
export type SmartContractsPkColumnsInput = {
  id: Scalars['Int'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type SmartContractsPrependInput = {
  abi?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "smart_contracts" */
export enum SmartContractsSelectColumn {
  /** column name */
  Abi = 'abi',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  Canonical = 'canonical',
  /** column name */
  ContractId = 'contract_id',
  /** column name */
  Id = 'id',
  /** column name */
  IndexBlockHash = 'index_block_hash',
  /** column name */
  MicroblockCanonical = 'microblock_canonical',
  /** column name */
  MicroblockHash = 'microblock_hash',
  /** column name */
  MicroblockSequence = 'microblock_sequence',
  /** column name */
  ParentIndexBlockHash = 'parent_index_block_hash',
  /** column name */
  SourceCode = 'source_code',
  /** column name */
  TxId = 'tx_id'
}

/** input type for updating data in table "smart_contracts" */
export type SmartContractsSetInput = {
  abi?: InputMaybe<Scalars['jsonb']>;
  block_height?: InputMaybe<Scalars['Int']>;
  canonical?: InputMaybe<Scalars['Boolean']>;
  contract_id?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['Int']>;
  index_block_hash?: InputMaybe<Scalars['bytea']>;
  microblock_canonical?: InputMaybe<Scalars['Boolean']>;
  microblock_hash?: InputMaybe<Scalars['bytea']>;
  microblock_sequence?: InputMaybe<Scalars['Int']>;
  parent_index_block_hash?: InputMaybe<Scalars['bytea']>;
  source_code?: InputMaybe<Scalars['String']>;
  tx_id?: InputMaybe<Scalars['bytea']>;
};

/** aggregate stddev on columns */
export type SmartContractsStddevFields = {
  __typename?: 'smart_contracts_stddev_fields';
  block_height?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type SmartContractsStddevPopFields = {
  __typename?: 'smart_contracts_stddev_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type SmartContractsStddevSampFields = {
  __typename?: 'smart_contracts_stddev_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "smart_contracts" */
export type SmartContractsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: SmartContractsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type SmartContractsStreamCursorValueInput = {
  abi?: InputMaybe<Scalars['jsonb']>;
  block_height?: InputMaybe<Scalars['Int']>;
  canonical?: InputMaybe<Scalars['Boolean']>;
  contract_id?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['Int']>;
  index_block_hash?: InputMaybe<Scalars['bytea']>;
  microblock_canonical?: InputMaybe<Scalars['Boolean']>;
  microblock_hash?: InputMaybe<Scalars['bytea']>;
  microblock_sequence?: InputMaybe<Scalars['Int']>;
  parent_index_block_hash?: InputMaybe<Scalars['bytea']>;
  source_code?: InputMaybe<Scalars['String']>;
  tx_id?: InputMaybe<Scalars['bytea']>;
};

/** aggregate sum on columns */
export type SmartContractsSumFields = {
  __typename?: 'smart_contracts_sum_fields';
  block_height?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  microblock_sequence?: Maybe<Scalars['Int']>;
};

/** update columns of table "smart_contracts" */
export enum SmartContractsUpdateColumn {
  /** column name */
  Abi = 'abi',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  Canonical = 'canonical',
  /** column name */
  ContractId = 'contract_id',
  /** column name */
  Id = 'id',
  /** column name */
  IndexBlockHash = 'index_block_hash',
  /** column name */
  MicroblockCanonical = 'microblock_canonical',
  /** column name */
  MicroblockHash = 'microblock_hash',
  /** column name */
  MicroblockSequence = 'microblock_sequence',
  /** column name */
  ParentIndexBlockHash = 'parent_index_block_hash',
  /** column name */
  SourceCode = 'source_code',
  /** column name */
  TxId = 'tx_id'
}

export type SmartContractsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<SmartContractsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<SmartContractsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<SmartContractsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<SmartContractsDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<SmartContractsIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<SmartContractsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<SmartContractsSetInput>;
  where: SmartContractsBoolExp;
};

/** aggregate var_pop on columns */
export type SmartContractsVarPopFields = {
  __typename?: 'smart_contracts_var_pop_fields';
  block_height?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type SmartContractsVarSampFields = {
  __typename?: 'smart_contracts_var_samp_fields';
  block_height?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type SmartContractsVarianceFields = {
  __typename?: 'smart_contracts_variance_fields';
  block_height?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "stx_events" */
export type StxEvents = {
  __typename?: 'stx_events';
  amount: Scalars['bigint'];
  asset_event_type_id: Scalars['smallint'];
  block_height: Scalars['Int'];
  canonical: Scalars['Boolean'];
  event_index: Scalars['Int'];
  id: Scalars['Int'];
  index_block_hash: Scalars['bytea'];
  microblock_canonical: Scalars['Boolean'];
  microblock_hash: Scalars['bytea'];
  microblock_sequence: Scalars['Int'];
  parent_index_block_hash: Scalars['bytea'];
  recipient?: Maybe<Scalars['String']>;
  sender?: Maybe<Scalars['String']>;
  tx_id: Scalars['bytea'];
  tx_index: Scalars['smallint'];
};

/** aggregated selection of "stx_events" */
export type StxEventsAggregate = {
  __typename?: 'stx_events_aggregate';
  aggregate?: Maybe<StxEventsAggregateFields>;
  nodes: Array<StxEvents>;
};

/** aggregate fields of "stx_events" */
export type StxEventsAggregateFields = {
  __typename?: 'stx_events_aggregate_fields';
  avg?: Maybe<StxEventsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StxEventsMaxFields>;
  min?: Maybe<StxEventsMinFields>;
  stddev?: Maybe<StxEventsStddevFields>;
  stddev_pop?: Maybe<StxEventsStddevPopFields>;
  stddev_samp?: Maybe<StxEventsStddevSampFields>;
  sum?: Maybe<StxEventsSumFields>;
  var_pop?: Maybe<StxEventsVarPopFields>;
  var_samp?: Maybe<StxEventsVarSampFields>;
  variance?: Maybe<StxEventsVarianceFields>;
};


/** aggregate fields of "stx_events" */
export type StxEventsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StxEventsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StxEventsAvgFields = {
  __typename?: 'stx_events_avg_fields';
  amount?: Maybe<Scalars['Float']>;
  asset_event_type_id?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  event_index?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "stx_events". All fields are combined with a logical 'AND'. */
export type StxEventsBoolExp = {
  _and?: InputMaybe<Array<StxEventsBoolExp>>;
  _not?: InputMaybe<StxEventsBoolExp>;
  _or?: InputMaybe<Array<StxEventsBoolExp>>;
  amount?: InputMaybe<BigintComparisonExp>;
  asset_event_type_id?: InputMaybe<SmallintComparisonExp>;
  block_height?: InputMaybe<IntComparisonExp>;
  canonical?: InputMaybe<BooleanComparisonExp>;
  event_index?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  index_block_hash?: InputMaybe<ByteaComparisonExp>;
  microblock_canonical?: InputMaybe<BooleanComparisonExp>;
  microblock_hash?: InputMaybe<ByteaComparisonExp>;
  microblock_sequence?: InputMaybe<IntComparisonExp>;
  parent_index_block_hash?: InputMaybe<ByteaComparisonExp>;
  recipient?: InputMaybe<StringComparisonExp>;
  sender?: InputMaybe<StringComparisonExp>;
  tx_id?: InputMaybe<ByteaComparisonExp>;
  tx_index?: InputMaybe<SmallintComparisonExp>;
};

/** unique or primary key constraints on table "stx_events" */
export enum StxEventsConstraint {
  /** unique or primary key constraint on columns "id" */
  StxEventsPkey = 'stx_events_pkey'
}

/** input type for incrementing numeric columns in table "stx_events" */
export type StxEventsIncInput = {
  amount?: InputMaybe<Scalars['bigint']>;
  asset_event_type_id?: InputMaybe<Scalars['smallint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  event_index?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['Int']>;
  microblock_sequence?: InputMaybe<Scalars['Int']>;
  tx_index?: InputMaybe<Scalars['smallint']>;
};

/** input type for inserting data into table "stx_events" */
export type StxEventsInsertInput = {
  amount?: InputMaybe<Scalars['bigint']>;
  asset_event_type_id?: InputMaybe<Scalars['smallint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  canonical?: InputMaybe<Scalars['Boolean']>;
  event_index?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['Int']>;
  index_block_hash?: InputMaybe<Scalars['bytea']>;
  microblock_canonical?: InputMaybe<Scalars['Boolean']>;
  microblock_hash?: InputMaybe<Scalars['bytea']>;
  microblock_sequence?: InputMaybe<Scalars['Int']>;
  parent_index_block_hash?: InputMaybe<Scalars['bytea']>;
  recipient?: InputMaybe<Scalars['String']>;
  sender?: InputMaybe<Scalars['String']>;
  tx_id?: InputMaybe<Scalars['bytea']>;
  tx_index?: InputMaybe<Scalars['smallint']>;
};

/** aggregate max on columns */
export type StxEventsMaxFields = {
  __typename?: 'stx_events_max_fields';
  amount?: Maybe<Scalars['bigint']>;
  asset_event_type_id?: Maybe<Scalars['smallint']>;
  block_height?: Maybe<Scalars['Int']>;
  event_index?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  microblock_sequence?: Maybe<Scalars['Int']>;
  recipient?: Maybe<Scalars['String']>;
  sender?: Maybe<Scalars['String']>;
  tx_index?: Maybe<Scalars['smallint']>;
};

/** aggregate min on columns */
export type StxEventsMinFields = {
  __typename?: 'stx_events_min_fields';
  amount?: Maybe<Scalars['bigint']>;
  asset_event_type_id?: Maybe<Scalars['smallint']>;
  block_height?: Maybe<Scalars['Int']>;
  event_index?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  microblock_sequence?: Maybe<Scalars['Int']>;
  recipient?: Maybe<Scalars['String']>;
  sender?: Maybe<Scalars['String']>;
  tx_index?: Maybe<Scalars['smallint']>;
};

/** response of any mutation on the table "stx_events" */
export type StxEventsMutationResponse = {
  __typename?: 'stx_events_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StxEvents>;
};

/** on_conflict condition type for table "stx_events" */
export type StxEventsOnConflict = {
  constraint: StxEventsConstraint;
  update_columns?: Array<StxEventsUpdateColumn>;
  where?: InputMaybe<StxEventsBoolExp>;
};

/** Ordering options when selecting data from "stx_events". */
export type StxEventsOrderBy = {
  amount?: InputMaybe<OrderBy>;
  asset_event_type_id?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  canonical?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  index_block_hash?: InputMaybe<OrderBy>;
  microblock_canonical?: InputMaybe<OrderBy>;
  microblock_hash?: InputMaybe<OrderBy>;
  microblock_sequence?: InputMaybe<OrderBy>;
  parent_index_block_hash?: InputMaybe<OrderBy>;
  recipient?: InputMaybe<OrderBy>;
  sender?: InputMaybe<OrderBy>;
  tx_id?: InputMaybe<OrderBy>;
  tx_index?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: stx_events */
export type StxEventsPkColumnsInput = {
  id: Scalars['Int'];
};

/** select columns of table "stx_events" */
export enum StxEventsSelectColumn {
  /** column name */
  Amount = 'amount',
  /** column name */
  AssetEventTypeId = 'asset_event_type_id',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  Canonical = 'canonical',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  Id = 'id',
  /** column name */
  IndexBlockHash = 'index_block_hash',
  /** column name */
  MicroblockCanonical = 'microblock_canonical',
  /** column name */
  MicroblockHash = 'microblock_hash',
  /** column name */
  MicroblockSequence = 'microblock_sequence',
  /** column name */
  ParentIndexBlockHash = 'parent_index_block_hash',
  /** column name */
  Recipient = 'recipient',
  /** column name */
  Sender = 'sender',
  /** column name */
  TxId = 'tx_id',
  /** column name */
  TxIndex = 'tx_index'
}

/** input type for updating data in table "stx_events" */
export type StxEventsSetInput = {
  amount?: InputMaybe<Scalars['bigint']>;
  asset_event_type_id?: InputMaybe<Scalars['smallint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  canonical?: InputMaybe<Scalars['Boolean']>;
  event_index?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['Int']>;
  index_block_hash?: InputMaybe<Scalars['bytea']>;
  microblock_canonical?: InputMaybe<Scalars['Boolean']>;
  microblock_hash?: InputMaybe<Scalars['bytea']>;
  microblock_sequence?: InputMaybe<Scalars['Int']>;
  parent_index_block_hash?: InputMaybe<Scalars['bytea']>;
  recipient?: InputMaybe<Scalars['String']>;
  sender?: InputMaybe<Scalars['String']>;
  tx_id?: InputMaybe<Scalars['bytea']>;
  tx_index?: InputMaybe<Scalars['smallint']>;
};

/** aggregate stddev on columns */
export type StxEventsStddevFields = {
  __typename?: 'stx_events_stddev_fields';
  amount?: Maybe<Scalars['Float']>;
  asset_event_type_id?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  event_index?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StxEventsStddevPopFields = {
  __typename?: 'stx_events_stddev_pop_fields';
  amount?: Maybe<Scalars['Float']>;
  asset_event_type_id?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  event_index?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StxEventsStddevSampFields = {
  __typename?: 'stx_events_stddev_samp_fields';
  amount?: Maybe<Scalars['Float']>;
  asset_event_type_id?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  event_index?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "stx_events" */
export type StxEventsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StxEventsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StxEventsStreamCursorValueInput = {
  amount?: InputMaybe<Scalars['bigint']>;
  asset_event_type_id?: InputMaybe<Scalars['smallint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  canonical?: InputMaybe<Scalars['Boolean']>;
  event_index?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['Int']>;
  index_block_hash?: InputMaybe<Scalars['bytea']>;
  microblock_canonical?: InputMaybe<Scalars['Boolean']>;
  microblock_hash?: InputMaybe<Scalars['bytea']>;
  microblock_sequence?: InputMaybe<Scalars['Int']>;
  parent_index_block_hash?: InputMaybe<Scalars['bytea']>;
  recipient?: InputMaybe<Scalars['String']>;
  sender?: InputMaybe<Scalars['String']>;
  tx_id?: InputMaybe<Scalars['bytea']>;
  tx_index?: InputMaybe<Scalars['smallint']>;
};

/** aggregate sum on columns */
export type StxEventsSumFields = {
  __typename?: 'stx_events_sum_fields';
  amount?: Maybe<Scalars['bigint']>;
  asset_event_type_id?: Maybe<Scalars['smallint']>;
  block_height?: Maybe<Scalars['Int']>;
  event_index?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  microblock_sequence?: Maybe<Scalars['Int']>;
  tx_index?: Maybe<Scalars['smallint']>;
};

/** update columns of table "stx_events" */
export enum StxEventsUpdateColumn {
  /** column name */
  Amount = 'amount',
  /** column name */
  AssetEventTypeId = 'asset_event_type_id',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  Canonical = 'canonical',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  Id = 'id',
  /** column name */
  IndexBlockHash = 'index_block_hash',
  /** column name */
  MicroblockCanonical = 'microblock_canonical',
  /** column name */
  MicroblockHash = 'microblock_hash',
  /** column name */
  MicroblockSequence = 'microblock_sequence',
  /** column name */
  ParentIndexBlockHash = 'parent_index_block_hash',
  /** column name */
  Recipient = 'recipient',
  /** column name */
  Sender = 'sender',
  /** column name */
  TxId = 'tx_id',
  /** column name */
  TxIndex = 'tx_index'
}

export type StxEventsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StxEventsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StxEventsSetInput>;
  where: StxEventsBoolExp;
};

/** aggregate var_pop on columns */
export type StxEventsVarPopFields = {
  __typename?: 'stx_events_var_pop_fields';
  amount?: Maybe<Scalars['Float']>;
  asset_event_type_id?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  event_index?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StxEventsVarSampFields = {
  __typename?: 'stx_events_var_samp_fields';
  amount?: Maybe<Scalars['Float']>;
  asset_event_type_id?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  event_index?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StxEventsVarianceFields = {
  __typename?: 'stx_events_variance_fields';
  amount?: Maybe<Scalars['Float']>;
  asset_event_type_id?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  event_index?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
};

export type SubscriptionRoot = {
  __typename?: 'subscription_root';
  /** fetch data from the table: "blocks" */
  blocks: Array<Blocks>;
  /** fetch aggregated fields from the table: "blocks" */
  blocks_aggregate: BlocksAggregate;
  /** fetch data from the table: "blocks" using primary key columns */
  blocks_by_pk?: Maybe<Blocks>;
  /** fetch data from the table in a streaming manner: "blocks" */
  blocks_stream: Array<Blocks>;
  /** fetch data from the table: "contract_logs" */
  contract_logs: Array<ContractLogs>;
  /** fetch aggregated fields from the table: "contract_logs" */
  contract_logs_aggregate: ContractLogsAggregate;
  /** fetch data from the table: "contract_logs" using primary key columns */
  contract_logs_by_pk?: Maybe<ContractLogs>;
  /** fetch data from the table in a streaming manner: "contract_logs" */
  contract_logs_stream: Array<ContractLogs>;
  /** fetch data from the table: "ft_events" */
  ft_events: Array<FtEvents>;
  /** fetch aggregated fields from the table: "ft_events" */
  ft_events_aggregate: FtEventsAggregate;
  /** fetch data from the table: "ft_events" using primary key columns */
  ft_events_by_pk?: Maybe<FtEvents>;
  /** fetch data from the table in a streaming manner: "ft_events" */
  ft_events_stream: Array<FtEvents>;
  /** fetch data from the table: "laplace.alex_reserve_pools" */
  laplace_alex_reserve_pools: Array<LaplaceAlexReservePools>;
  /** fetch aggregated fields from the table: "laplace.alex_reserve_pools" */
  laplace_alex_reserve_pools_aggregate: LaplaceAlexReservePoolsAggregate;
  /** fetch data from the table: "laplace.alex_reserve_pools" using primary key columns */
  laplace_alex_reserve_pools_by_pk?: Maybe<LaplaceAlexReservePools>;
  /** fetch data from the table in a streaming manner: "laplace.alex_reserve_pools" */
  laplace_alex_reserve_pools_stream: Array<LaplaceAlexReservePools>;
  /** fetch data from the table: "laplace.alex_usd_pricing" */
  laplace_alex_usd_pricing: Array<LaplaceAlexUsdPricing>;
  /** fetch aggregated fields from the table: "laplace.alex_usd_pricing" */
  laplace_alex_usd_pricing_aggregate: LaplaceAlexUsdPricingAggregate;
  /** fetch data from the table in a streaming manner: "laplace.alex_usd_pricing" */
  laplace_alex_usd_pricing_stream: Array<LaplaceAlexUsdPricing>;
  /** fetch data from the table: "laplace.borrow_deposit_daily_stats" */
  laplace_borrow_deposit_daily_stats: Array<LaplaceBorrowDepositDailyStats>;
  /** fetch aggregated fields from the table: "laplace.borrow_deposit_daily_stats" */
  laplace_borrow_deposit_daily_stats_aggregate: LaplaceBorrowDepositDailyStatsAggregate;
  /** fetch data from the table: "laplace.borrow_deposit_daily_stats" using primary key columns */
  laplace_borrow_deposit_daily_stats_by_pk?: Maybe<LaplaceBorrowDepositDailyStats>;
  /** fetch data from the table in a streaming manner: "laplace.borrow_deposit_daily_stats" */
  laplace_borrow_deposit_daily_stats_stream: Array<LaplaceBorrowDepositDailyStats>;
  /** fetch data from the table: "laplace.borrow_deposit_hourly_stats" */
  laplace_borrow_deposit_hourly_stats: Array<LaplaceBorrowDepositHourlyStats>;
  /** fetch aggregated fields from the table: "laplace.borrow_deposit_hourly_stats" */
  laplace_borrow_deposit_hourly_stats_aggregate: LaplaceBorrowDepositHourlyStatsAggregate;
  /** fetch data from the table: "laplace.borrow_deposit_hourly_stats" using primary key columns */
  laplace_borrow_deposit_hourly_stats_by_pk?: Maybe<LaplaceBorrowDepositHourlyStats>;
  /** fetch data from the table in a streaming manner: "laplace.borrow_deposit_hourly_stats" */
  laplace_borrow_deposit_hourly_stats_stream: Array<LaplaceBorrowDepositHourlyStats>;
  /** fetch data from the table: "laplace.borrow_deposit_stats" */
  laplace_borrow_deposit_stats: Array<LaplaceBorrowDepositStats>;
  /** fetch aggregated fields from the table: "laplace.borrow_deposit_stats" */
  laplace_borrow_deposit_stats_aggregate: LaplaceBorrowDepositStatsAggregate;
  /** fetch data from the table: "laplace.borrow_deposit_stats" using primary key columns */
  laplace_borrow_deposit_stats_by_pk?: Maybe<LaplaceBorrowDepositStats>;
  /** fetch data from the table in a streaming manner: "laplace.borrow_deposit_stats" */
  laplace_borrow_deposit_stats_stream: Array<LaplaceBorrowDepositStats>;
  /** fetch data from the table: "laplace.coin_gecko" */
  laplace_coin_gecko: Array<LaplaceCoinGecko>;
  /** fetch aggregated fields from the table: "laplace.coin_gecko" */
  laplace_coin_gecko_aggregate: LaplaceCoinGeckoAggregate;
  /** fetch data from the table: "laplace.coin_gecko_archive" */
  laplace_coin_gecko_archive: Array<LaplaceCoinGeckoArchive>;
  /** fetch aggregated fields from the table: "laplace.coin_gecko_archive" */
  laplace_coin_gecko_archive_aggregate: LaplaceCoinGeckoArchiveAggregate;
  /** fetch data from the table: "laplace.coin_gecko_archive" using primary key columns */
  laplace_coin_gecko_archive_by_pk?: Maybe<LaplaceCoinGeckoArchive>;
  /** fetch data from the table in a streaming manner: "laplace.coin_gecko_archive" */
  laplace_coin_gecko_archive_stream: Array<LaplaceCoinGeckoArchive>;
  /** fetch data from the table: "laplace.coin_gecko" using primary key columns */
  laplace_coin_gecko_by_pk?: Maybe<LaplaceCoinGecko>;
  /** fetch data from the table in a streaming manner: "laplace.coin_gecko" */
  laplace_coin_gecko_stream: Array<LaplaceCoinGecko>;
  /** fetch data from the table: "laplace.collateral_rebalancing_pool" */
  laplace_collateral_rebalancing_pool: Array<LaplaceCollateralRebalancingPool>;
  /** fetch aggregated fields from the table: "laplace.collateral_rebalancing_pool" */
  laplace_collateral_rebalancing_pool_aggregate: LaplaceCollateralRebalancingPoolAggregate;
  /** fetch data from the table: "laplace.collateral_rebalancing_pool" using primary key columns */
  laplace_collateral_rebalancing_pool_by_pk?: Maybe<LaplaceCollateralRebalancingPool>;
  /** fetch data from the table in a streaming manner: "laplace.collateral_rebalancing_pool" */
  laplace_collateral_rebalancing_pool_stream: Array<LaplaceCollateralRebalancingPool>;
  /** fetch data from the table: "laplace.config_contracts" */
  laplace_config_contracts: Array<LaplaceConfigContracts>;
  /** fetch aggregated fields from the table: "laplace.config_contracts" */
  laplace_config_contracts_aggregate: LaplaceConfigContractsAggregate;
  /** fetch data from the table: "laplace.config_contracts" using primary key columns */
  laplace_config_contracts_by_pk?: Maybe<LaplaceConfigContracts>;
  /** fetch data from the table in a streaming manner: "laplace.config_contracts" */
  laplace_config_contracts_stream: Array<LaplaceConfigContracts>;
  /** fetch data from the table: "laplace.contract_calls" */
  laplace_contract_calls: Array<LaplaceContractCalls>;
  /** fetch aggregated fields from the table: "laplace.contract_calls" */
  laplace_contract_calls_aggregate: LaplaceContractCallsAggregate;
  /** fetch data from the table: "laplace.contract_calls" using primary key columns */
  laplace_contract_calls_by_pk?: Maybe<LaplaceContractCalls>;
  /** fetch data from the table in a streaming manner: "laplace.contract_calls" */
  laplace_contract_calls_stream: Array<LaplaceContractCalls>;
  /** fetch data from the table: "laplace.current_token_price" */
  laplace_current_token_price: Array<LaplaceCurrentTokenPrice>;
  /** fetch aggregated fields from the table: "laplace.current_token_price" */
  laplace_current_token_price_aggregate: LaplaceCurrentTokenPriceAggregate;
  /** fetch data from the table in a streaming manner: "laplace.current_token_price" */
  laplace_current_token_price_stream: Array<LaplaceCurrentTokenPrice>;
  /** fetch data from the table: "laplace.deployed_contracts" */
  laplace_deployed_contracts: Array<LaplaceDeployedContracts>;
  /** fetch aggregated fields from the table: "laplace.deployed_contracts" */
  laplace_deployed_contracts_aggregate: LaplaceDeployedContractsAggregate;
  /** fetch data from the table: "laplace.deployed_contracts" using primary key columns */
  laplace_deployed_contracts_by_pk?: Maybe<LaplaceDeployedContracts>;
  /** fetch data from the table in a streaming manner: "laplace.deployed_contracts" */
  laplace_deployed_contracts_stream: Array<LaplaceDeployedContracts>;
  /** fetch data from the table: "laplace.external_token_price" */
  laplace_external_token_price: Array<LaplaceExternalTokenPrice>;
  /** fetch aggregated fields from the table: "laplace.external_token_price" */
  laplace_external_token_price_aggregate: LaplaceExternalTokenPriceAggregate;
  /** fetch data from the table: "laplace.external_token_price" using primary key columns */
  laplace_external_token_price_by_pk?: Maybe<LaplaceExternalTokenPrice>;
  /** fetch data from the table in a streaming manner: "laplace.external_token_price" */
  laplace_external_token_price_stream: Array<LaplaceExternalTokenPrice>;
  /** fetch data from the table: "laplace.fixed_weight_pool_v1_01" */
  laplace_fixed_weight_pool_v1_01: Array<LaplaceFixedWeightPoolV1_01>;
  /** fetch aggregated fields from the table: "laplace.fixed_weight_pool_v1_01" */
  laplace_fixed_weight_pool_v1_01_aggregate: LaplaceFixedWeightPoolV1_01Aggregate;
  /** fetch data from the table: "laplace.fixed_weight_pool_v1_01" using primary key columns */
  laplace_fixed_weight_pool_v1_01_by_pk?: Maybe<LaplaceFixedWeightPoolV1_01>;
  /** fetch data from the table in a streaming manner: "laplace.fixed_weight_pool_v1_01" */
  laplace_fixed_weight_pool_v1_01_stream: Array<LaplaceFixedWeightPoolV1_01>;
  /** fetch data from the table: "laplace.history_price_data" */
  laplace_history_price_data: Array<LaplaceHistoryPriceData>;
  /** fetch aggregated fields from the table: "laplace.history_price_data" */
  laplace_history_price_data_aggregate: LaplaceHistoryPriceDataAggregate;
  /** fetch data from the table: "laplace.history_price_data" using primary key columns */
  laplace_history_price_data_by_pk?: Maybe<LaplaceHistoryPriceData>;
  /** fetch data from the table in a streaming manner: "laplace.history_price_data" */
  laplace_history_price_data_stream: Array<LaplaceHistoryPriceData>;
  /** fetch data from the table: "laplace.history_staking_stats" */
  laplace_history_staking_stats: Array<LaplaceHistoryStakingStats>;
  /** fetch aggregated fields from the table: "laplace.history_staking_stats" */
  laplace_history_staking_stats_aggregate: LaplaceHistoryStakingStatsAggregate;
  /** fetch data from the table: "laplace.history_staking_stats" using primary key columns */
  laplace_history_staking_stats_by_pk?: Maybe<LaplaceHistoryStakingStats>;
  /** fetch data from the table in a streaming manner: "laplace.history_staking_stats" */
  laplace_history_staking_stats_stream: Array<LaplaceHistoryStakingStats>;
  /** fetch data from the table: "laplace.ido_pool_creation" */
  laplace_ido_pool_creation: Array<LaplaceIdoPoolCreation>;
  /** fetch aggregated fields from the table: "laplace.ido_pool_creation" */
  laplace_ido_pool_creation_aggregate: LaplaceIdoPoolCreationAggregate;
  /** fetch data from the table: "laplace.ido_pool_creation" using primary key columns */
  laplace_ido_pool_creation_by_pk?: Maybe<LaplaceIdoPoolCreation>;
  /** fetch data from the table in a streaming manner: "laplace.ido_pool_creation" */
  laplace_ido_pool_creation_stream: Array<LaplaceIdoPoolCreation>;
  /** fetch data from the table: "laplace.ido_register" */
  laplace_ido_register: Array<LaplaceIdoRegister>;
  /** fetch aggregated fields from the table: "laplace.ido_register" */
  laplace_ido_register_aggregate: LaplaceIdoRegisterAggregate;
  /** fetch data from the table: "laplace.ido_register" using primary key columns */
  laplace_ido_register_by_pk?: Maybe<LaplaceIdoRegister>;
  /** fetch data from the table in a streaming manner: "laplace.ido_register" */
  laplace_ido_register_stream: Array<LaplaceIdoRegister>;
  /** fetch data from the table: "laplace.latest_alex_reserve_pools" */
  laplace_latest_alex_reserve_pools: Array<LaplaceLatestAlexReservePools>;
  /** fetch aggregated fields from the table: "laplace.latest_alex_reserve_pools" */
  laplace_latest_alex_reserve_pools_aggregate: LaplaceLatestAlexReservePoolsAggregate;
  /** fetch data from the table: "laplace.latest_alex_reserve_pools" using primary key columns */
  laplace_latest_alex_reserve_pools_by_pk?: Maybe<LaplaceLatestAlexReservePools>;
  /** fetch data from the table in a streaming manner: "laplace.latest_alex_reserve_pools" */
  laplace_latest_alex_reserve_pools_stream: Array<LaplaceLatestAlexReservePools>;
  /** fetch data from the table: "laplace.latest_auto_alex" */
  laplace_latest_auto_alex: Array<LaplaceLatestAutoAlex>;
  /** fetch aggregated fields from the table: "laplace.latest_auto_alex" */
  laplace_latest_auto_alex_aggregate: LaplaceLatestAutoAlexAggregate;
  /** fetch data from the table: "laplace.latest_auto_alex" using primary key columns */
  laplace_latest_auto_alex_by_pk?: Maybe<LaplaceLatestAutoAlex>;
  /** fetch data from the table in a streaming manner: "laplace.latest_auto_alex" */
  laplace_latest_auto_alex_stream: Array<LaplaceLatestAutoAlex>;
  /** fetch data from the table: "laplace.latest_collateral_per_share" */
  laplace_latest_collateral_per_share: Array<LaplaceLatestCollateralPerShare>;
  /** fetch aggregated fields from the table: "laplace.latest_collateral_per_share" */
  laplace_latest_collateral_per_share_aggregate: LaplaceLatestCollateralPerShareAggregate;
  /** fetch data from the table: "laplace.latest_collateral_per_share" using primary key columns */
  laplace_latest_collateral_per_share_by_pk?: Maybe<LaplaceLatestCollateralPerShare>;
  /** fetch data from the table in a streaming manner: "laplace.latest_collateral_per_share" */
  laplace_latest_collateral_per_share_stream: Array<LaplaceLatestCollateralPerShare>;
  /** fetch data from the table: "laplace.latest_collateral_rebalancing_pool" */
  laplace_latest_collateral_rebalancing_pool: Array<LaplaceLatestCollateralRebalancingPool>;
  /** fetch aggregated fields from the table: "laplace.latest_collateral_rebalancing_pool" */
  laplace_latest_collateral_rebalancing_pool_aggregate: LaplaceLatestCollateralRebalancingPoolAggregate;
  /** fetch data from the table: "laplace.latest_collateral_rebalancing_pool" using primary key columns */
  laplace_latest_collateral_rebalancing_pool_by_pk?: Maybe<LaplaceLatestCollateralRebalancingPool>;
  /** fetch data from the table in a streaming manner: "laplace.latest_collateral_rebalancing_pool" */
  laplace_latest_collateral_rebalancing_pool_stream: Array<LaplaceLatestCollateralRebalancingPool>;
  /** fetch data from the table: "laplace.latest_fixed_weight_pool_v1_01" */
  laplace_latest_fixed_weight_pool_v1_01: Array<LaplaceLatestFixedWeightPoolV1_01>;
  /** fetch aggregated fields from the table: "laplace.latest_fixed_weight_pool_v1_01" */
  laplace_latest_fixed_weight_pool_v1_01_aggregate: LaplaceLatestFixedWeightPoolV1_01Aggregate;
  /** fetch data from the table: "laplace.latest_fixed_weight_pool_v1_01" using primary key columns */
  laplace_latest_fixed_weight_pool_v1_01_by_pk?: Maybe<LaplaceLatestFixedWeightPoolV1_01>;
  /** fetch data from the table in a streaming manner: "laplace.latest_fixed_weight_pool_v1_01" */
  laplace_latest_fixed_weight_pool_v1_01_stream: Array<LaplaceLatestFixedWeightPoolV1_01>;
  /** fetch data from the table: "laplace.latest_pool_stats" */
  laplace_latest_pool_stats: Array<LaplaceLatestPoolStats>;
  /** fetch aggregated fields from the table: "laplace.latest_pool_stats" */
  laplace_latest_pool_stats_aggregate: LaplaceLatestPoolStatsAggregate;
  /** fetch data from the table: "laplace.latest_pool_stats" using primary key columns */
  laplace_latest_pool_stats_by_pk?: Maybe<LaplaceLatestPoolStats>;
  /** fetch data from the table in a streaming manner: "laplace.latest_pool_stats" */
  laplace_latest_pool_stats_stream: Array<LaplaceLatestPoolStats>;
  /** fetch data from the table: "laplace.latest_simple_weight_pool_alex" */
  laplace_latest_simple_weight_pool_alex: Array<LaplaceLatestSimpleWeightPoolAlex>;
  /** fetch aggregated fields from the table: "laplace.latest_simple_weight_pool_alex" */
  laplace_latest_simple_weight_pool_alex_aggregate: LaplaceLatestSimpleWeightPoolAlexAggregate;
  /** fetch data from the table: "laplace.latest_simple_weight_pool_alex" using primary key columns */
  laplace_latest_simple_weight_pool_alex_by_pk?: Maybe<LaplaceLatestSimpleWeightPoolAlex>;
  /** fetch data from the table in a streaming manner: "laplace.latest_simple_weight_pool_alex" */
  laplace_latest_simple_weight_pool_alex_stream: Array<LaplaceLatestSimpleWeightPoolAlex>;
  /** fetch data from the table: "laplace.latest_yield_token_pool" */
  laplace_latest_yield_token_pool: Array<LaplaceLatestYieldTokenPool>;
  /** fetch aggregated fields from the table: "laplace.latest_yield_token_pool" */
  laplace_latest_yield_token_pool_aggregate: LaplaceLatestYieldTokenPoolAggregate;
  /** fetch data from the table: "laplace.latest_yield_token_pool" using primary key columns */
  laplace_latest_yield_token_pool_by_pk?: Maybe<LaplaceLatestYieldTokenPool>;
  /** fetch data from the table in a streaming manner: "laplace.latest_yield_token_pool" */
  laplace_latest_yield_token_pool_stream: Array<LaplaceLatestYieldTokenPool>;
  /** fetch data from the table: "laplace.oracle_instant_price" */
  laplace_oracle_instant_price: Array<LaplaceOracleInstantPrice>;
  /** fetch aggregated fields from the table: "laplace.oracle_instant_price" */
  laplace_oracle_instant_price_aggregate: LaplaceOracleInstantPriceAggregate;
  /** fetch data from the table: "laplace.oracle_instant_price" using primary key columns */
  laplace_oracle_instant_price_by_pk?: Maybe<LaplaceOracleInstantPrice>;
  /** fetch data from the table in a streaming manner: "laplace.oracle_instant_price" */
  laplace_oracle_instant_price_stream: Array<LaplaceOracleInstantPrice>;
  /** fetch data from the table: "laplace.oracle_resilient_price" */
  laplace_oracle_resilient_price: Array<LaplaceOracleResilientPrice>;
  /** fetch aggregated fields from the table: "laplace.oracle_resilient_price" */
  laplace_oracle_resilient_price_aggregate: LaplaceOracleResilientPriceAggregate;
  /** fetch data from the table: "laplace.oracle_resilient_price" using primary key columns */
  laplace_oracle_resilient_price_by_pk?: Maybe<LaplaceOracleResilientPrice>;
  /** fetch data from the table in a streaming manner: "laplace.oracle_resilient_price" */
  laplace_oracle_resilient_price_stream: Array<LaplaceOracleResilientPrice>;
  /** fetch data from the table: "laplace.oracle_token_price" */
  laplace_oracle_token_price: Array<LaplaceOracleTokenPrice>;
  /** fetch aggregated fields from the table: "laplace.oracle_token_price" */
  laplace_oracle_token_price_aggregate: LaplaceOracleTokenPriceAggregate;
  /** fetch data from the table: "laplace.oracle_token_price_resilient" */
  laplace_oracle_token_price_resilient: Array<LaplaceOracleTokenPriceResilient>;
  /** fetch aggregated fields from the table: "laplace.oracle_token_price_resilient" */
  laplace_oracle_token_price_resilient_aggregate: LaplaceOracleTokenPriceResilientAggregate;
  /** fetch data from the table in a streaming manner: "laplace.oracle_token_price_resilient" */
  laplace_oracle_token_price_resilient_stream: Array<LaplaceOracleTokenPriceResilient>;
  /** fetch data from the table in a streaming manner: "laplace.oracle_token_price" */
  laplace_oracle_token_price_stream: Array<LaplaceOracleTokenPrice>;
  /** fetch data from the table: "laplace.pool_stats" */
  laplace_pool_stats: Array<LaplacePoolStats>;
  /** fetch aggregated fields from the table: "laplace.pool_stats" */
  laplace_pool_stats_aggregate: LaplacePoolStatsAggregate;
  /** fetch data from the table: "laplace.pool_stats" using primary key columns */
  laplace_pool_stats_by_pk?: Maybe<LaplacePoolStats>;
  /** fetch data from the table in a streaming manner: "laplace.pool_stats" */
  laplace_pool_stats_stream: Array<LaplacePoolStats>;
  /** fetch data from the table: "laplace.reward_cycle_stats" */
  laplace_reward_cycle_stats: Array<LaplaceRewardCycleStats>;
  /** fetch aggregated fields from the table: "laplace.reward_cycle_stats" */
  laplace_reward_cycle_stats_aggregate: LaplaceRewardCycleStatsAggregate;
  /** fetch data from the table: "laplace.reward_cycle_stats" using primary key columns */
  laplace_reward_cycle_stats_by_pk?: Maybe<LaplaceRewardCycleStats>;
  /** fetch data from the table in a streaming manner: "laplace.reward_cycle_stats" */
  laplace_reward_cycle_stats_stream: Array<LaplaceRewardCycleStats>;
  /** fetch data from the table: "laplace.simple_weight_pool_alex" */
  laplace_simple_weight_pool_alex: Array<LaplaceSimpleWeightPoolAlex>;
  /** fetch aggregated fields from the table: "laplace.simple_weight_pool_alex" */
  laplace_simple_weight_pool_alex_aggregate: LaplaceSimpleWeightPoolAlexAggregate;
  /** fetch data from the table: "laplace.simple_weight_pool_alex" using primary key columns */
  laplace_simple_weight_pool_alex_by_pk?: Maybe<LaplaceSimpleWeightPoolAlex>;
  /** fetch data from the table in a streaming manner: "laplace.simple_weight_pool_alex" */
  laplace_simple_weight_pool_alex_stream: Array<LaplaceSimpleWeightPoolAlex>;
  /** fetch data from the table: "laplace.stacks_blockchain_events" */
  laplace_stacks_blockchain_events: Array<LaplaceStacksBlockchainEvents>;
  /** fetch aggregated fields from the table: "laplace.stacks_blockchain_events" */
  laplace_stacks_blockchain_events_aggregate: LaplaceStacksBlockchainEventsAggregate;
  /** fetch data from the table in a streaming manner: "laplace.stacks_blockchain_events" */
  laplace_stacks_blockchain_events_stream: Array<LaplaceStacksBlockchainEvents>;
  /** fetch data from the table: "laplace.swap_records" */
  laplace_swap_records: Array<LaplaceSwapRecords>;
  /** fetch aggregated fields from the table: "laplace.swap_records" */
  laplace_swap_records_aggregate: LaplaceSwapRecordsAggregate;
  /** fetch data from the table: "laplace.swap_records" using primary key columns */
  laplace_swap_records_by_pk?: Maybe<LaplaceSwapRecords>;
  /** fetch data from the table in a streaming manner: "laplace.swap_records" */
  laplace_swap_records_stream: Array<LaplaceSwapRecords>;
  /** fetch data from the table: "laplace.sync_status" */
  laplace_sync_status: Array<LaplaceSyncStatus>;
  /** fetch aggregated fields from the table: "laplace.sync_status" */
  laplace_sync_status_aggregate: LaplaceSyncStatusAggregate;
  /** fetch data from the table: "laplace.sync_status" using primary key columns */
  laplace_sync_status_by_pk?: Maybe<LaplaceSyncStatus>;
  /** fetch data from the table in a streaming manner: "laplace.sync_status" */
  laplace_sync_status_stream: Array<LaplaceSyncStatus>;
  /** fetch data from the table: "laplace.synced_blocks" */
  laplace_synced_blocks: Array<LaplaceSyncedBlocks>;
  /** fetch aggregated fields from the table: "laplace.synced_blocks" */
  laplace_synced_blocks_aggregate: LaplaceSyncedBlocksAggregate;
  /** fetch data from the table: "laplace.synced_blocks" using primary key columns */
  laplace_synced_blocks_by_pk?: Maybe<LaplaceSyncedBlocks>;
  /** fetch data from the table in a streaming manner: "laplace.synced_blocks" */
  laplace_synced_blocks_stream: Array<LaplaceSyncedBlocks>;
  /** fetch data from the table: "laplace.token_stats" */
  laplace_token_stats: Array<LaplaceTokenStats>;
  /** fetch aggregated fields from the table: "laplace.token_stats" */
  laplace_token_stats_aggregate: LaplaceTokenStatsAggregate;
  /** fetch data from the table: "laplace.token_stats" using primary key columns */
  laplace_token_stats_by_pk?: Maybe<LaplaceTokenStats>;
  /** fetch data from the table in a streaming manner: "laplace.token_stats" */
  laplace_token_stats_stream: Array<LaplaceTokenStats>;
  /** fetch data from the table: "laplace.token_tvl" */
  laplace_token_tvl: Array<LaplaceTokenTvl>;
  /** fetch aggregated fields from the table: "laplace.token_tvl" */
  laplace_token_tvl_aggregate: LaplaceTokenTvlAggregate;
  /** fetch data from the table: "laplace.token_tvl" using primary key columns */
  laplace_token_tvl_by_pk?: Maybe<LaplaceTokenTvl>;
  /** fetch data from the table in a streaming manner: "laplace.token_tvl" */
  laplace_token_tvl_stream: Array<LaplaceTokenTvl>;
  /** fetch data from the table: "laplace.yield_token_pool" */
  laplace_yield_token_pool: Array<LaplaceYieldTokenPool>;
  /** fetch aggregated fields from the table: "laplace.yield_token_pool" */
  laplace_yield_token_pool_aggregate: LaplaceYieldTokenPoolAggregate;
  /** fetch data from the table: "laplace.yield_token_pool" using primary key columns */
  laplace_yield_token_pool_by_pk?: Maybe<LaplaceYieldTokenPool>;
  /** fetch data from the table in a streaming manner: "laplace.yield_token_pool" */
  laplace_yield_token_pool_stream: Array<LaplaceYieldTokenPool>;
  /** fetch data from the table: "public_dbt.autoalex_apower_distribution" */
  public_dbt_autoalex_apower_distribution: Array<PublicDbtAutoalexApowerDistribution>;
  /** fetch aggregated fields from the table: "public_dbt.autoalex_apower_distribution" */
  public_dbt_autoalex_apower_distribution_aggregate: PublicDbtAutoalexApowerDistributionAggregate;
  /** fetch data from the table in a streaming manner: "public_dbt.autoalex_apower_distribution" */
  public_dbt_autoalex_apower_distribution_stream: Array<PublicDbtAutoalexApowerDistribution>;
  /** fetch data from the table: "public_dbt.autoalex_claim_and_stake" */
  public_dbt_autoalex_claim_and_stake: Array<PublicDbtAutoalexClaimAndStake>;
  /** fetch aggregated fields from the table: "public_dbt.autoalex_claim_and_stake" */
  public_dbt_autoalex_claim_and_stake_aggregate: PublicDbtAutoalexClaimAndStakeAggregate;
  /** fetch data from the table in a streaming manner: "public_dbt.autoalex_claim_and_stake" */
  public_dbt_autoalex_claim_and_stake_stream: Array<PublicDbtAutoalexClaimAndStake>;
  /** fetch data from the table: "public_dbt.autoalex_lockdrop_snapshot_config" */
  public_dbt_autoalex_lockdrop_snapshot_config: Array<PublicDbtAutoalexLockdropSnapshotConfig>;
  /** fetch aggregated fields from the table: "public_dbt.autoalex_lockdrop_snapshot_config" */
  public_dbt_autoalex_lockdrop_snapshot_config_aggregate: PublicDbtAutoalexLockdropSnapshotConfigAggregate;
  /** fetch data from the table in a streaming manner: "public_dbt.autoalex_lockdrop_snapshot_config" */
  public_dbt_autoalex_lockdrop_snapshot_config_stream: Array<PublicDbtAutoalexLockdropSnapshotConfig>;
  /** fetch data from the table: "public_dbt.autoalex_snapshot_config" */
  public_dbt_autoalex_snapshot_config: Array<PublicDbtAutoalexSnapshotConfig>;
  /** fetch aggregated fields from the table: "public_dbt.autoalex_snapshot_config" */
  public_dbt_autoalex_snapshot_config_aggregate: PublicDbtAutoalexSnapshotConfigAggregate;
  /** fetch data from the table in a streaming manner: "public_dbt.autoalex_snapshot_config" */
  public_dbt_autoalex_snapshot_config_stream: Array<PublicDbtAutoalexSnapshotConfig>;
  /** fetch data from the table: "public_dbt.dim_autoalex_apower_cycle_reward_status" */
  public_dbt_dim_autoalex_apower_cycle_reward_status: Array<PublicDbtDimAutoalexApowerCycleRewardStatus>;
  /** fetch aggregated fields from the table: "public_dbt.dim_autoalex_apower_cycle_reward_status" */
  public_dbt_dim_autoalex_apower_cycle_reward_status_aggregate: PublicDbtDimAutoalexApowerCycleRewardStatusAggregate;
  /** fetch data from the table in a streaming manner: "public_dbt.dim_autoalex_apower_cycle_reward_status" */
  public_dbt_dim_autoalex_apower_cycle_reward_status_stream: Array<PublicDbtDimAutoalexApowerCycleRewardStatus>;
  /** fetch data from the table: "public_dbt.dim_balance_alex_staked_lockdrop_offets" */
  public_dbt_dim_balance_alex_staked_lockdrop_offets: Array<PublicDbtDimBalanceAlexStakedLockdropOffets>;
  /** fetch aggregated fields from the table: "public_dbt.dim_balance_alex_staked_lockdrop_offets" */
  public_dbt_dim_balance_alex_staked_lockdrop_offets_aggregate: PublicDbtDimBalanceAlexStakedLockdropOffetsAggregate;
  /** fetch data from the table in a streaming manner: "public_dbt.dim_balance_alex_staked_lockdrop_offets" */
  public_dbt_dim_balance_alex_staked_lockdrop_offets_stream: Array<PublicDbtDimBalanceAlexStakedLockdropOffets>;
  /** fetch data from the table: "public_dbt.dim_balance_autoalex_apower_distribution" */
  public_dbt_dim_balance_autoalex_apower_distribution: Array<PublicDbtDimBalanceAutoalexApowerDistribution>;
  /** fetch aggregated fields from the table: "public_dbt.dim_balance_autoalex_apower_distribution" */
  public_dbt_dim_balance_autoalex_apower_distribution_aggregate: PublicDbtDimBalanceAutoalexApowerDistributionAggregate;
  /** fetch data from the table in a streaming manner: "public_dbt.dim_balance_autoalex_apower_distribution" */
  public_dbt_dim_balance_autoalex_apower_distribution_stream: Array<PublicDbtDimBalanceAutoalexApowerDistribution>;
  /** fetch data from the table: "public_dbt.dim_balance_autoalex_lockdrop2_rank_snapshot_view" */
  public_dbt_dim_balance_autoalex_lockdrop2_rank_snapshot_view: Array<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotView>;
  /** fetch aggregated fields from the table: "public_dbt.dim_balance_autoalex_lockdrop2_rank_snapshot_view" */
  public_dbt_dim_balance_autoalex_lockdrop2_rank_snapshot_view_aggregate: PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewAggregate;
  /** fetch data from the table in a streaming manner: "public_dbt.dim_balance_autoalex_lockdrop2_rank_snapshot_view" */
  public_dbt_dim_balance_autoalex_lockdrop2_rank_snapshot_view_stream: Array<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotView>;
  /** fetch data from the table: "public_dbt.dim_balance_autoalex_lockdrop2_rank_view" */
  public_dbt_dim_balance_autoalex_lockdrop2_rank_view: Array<PublicDbtDimBalanceAutoalexLockdrop2RankView>;
  /** fetch aggregated fields from the table: "public_dbt.dim_balance_autoalex_lockdrop2_rank_view" */
  public_dbt_dim_balance_autoalex_lockdrop2_rank_view_aggregate: PublicDbtDimBalanceAutoalexLockdrop2RankViewAggregate;
  /** fetch data from the table in a streaming manner: "public_dbt.dim_balance_autoalex_lockdrop2_rank_view" */
  public_dbt_dim_balance_autoalex_lockdrop2_rank_view_stream: Array<PublicDbtDimBalanceAutoalexLockdrop2RankView>;
  /** fetch data from the table: "public_dbt.dim_balance_autoalex_rank_on_height_view" */
  public_dbt_dim_balance_autoalex_rank_on_height_view: Array<PublicDbtDimBalanceAutoalexRankOnHeightView>;
  /** fetch aggregated fields from the table: "public_dbt.dim_balance_autoalex_rank_on_height_view" */
  public_dbt_dim_balance_autoalex_rank_on_height_view_aggregate: PublicDbtDimBalanceAutoalexRankOnHeightViewAggregate;
  /** fetch data from the table in a streaming manner: "public_dbt.dim_balance_autoalex_rank_on_height_view" */
  public_dbt_dim_balance_autoalex_rank_on_height_view_stream: Array<PublicDbtDimBalanceAutoalexRankOnHeightView>;
  /** fetch data from the table: "public_dbt.dim_balance_autoalex_rank_snapshot_view" */
  public_dbt_dim_balance_autoalex_rank_snapshot_view: Array<PublicDbtDimBalanceAutoalexRankSnapshotView>;
  /** fetch aggregated fields from the table: "public_dbt.dim_balance_autoalex_rank_snapshot_view" */
  public_dbt_dim_balance_autoalex_rank_snapshot_view_aggregate: PublicDbtDimBalanceAutoalexRankSnapshotViewAggregate;
  /** fetch data from the table in a streaming manner: "public_dbt.dim_balance_autoalex_rank_snapshot_view" */
  public_dbt_dim_balance_autoalex_rank_snapshot_view_stream: Array<PublicDbtDimBalanceAutoalexRankSnapshotView>;
  /** fetch data from the table: "public_dbt.dim_balance_autoalex_rank_view" */
  public_dbt_dim_balance_autoalex_rank_view: Array<PublicDbtDimBalanceAutoalexRankView>;
  /** fetch aggregated fields from the table: "public_dbt.dim_balance_autoalex_rank_view" */
  public_dbt_dim_balance_autoalex_rank_view_aggregate: PublicDbtDimBalanceAutoalexRankViewAggregate;
  /** fetch data from the table in a streaming manner: "public_dbt.dim_balance_autoalex_rank_view" */
  public_dbt_dim_balance_autoalex_rank_view_stream: Array<PublicDbtDimBalanceAutoalexRankView>;
  /** fetch data from the table: "public_dbt.dim_idos_info" */
  public_dbt_dim_idos_info: Array<PublicDbtDimIdosInfo>;
  /** fetch aggregated fields from the table: "public_dbt.dim_idos_info" */
  public_dbt_dim_idos_info_aggregate: PublicDbtDimIdosInfoAggregate;
  /** fetch data from the table in a streaming manner: "public_dbt.dim_idos_info" */
  public_dbt_dim_idos_info_stream: Array<PublicDbtDimIdosInfo>;
  /** fetch data from the table: "smart_contracts" */
  smart_contracts: Array<SmartContracts>;
  /** fetch aggregated fields from the table: "smart_contracts" */
  smart_contracts_aggregate: SmartContractsAggregate;
  /** fetch data from the table: "smart_contracts" using primary key columns */
  smart_contracts_by_pk?: Maybe<SmartContracts>;
  /** fetch data from the table in a streaming manner: "smart_contracts" */
  smart_contracts_stream: Array<SmartContracts>;
  /** fetch data from the table: "stx_events" */
  stx_events: Array<StxEvents>;
  /** fetch aggregated fields from the table: "stx_events" */
  stx_events_aggregate: StxEventsAggregate;
  /** fetch data from the table: "stx_events" using primary key columns */
  stx_events_by_pk?: Maybe<StxEvents>;
  /** fetch data from the table in a streaming manner: "stx_events" */
  stx_events_stream: Array<StxEvents>;
  /** fetch data from the table: "txs" */
  txs: Array<Txs>;
  /** fetch aggregated fields from the table: "txs" */
  txs_aggregate: TxsAggregate;
  /** fetch data from the table: "txs" using primary key columns */
  txs_by_pk?: Maybe<Txs>;
  /** fetch data from the table in a streaming manner: "txs" */
  txs_stream: Array<Txs>;
};


export type SubscriptionRootBlocksArgs = {
  distinct_on?: InputMaybe<Array<BlocksSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<BlocksOrderBy>>;
  where?: InputMaybe<BlocksBoolExp>;
};


export type SubscriptionRootBlocksAggregateArgs = {
  distinct_on?: InputMaybe<Array<BlocksSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<BlocksOrderBy>>;
  where?: InputMaybe<BlocksBoolExp>;
};


export type SubscriptionRootBlocksByPkArgs = {
  index_block_hash: Scalars['bytea'];
};


export type SubscriptionRootBlocksStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<BlocksStreamCursorInput>>;
  where?: InputMaybe<BlocksBoolExp>;
};


export type SubscriptionRootContractLogsArgs = {
  distinct_on?: InputMaybe<Array<ContractLogsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<ContractLogsOrderBy>>;
  where?: InputMaybe<ContractLogsBoolExp>;
};


export type SubscriptionRootContractLogsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ContractLogsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<ContractLogsOrderBy>>;
  where?: InputMaybe<ContractLogsBoolExp>;
};


export type SubscriptionRootContractLogsByPkArgs = {
  id: Scalars['Int'];
};


export type SubscriptionRootContractLogsStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<ContractLogsStreamCursorInput>>;
  where?: InputMaybe<ContractLogsBoolExp>;
};


export type SubscriptionRootFtEventsArgs = {
  distinct_on?: InputMaybe<Array<FtEventsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<FtEventsOrderBy>>;
  where?: InputMaybe<FtEventsBoolExp>;
};


export type SubscriptionRootFtEventsAggregateArgs = {
  distinct_on?: InputMaybe<Array<FtEventsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<FtEventsOrderBy>>;
  where?: InputMaybe<FtEventsBoolExp>;
};


export type SubscriptionRootFtEventsByPkArgs = {
  id: Scalars['Int'];
};


export type SubscriptionRootFtEventsStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<FtEventsStreamCursorInput>>;
  where?: InputMaybe<FtEventsBoolExp>;
};


export type SubscriptionRootLaplaceAlexReservePoolsArgs = {
  distinct_on?: InputMaybe<Array<LaplaceAlexReservePoolsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceAlexReservePoolsOrderBy>>;
  where?: InputMaybe<LaplaceAlexReservePoolsBoolExp>;
};


export type SubscriptionRootLaplaceAlexReservePoolsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceAlexReservePoolsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceAlexReservePoolsOrderBy>>;
  where?: InputMaybe<LaplaceAlexReservePoolsBoolExp>;
};


export type SubscriptionRootLaplaceAlexReservePoolsByPkArgs = {
  block_height: Scalars['Int'];
  token_deployer_address: Scalars['String'];
  token_name: Scalars['String'];
};


export type SubscriptionRootLaplaceAlexReservePoolsStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceAlexReservePoolsStreamCursorInput>>;
  where?: InputMaybe<LaplaceAlexReservePoolsBoolExp>;
};


export type SubscriptionRootLaplaceAlexUsdPricingArgs = {
  distinct_on?: InputMaybe<Array<LaplaceAlexUsdPricingSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceAlexUsdPricingOrderBy>>;
  where?: InputMaybe<LaplaceAlexUsdPricingBoolExp>;
};


export type SubscriptionRootLaplaceAlexUsdPricingAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceAlexUsdPricingSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceAlexUsdPricingOrderBy>>;
  where?: InputMaybe<LaplaceAlexUsdPricingBoolExp>;
};


export type SubscriptionRootLaplaceAlexUsdPricingStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceAlexUsdPricingStreamCursorInput>>;
  where?: InputMaybe<LaplaceAlexUsdPricingBoolExp>;
};


export type SubscriptionRootLaplaceBorrowDepositDailyStatsArgs = {
  distinct_on?: InputMaybe<Array<LaplaceBorrowDepositDailyStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceBorrowDepositDailyStatsOrderBy>>;
  where?: InputMaybe<LaplaceBorrowDepositDailyStatsBoolExp>;
};


export type SubscriptionRootLaplaceBorrowDepositDailyStatsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceBorrowDepositDailyStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceBorrowDepositDailyStatsOrderBy>>;
  where?: InputMaybe<LaplaceBorrowDepositDailyStatsBoolExp>;
};


export type SubscriptionRootLaplaceBorrowDepositDailyStatsByPkArgs = {
  day: Scalars['numeric'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};


export type SubscriptionRootLaplaceBorrowDepositDailyStatsStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceBorrowDepositDailyStatsStreamCursorInput>>;
  where?: InputMaybe<LaplaceBorrowDepositDailyStatsBoolExp>;
};


export type SubscriptionRootLaplaceBorrowDepositHourlyStatsArgs = {
  distinct_on?: InputMaybe<Array<LaplaceBorrowDepositHourlyStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceBorrowDepositHourlyStatsOrderBy>>;
  where?: InputMaybe<LaplaceBorrowDepositHourlyStatsBoolExp>;
};


export type SubscriptionRootLaplaceBorrowDepositHourlyStatsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceBorrowDepositHourlyStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceBorrowDepositHourlyStatsOrderBy>>;
  where?: InputMaybe<LaplaceBorrowDepositHourlyStatsBoolExp>;
};


export type SubscriptionRootLaplaceBorrowDepositHourlyStatsByPkArgs = {
  expiry: Scalars['numeric'];
  hour: Scalars['numeric'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};


export type SubscriptionRootLaplaceBorrowDepositHourlyStatsStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceBorrowDepositHourlyStatsStreamCursorInput>>;
  where?: InputMaybe<LaplaceBorrowDepositHourlyStatsBoolExp>;
};


export type SubscriptionRootLaplaceBorrowDepositStatsArgs = {
  distinct_on?: InputMaybe<Array<LaplaceBorrowDepositStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceBorrowDepositStatsOrderBy>>;
  where?: InputMaybe<LaplaceBorrowDepositStatsBoolExp>;
};


export type SubscriptionRootLaplaceBorrowDepositStatsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceBorrowDepositStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceBorrowDepositStatsOrderBy>>;
  where?: InputMaybe<LaplaceBorrowDepositStatsBoolExp>;
};


export type SubscriptionRootLaplaceBorrowDepositStatsByPkArgs = {
  block_height: Scalars['numeric'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};


export type SubscriptionRootLaplaceBorrowDepositStatsStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceBorrowDepositStatsStreamCursorInput>>;
  where?: InputMaybe<LaplaceBorrowDepositStatsBoolExp>;
};


export type SubscriptionRootLaplaceCoinGeckoArgs = {
  distinct_on?: InputMaybe<Array<LaplaceCoinGeckoSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceCoinGeckoOrderBy>>;
  where?: InputMaybe<LaplaceCoinGeckoBoolExp>;
};


export type SubscriptionRootLaplaceCoinGeckoAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceCoinGeckoSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceCoinGeckoOrderBy>>;
  where?: InputMaybe<LaplaceCoinGeckoBoolExp>;
};


export type SubscriptionRootLaplaceCoinGeckoArchiveArgs = {
  distinct_on?: InputMaybe<Array<LaplaceCoinGeckoArchiveSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceCoinGeckoArchiveOrderBy>>;
  where?: InputMaybe<LaplaceCoinGeckoArchiveBoolExp>;
};


export type SubscriptionRootLaplaceCoinGeckoArchiveAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceCoinGeckoArchiveSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceCoinGeckoArchiveOrderBy>>;
  where?: InputMaybe<LaplaceCoinGeckoArchiveBoolExp>;
};


export type SubscriptionRootLaplaceCoinGeckoArchiveByPkArgs = {
  timestamp: Scalars['timestamptz'];
  token: Scalars['String'];
};


export type SubscriptionRootLaplaceCoinGeckoArchiveStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceCoinGeckoArchiveStreamCursorInput>>;
  where?: InputMaybe<LaplaceCoinGeckoArchiveBoolExp>;
};


export type SubscriptionRootLaplaceCoinGeckoByPkArgs = {
  token: Scalars['String'];
};


export type SubscriptionRootLaplaceCoinGeckoStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceCoinGeckoStreamCursorInput>>;
  where?: InputMaybe<LaplaceCoinGeckoBoolExp>;
};


export type SubscriptionRootLaplaceCollateralRebalancingPoolArgs = {
  distinct_on?: InputMaybe<Array<LaplaceCollateralRebalancingPoolSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceCollateralRebalancingPoolOrderBy>>;
  where?: InputMaybe<LaplaceCollateralRebalancingPoolBoolExp>;
};


export type SubscriptionRootLaplaceCollateralRebalancingPoolAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceCollateralRebalancingPoolSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceCollateralRebalancingPoolOrderBy>>;
  where?: InputMaybe<LaplaceCollateralRebalancingPoolBoolExp>;
};


export type SubscriptionRootLaplaceCollateralRebalancingPoolByPkArgs = {
  block_height: Scalars['numeric'];
  expiry: Scalars['numeric'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};


export type SubscriptionRootLaplaceCollateralRebalancingPoolStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceCollateralRebalancingPoolStreamCursorInput>>;
  where?: InputMaybe<LaplaceCollateralRebalancingPoolBoolExp>;
};


export type SubscriptionRootLaplaceConfigContractsArgs = {
  distinct_on?: InputMaybe<Array<LaplaceConfigContractsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceConfigContractsOrderBy>>;
  where?: InputMaybe<LaplaceConfigContractsBoolExp>;
};


export type SubscriptionRootLaplaceConfigContractsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceConfigContractsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceConfigContractsOrderBy>>;
  where?: InputMaybe<LaplaceConfigContractsBoolExp>;
};


export type SubscriptionRootLaplaceConfigContractsByPkArgs = {
  contract: Scalars['String'];
};


export type SubscriptionRootLaplaceConfigContractsStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceConfigContractsStreamCursorInput>>;
  where?: InputMaybe<LaplaceConfigContractsBoolExp>;
};


export type SubscriptionRootLaplaceContractCallsArgs = {
  distinct_on?: InputMaybe<Array<LaplaceContractCallsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceContractCallsOrderBy>>;
  where?: InputMaybe<LaplaceContractCallsBoolExp>;
};


export type SubscriptionRootLaplaceContractCallsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceContractCallsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceContractCallsOrderBy>>;
  where?: InputMaybe<LaplaceContractCallsBoolExp>;
};


export type SubscriptionRootLaplaceContractCallsByPkArgs = {
  block_height: Scalars['Int'];
  tx_id: Scalars['bytea'];
};


export type SubscriptionRootLaplaceContractCallsStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceContractCallsStreamCursorInput>>;
  where?: InputMaybe<LaplaceContractCallsBoolExp>;
};


export type SubscriptionRootLaplaceCurrentTokenPriceArgs = {
  distinct_on?: InputMaybe<Array<LaplaceCurrentTokenPriceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceCurrentTokenPriceOrderBy>>;
  where?: InputMaybe<LaplaceCurrentTokenPriceBoolExp>;
};


export type SubscriptionRootLaplaceCurrentTokenPriceAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceCurrentTokenPriceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceCurrentTokenPriceOrderBy>>;
  where?: InputMaybe<LaplaceCurrentTokenPriceBoolExp>;
};


export type SubscriptionRootLaplaceCurrentTokenPriceStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceCurrentTokenPriceStreamCursorInput>>;
  where?: InputMaybe<LaplaceCurrentTokenPriceBoolExp>;
};


export type SubscriptionRootLaplaceDeployedContractsArgs = {
  distinct_on?: InputMaybe<Array<LaplaceDeployedContractsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceDeployedContractsOrderBy>>;
  where?: InputMaybe<LaplaceDeployedContractsBoolExp>;
};


export type SubscriptionRootLaplaceDeployedContractsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceDeployedContractsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceDeployedContractsOrderBy>>;
  where?: InputMaybe<LaplaceDeployedContractsBoolExp>;
};


export type SubscriptionRootLaplaceDeployedContractsByPkArgs = {
  contract_name: Scalars['String'];
  deployer_address: Scalars['String'];
  tx_id: Scalars['String'];
};


export type SubscriptionRootLaplaceDeployedContractsStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceDeployedContractsStreamCursorInput>>;
  where?: InputMaybe<LaplaceDeployedContractsBoolExp>;
};


export type SubscriptionRootLaplaceExternalTokenPriceArgs = {
  distinct_on?: InputMaybe<Array<LaplaceExternalTokenPriceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceExternalTokenPriceOrderBy>>;
  where?: InputMaybe<LaplaceExternalTokenPriceBoolExp>;
};


export type SubscriptionRootLaplaceExternalTokenPriceAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceExternalTokenPriceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceExternalTokenPriceOrderBy>>;
  where?: InputMaybe<LaplaceExternalTokenPriceBoolExp>;
};


export type SubscriptionRootLaplaceExternalTokenPriceByPkArgs = {
  token_name: Scalars['String'];
};


export type SubscriptionRootLaplaceExternalTokenPriceStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceExternalTokenPriceStreamCursorInput>>;
  where?: InputMaybe<LaplaceExternalTokenPriceBoolExp>;
};


export type SubscriptionRootLaplaceFixedWeightPoolV1_01Args = {
  distinct_on?: InputMaybe<Array<LaplaceFixedWeightPoolV1_01SelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceFixedWeightPoolV1_01OrderBy>>;
  where?: InputMaybe<LaplaceFixedWeightPoolV1_01BoolExp>;
};


export type SubscriptionRootLaplaceFixedWeightPoolV1_01AggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceFixedWeightPoolV1_01SelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceFixedWeightPoolV1_01OrderBy>>;
  where?: InputMaybe<LaplaceFixedWeightPoolV1_01BoolExp>;
};


export type SubscriptionRootLaplaceFixedWeightPoolV1_01ByPkArgs = {
  block_height: Scalars['Int'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
  weight_x: Scalars['bigint'];
  weight_y: Scalars['bigint'];
};


export type SubscriptionRootLaplaceFixedWeightPoolV1_01StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceFixedWeightPoolV1_01StreamCursorInput>>;
  where?: InputMaybe<LaplaceFixedWeightPoolV1_01BoolExp>;
};


export type SubscriptionRootLaplaceHistoryPriceDataArgs = {
  distinct_on?: InputMaybe<Array<LaplaceHistoryPriceDataSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceHistoryPriceDataOrderBy>>;
  where?: InputMaybe<LaplaceHistoryPriceDataBoolExp>;
};


export type SubscriptionRootLaplaceHistoryPriceDataAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceHistoryPriceDataSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceHistoryPriceDataOrderBy>>;
  where?: InputMaybe<LaplaceHistoryPriceDataBoolExp>;
};


export type SubscriptionRootLaplaceHistoryPriceDataByPkArgs = {
  block_height: Scalars['numeric'];
  token: Scalars['String'];
};


export type SubscriptionRootLaplaceHistoryPriceDataStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceHistoryPriceDataStreamCursorInput>>;
  where?: InputMaybe<LaplaceHistoryPriceDataBoolExp>;
};


export type SubscriptionRootLaplaceHistoryStakingStatsArgs = {
  distinct_on?: InputMaybe<Array<LaplaceHistoryStakingStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceHistoryStakingStatsOrderBy>>;
  where?: InputMaybe<LaplaceHistoryStakingStatsBoolExp>;
};


export type SubscriptionRootLaplaceHistoryStakingStatsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceHistoryStakingStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceHistoryStakingStatsOrderBy>>;
  where?: InputMaybe<LaplaceHistoryStakingStatsBoolExp>;
};


export type SubscriptionRootLaplaceHistoryStakingStatsByPkArgs = {
  cycle: Scalars['Int'];
  token: Scalars['String'];
};


export type SubscriptionRootLaplaceHistoryStakingStatsStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceHistoryStakingStatsStreamCursorInput>>;
  where?: InputMaybe<LaplaceHistoryStakingStatsBoolExp>;
};


export type SubscriptionRootLaplaceIdoPoolCreationArgs = {
  distinct_on?: InputMaybe<Array<LaplaceIdoPoolCreationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceIdoPoolCreationOrderBy>>;
  where?: InputMaybe<LaplaceIdoPoolCreationBoolExp>;
};


export type SubscriptionRootLaplaceIdoPoolCreationAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceIdoPoolCreationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceIdoPoolCreationOrderBy>>;
  where?: InputMaybe<LaplaceIdoPoolCreationBoolExp>;
};


export type SubscriptionRootLaplaceIdoPoolCreationByPkArgs = {
  activation_threshold: Scalars['Int'];
  apower_per_ticket_in_fixed: Scalars['bigint'];
  claim_end_height: Scalars['Int'];
  ido_owner: Scalars['String'];
  ido_token: Scalars['String'];
  ido_tokens_per_ticket: Scalars['Int'];
  payment_token: Scalars['String'];
  registration_end_height: Scalars['Int'];
  registration_start_height: Scalars['Int'];
  tx_id: Scalars['String'];
};


export type SubscriptionRootLaplaceIdoPoolCreationStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceIdoPoolCreationStreamCursorInput>>;
  where?: InputMaybe<LaplaceIdoPoolCreationBoolExp>;
};


export type SubscriptionRootLaplaceIdoRegisterArgs = {
  distinct_on?: InputMaybe<Array<LaplaceIdoRegisterSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceIdoRegisterOrderBy>>;
  where?: InputMaybe<LaplaceIdoRegisterBoolExp>;
};


export type SubscriptionRootLaplaceIdoRegisterAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceIdoRegisterSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceIdoRegisterOrderBy>>;
  where?: InputMaybe<LaplaceIdoRegisterBoolExp>;
};


export type SubscriptionRootLaplaceIdoRegisterByPkArgs = {
  block_height: Scalars['Int'];
  tx_id: Scalars['bytea'];
};


export type SubscriptionRootLaplaceIdoRegisterStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceIdoRegisterStreamCursorInput>>;
  where?: InputMaybe<LaplaceIdoRegisterBoolExp>;
};


export type SubscriptionRootLaplaceLatestAlexReservePoolsArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestAlexReservePoolsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestAlexReservePoolsOrderBy>>;
  where?: InputMaybe<LaplaceLatestAlexReservePoolsBoolExp>;
};


export type SubscriptionRootLaplaceLatestAlexReservePoolsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestAlexReservePoolsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestAlexReservePoolsOrderBy>>;
  where?: InputMaybe<LaplaceLatestAlexReservePoolsBoolExp>;
};


export type SubscriptionRootLaplaceLatestAlexReservePoolsByPkArgs = {
  token_deployer_address: Scalars['String'];
  token_name: Scalars['String'];
};


export type SubscriptionRootLaplaceLatestAlexReservePoolsStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceLatestAlexReservePoolsStreamCursorInput>>;
  where?: InputMaybe<LaplaceLatestAlexReservePoolsBoolExp>;
};


export type SubscriptionRootLaplaceLatestAutoAlexArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestAutoAlexSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestAutoAlexOrderBy>>;
  where?: InputMaybe<LaplaceLatestAutoAlexBoolExp>;
};


export type SubscriptionRootLaplaceLatestAutoAlexAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestAutoAlexSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestAutoAlexOrderBy>>;
  where?: InputMaybe<LaplaceLatestAutoAlexBoolExp>;
};


export type SubscriptionRootLaplaceLatestAutoAlexByPkArgs = {
  token_name: Scalars['String'];
};


export type SubscriptionRootLaplaceLatestAutoAlexStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceLatestAutoAlexStreamCursorInput>>;
  where?: InputMaybe<LaplaceLatestAutoAlexBoolExp>;
};


export type SubscriptionRootLaplaceLatestCollateralPerShareArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestCollateralPerShareSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestCollateralPerShareOrderBy>>;
  where?: InputMaybe<LaplaceLatestCollateralPerShareBoolExp>;
};


export type SubscriptionRootLaplaceLatestCollateralPerShareAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestCollateralPerShareSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestCollateralPerShareOrderBy>>;
  where?: InputMaybe<LaplaceLatestCollateralPerShareBoolExp>;
};


export type SubscriptionRootLaplaceLatestCollateralPerShareByPkArgs = {
  expiry: Scalars['numeric'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};


export type SubscriptionRootLaplaceLatestCollateralPerShareStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceLatestCollateralPerShareStreamCursorInput>>;
  where?: InputMaybe<LaplaceLatestCollateralPerShareBoolExp>;
};


export type SubscriptionRootLaplaceLatestCollateralRebalancingPoolArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestCollateralRebalancingPoolSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestCollateralRebalancingPoolOrderBy>>;
  where?: InputMaybe<LaplaceLatestCollateralRebalancingPoolBoolExp>;
};


export type SubscriptionRootLaplaceLatestCollateralRebalancingPoolAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestCollateralRebalancingPoolSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestCollateralRebalancingPoolOrderBy>>;
  where?: InputMaybe<LaplaceLatestCollateralRebalancingPoolBoolExp>;
};


export type SubscriptionRootLaplaceLatestCollateralRebalancingPoolByPkArgs = {
  expiry: Scalars['numeric'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};


export type SubscriptionRootLaplaceLatestCollateralRebalancingPoolStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceLatestCollateralRebalancingPoolStreamCursorInput>>;
  where?: InputMaybe<LaplaceLatestCollateralRebalancingPoolBoolExp>;
};


export type SubscriptionRootLaplaceLatestFixedWeightPoolV1_01Args = {
  distinct_on?: InputMaybe<Array<LaplaceLatestFixedWeightPoolV1_01SelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestFixedWeightPoolV1_01OrderBy>>;
  where?: InputMaybe<LaplaceLatestFixedWeightPoolV1_01BoolExp>;
};


export type SubscriptionRootLaplaceLatestFixedWeightPoolV1_01AggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestFixedWeightPoolV1_01SelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestFixedWeightPoolV1_01OrderBy>>;
  where?: InputMaybe<LaplaceLatestFixedWeightPoolV1_01BoolExp>;
};


export type SubscriptionRootLaplaceLatestFixedWeightPoolV1_01ByPkArgs = {
  token_x: Scalars['String'];
  token_y: Scalars['String'];
  weight_x: Scalars['bigint'];
  weight_y: Scalars['bigint'];
};


export type SubscriptionRootLaplaceLatestFixedWeightPoolV1_01StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceLatestFixedWeightPoolV1_01StreamCursorInput>>;
  where?: InputMaybe<LaplaceLatestFixedWeightPoolV1_01BoolExp>;
};


export type SubscriptionRootLaplaceLatestPoolStatsArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestPoolStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestPoolStatsOrderBy>>;
  where?: InputMaybe<LaplaceLatestPoolStatsBoolExp>;
};


export type SubscriptionRootLaplaceLatestPoolStatsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestPoolStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestPoolStatsOrderBy>>;
  where?: InputMaybe<LaplaceLatestPoolStatsBoolExp>;
};


export type SubscriptionRootLaplaceLatestPoolStatsByPkArgs = {
  pool_token: Scalars['String'];
};


export type SubscriptionRootLaplaceLatestPoolStatsStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceLatestPoolStatsStreamCursorInput>>;
  where?: InputMaybe<LaplaceLatestPoolStatsBoolExp>;
};


export type SubscriptionRootLaplaceLatestSimpleWeightPoolAlexArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestSimpleWeightPoolAlexSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestSimpleWeightPoolAlexOrderBy>>;
  where?: InputMaybe<LaplaceLatestSimpleWeightPoolAlexBoolExp>;
};


export type SubscriptionRootLaplaceLatestSimpleWeightPoolAlexAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestSimpleWeightPoolAlexSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestSimpleWeightPoolAlexOrderBy>>;
  where?: InputMaybe<LaplaceLatestSimpleWeightPoolAlexBoolExp>;
};


export type SubscriptionRootLaplaceLatestSimpleWeightPoolAlexByPkArgs = {
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};


export type SubscriptionRootLaplaceLatestSimpleWeightPoolAlexStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceLatestSimpleWeightPoolAlexStreamCursorInput>>;
  where?: InputMaybe<LaplaceLatestSimpleWeightPoolAlexBoolExp>;
};


export type SubscriptionRootLaplaceLatestYieldTokenPoolArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestYieldTokenPoolSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestYieldTokenPoolOrderBy>>;
  where?: InputMaybe<LaplaceLatestYieldTokenPoolBoolExp>;
};


export type SubscriptionRootLaplaceLatestYieldTokenPoolAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceLatestYieldTokenPoolSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceLatestYieldTokenPoolOrderBy>>;
  where?: InputMaybe<LaplaceLatestYieldTokenPoolBoolExp>;
};


export type SubscriptionRootLaplaceLatestYieldTokenPoolByPkArgs = {
  expiry: Scalars['numeric'];
  yield_token: Scalars['String'];
};


export type SubscriptionRootLaplaceLatestYieldTokenPoolStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceLatestYieldTokenPoolStreamCursorInput>>;
  where?: InputMaybe<LaplaceLatestYieldTokenPoolBoolExp>;
};


export type SubscriptionRootLaplaceOracleInstantPriceArgs = {
  distinct_on?: InputMaybe<Array<LaplaceOracleInstantPriceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceOracleInstantPriceOrderBy>>;
  where?: InputMaybe<LaplaceOracleInstantPriceBoolExp>;
};


export type SubscriptionRootLaplaceOracleInstantPriceAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceOracleInstantPriceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceOracleInstantPriceOrderBy>>;
  where?: InputMaybe<LaplaceOracleInstantPriceBoolExp>;
};


export type SubscriptionRootLaplaceOracleInstantPriceByPkArgs = {
  block_height: Scalars['numeric'];
  pool_token: Scalars['String'];
  token: Scalars['String'];
};


export type SubscriptionRootLaplaceOracleInstantPriceStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceOracleInstantPriceStreamCursorInput>>;
  where?: InputMaybe<LaplaceOracleInstantPriceBoolExp>;
};


export type SubscriptionRootLaplaceOracleResilientPriceArgs = {
  distinct_on?: InputMaybe<Array<LaplaceOracleResilientPriceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceOracleResilientPriceOrderBy>>;
  where?: InputMaybe<LaplaceOracleResilientPriceBoolExp>;
};


export type SubscriptionRootLaplaceOracleResilientPriceAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceOracleResilientPriceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceOracleResilientPriceOrderBy>>;
  where?: InputMaybe<LaplaceOracleResilientPriceBoolExp>;
};


export type SubscriptionRootLaplaceOracleResilientPriceByPkArgs = {
  block_height: Scalars['numeric'];
  pool_token: Scalars['String'];
  token: Scalars['String'];
};


export type SubscriptionRootLaplaceOracleResilientPriceStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceOracleResilientPriceStreamCursorInput>>;
  where?: InputMaybe<LaplaceOracleResilientPriceBoolExp>;
};


export type SubscriptionRootLaplaceOracleTokenPriceArgs = {
  distinct_on?: InputMaybe<Array<LaplaceOracleTokenPriceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceOracleTokenPriceOrderBy>>;
  where?: InputMaybe<LaplaceOracleTokenPriceBoolExp>;
};


export type SubscriptionRootLaplaceOracleTokenPriceAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceOracleTokenPriceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceOracleTokenPriceOrderBy>>;
  where?: InputMaybe<LaplaceOracleTokenPriceBoolExp>;
};


export type SubscriptionRootLaplaceOracleTokenPriceResilientArgs = {
  distinct_on?: InputMaybe<Array<LaplaceOracleTokenPriceResilientSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceOracleTokenPriceResilientOrderBy>>;
  where?: InputMaybe<LaplaceOracleTokenPriceResilientBoolExp>;
};


export type SubscriptionRootLaplaceOracleTokenPriceResilientAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceOracleTokenPriceResilientSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceOracleTokenPriceResilientOrderBy>>;
  where?: InputMaybe<LaplaceOracleTokenPriceResilientBoolExp>;
};


export type SubscriptionRootLaplaceOracleTokenPriceResilientStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceOracleTokenPriceResilientStreamCursorInput>>;
  where?: InputMaybe<LaplaceOracleTokenPriceResilientBoolExp>;
};


export type SubscriptionRootLaplaceOracleTokenPriceStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceOracleTokenPriceStreamCursorInput>>;
  where?: InputMaybe<LaplaceOracleTokenPriceBoolExp>;
};


export type SubscriptionRootLaplacePoolStatsArgs = {
  distinct_on?: InputMaybe<Array<LaplacePoolStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplacePoolStatsOrderBy>>;
  where?: InputMaybe<LaplacePoolStatsBoolExp>;
};


export type SubscriptionRootLaplacePoolStatsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplacePoolStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplacePoolStatsOrderBy>>;
  where?: InputMaybe<LaplacePoolStatsBoolExp>;
};


export type SubscriptionRootLaplacePoolStatsByPkArgs = {
  block_height: Scalars['numeric'];
  pool_token: Scalars['String'];
};


export type SubscriptionRootLaplacePoolStatsStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplacePoolStatsStreamCursorInput>>;
  where?: InputMaybe<LaplacePoolStatsBoolExp>;
};


export type SubscriptionRootLaplaceRewardCycleStatsArgs = {
  distinct_on?: InputMaybe<Array<LaplaceRewardCycleStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceRewardCycleStatsOrderBy>>;
  where?: InputMaybe<LaplaceRewardCycleStatsBoolExp>;
};


export type SubscriptionRootLaplaceRewardCycleStatsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceRewardCycleStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceRewardCycleStatsOrderBy>>;
  where?: InputMaybe<LaplaceRewardCycleStatsBoolExp>;
};


export type SubscriptionRootLaplaceRewardCycleStatsByPkArgs = {
  block_height: Scalars['bigint'];
  token: Scalars['String'];
};


export type SubscriptionRootLaplaceRewardCycleStatsStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceRewardCycleStatsStreamCursorInput>>;
  where?: InputMaybe<LaplaceRewardCycleStatsBoolExp>;
};


export type SubscriptionRootLaplaceSimpleWeightPoolAlexArgs = {
  distinct_on?: InputMaybe<Array<LaplaceSimpleWeightPoolAlexSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceSimpleWeightPoolAlexOrderBy>>;
  where?: InputMaybe<LaplaceSimpleWeightPoolAlexBoolExp>;
};


export type SubscriptionRootLaplaceSimpleWeightPoolAlexAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceSimpleWeightPoolAlexSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceSimpleWeightPoolAlexOrderBy>>;
  where?: InputMaybe<LaplaceSimpleWeightPoolAlexBoolExp>;
};


export type SubscriptionRootLaplaceSimpleWeightPoolAlexByPkArgs = {
  block_height: Scalars['Int'];
  token_x: Scalars['String'];
  token_y: Scalars['String'];
};


export type SubscriptionRootLaplaceSimpleWeightPoolAlexStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceSimpleWeightPoolAlexStreamCursorInput>>;
  where?: InputMaybe<LaplaceSimpleWeightPoolAlexBoolExp>;
};


export type SubscriptionRootLaplaceStacksBlockchainEventsArgs = {
  distinct_on?: InputMaybe<Array<LaplaceStacksBlockchainEventsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceStacksBlockchainEventsOrderBy>>;
  where?: InputMaybe<LaplaceStacksBlockchainEventsBoolExp>;
};


export type SubscriptionRootLaplaceStacksBlockchainEventsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceStacksBlockchainEventsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceStacksBlockchainEventsOrderBy>>;
  where?: InputMaybe<LaplaceStacksBlockchainEventsBoolExp>;
};


export type SubscriptionRootLaplaceStacksBlockchainEventsStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceStacksBlockchainEventsStreamCursorInput>>;
  where?: InputMaybe<LaplaceStacksBlockchainEventsBoolExp>;
};


export type SubscriptionRootLaplaceSwapRecordsArgs = {
  distinct_on?: InputMaybe<Array<LaplaceSwapRecordsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceSwapRecordsOrderBy>>;
  where?: InputMaybe<LaplaceSwapRecordsBoolExp>;
};


export type SubscriptionRootLaplaceSwapRecordsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceSwapRecordsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceSwapRecordsOrderBy>>;
  where?: InputMaybe<LaplaceSwapRecordsBoolExp>;
};


export type SubscriptionRootLaplaceSwapRecordsByPkArgs = {
  event_index: Scalars['numeric'];
  tx_id: Scalars['String'];
};


export type SubscriptionRootLaplaceSwapRecordsStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceSwapRecordsStreamCursorInput>>;
  where?: InputMaybe<LaplaceSwapRecordsBoolExp>;
};


export type SubscriptionRootLaplaceSyncStatusArgs = {
  distinct_on?: InputMaybe<Array<LaplaceSyncStatusSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceSyncStatusOrderBy>>;
  where?: InputMaybe<LaplaceSyncStatusBoolExp>;
};


export type SubscriptionRootLaplaceSyncStatusAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceSyncStatusSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceSyncStatusOrderBy>>;
  where?: InputMaybe<LaplaceSyncStatusBoolExp>;
};


export type SubscriptionRootLaplaceSyncStatusByPkArgs = {
  key: Scalars['String'];
};


export type SubscriptionRootLaplaceSyncStatusStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceSyncStatusStreamCursorInput>>;
  where?: InputMaybe<LaplaceSyncStatusBoolExp>;
};


export type SubscriptionRootLaplaceSyncedBlocksArgs = {
  distinct_on?: InputMaybe<Array<LaplaceSyncedBlocksSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceSyncedBlocksOrderBy>>;
  where?: InputMaybe<LaplaceSyncedBlocksBoolExp>;
};


export type SubscriptionRootLaplaceSyncedBlocksAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceSyncedBlocksSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceSyncedBlocksOrderBy>>;
  where?: InputMaybe<LaplaceSyncedBlocksBoolExp>;
};


export type SubscriptionRootLaplaceSyncedBlocksByPkArgs = {
  block_height: Scalars['Int'];
};


export type SubscriptionRootLaplaceSyncedBlocksStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceSyncedBlocksStreamCursorInput>>;
  where?: InputMaybe<LaplaceSyncedBlocksBoolExp>;
};


export type SubscriptionRootLaplaceTokenStatsArgs = {
  distinct_on?: InputMaybe<Array<LaplaceTokenStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceTokenStatsOrderBy>>;
  where?: InputMaybe<LaplaceTokenStatsBoolExp>;
};


export type SubscriptionRootLaplaceTokenStatsAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceTokenStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceTokenStatsOrderBy>>;
  where?: InputMaybe<LaplaceTokenStatsBoolExp>;
};


export type SubscriptionRootLaplaceTokenStatsByPkArgs = {
  token_name: Scalars['String'];
};


export type SubscriptionRootLaplaceTokenStatsStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceTokenStatsStreamCursorInput>>;
  where?: InputMaybe<LaplaceTokenStatsBoolExp>;
};


export type SubscriptionRootLaplaceTokenTvlArgs = {
  distinct_on?: InputMaybe<Array<LaplaceTokenTvlSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceTokenTvlOrderBy>>;
  where?: InputMaybe<LaplaceTokenTvlBoolExp>;
};


export type SubscriptionRootLaplaceTokenTvlAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceTokenTvlSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceTokenTvlOrderBy>>;
  where?: InputMaybe<LaplaceTokenTvlBoolExp>;
};


export type SubscriptionRootLaplaceTokenTvlByPkArgs = {
  block_height: Scalars['numeric'];
  token: Scalars['String'];
};


export type SubscriptionRootLaplaceTokenTvlStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceTokenTvlStreamCursorInput>>;
  where?: InputMaybe<LaplaceTokenTvlBoolExp>;
};


export type SubscriptionRootLaplaceYieldTokenPoolArgs = {
  distinct_on?: InputMaybe<Array<LaplaceYieldTokenPoolSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceYieldTokenPoolOrderBy>>;
  where?: InputMaybe<LaplaceYieldTokenPoolBoolExp>;
};


export type SubscriptionRootLaplaceYieldTokenPoolAggregateArgs = {
  distinct_on?: InputMaybe<Array<LaplaceYieldTokenPoolSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<LaplaceYieldTokenPoolOrderBy>>;
  where?: InputMaybe<LaplaceYieldTokenPoolBoolExp>;
};


export type SubscriptionRootLaplaceYieldTokenPoolByPkArgs = {
  block_height: Scalars['numeric'];
  expiry: Scalars['numeric'];
  yield_token: Scalars['String'];
};


export type SubscriptionRootLaplaceYieldTokenPoolStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<LaplaceYieldTokenPoolStreamCursorInput>>;
  where?: InputMaybe<LaplaceYieldTokenPoolBoolExp>;
};


export type SubscriptionRootPublicDbtAutoalexApowerDistributionArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtAutoalexApowerDistributionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtAutoalexApowerDistributionOrderBy>>;
  where?: InputMaybe<PublicDbtAutoalexApowerDistributionBoolExp>;
};


export type SubscriptionRootPublicDbtAutoalexApowerDistributionAggregateArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtAutoalexApowerDistributionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtAutoalexApowerDistributionOrderBy>>;
  where?: InputMaybe<PublicDbtAutoalexApowerDistributionBoolExp>;
};


export type SubscriptionRootPublicDbtAutoalexApowerDistributionStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<PublicDbtAutoalexApowerDistributionStreamCursorInput>>;
  where?: InputMaybe<PublicDbtAutoalexApowerDistributionBoolExp>;
};


export type SubscriptionRootPublicDbtAutoalexClaimAndStakeArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtAutoalexClaimAndStakeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtAutoalexClaimAndStakeOrderBy>>;
  where?: InputMaybe<PublicDbtAutoalexClaimAndStakeBoolExp>;
};


export type SubscriptionRootPublicDbtAutoalexClaimAndStakeAggregateArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtAutoalexClaimAndStakeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtAutoalexClaimAndStakeOrderBy>>;
  where?: InputMaybe<PublicDbtAutoalexClaimAndStakeBoolExp>;
};


export type SubscriptionRootPublicDbtAutoalexClaimAndStakeStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<PublicDbtAutoalexClaimAndStakeStreamCursorInput>>;
  where?: InputMaybe<PublicDbtAutoalexClaimAndStakeBoolExp>;
};


export type SubscriptionRootPublicDbtAutoalexLockdropSnapshotConfigArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtAutoalexLockdropSnapshotConfigSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtAutoalexLockdropSnapshotConfigOrderBy>>;
  where?: InputMaybe<PublicDbtAutoalexLockdropSnapshotConfigBoolExp>;
};


export type SubscriptionRootPublicDbtAutoalexLockdropSnapshotConfigAggregateArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtAutoalexLockdropSnapshotConfigSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtAutoalexLockdropSnapshotConfigOrderBy>>;
  where?: InputMaybe<PublicDbtAutoalexLockdropSnapshotConfigBoolExp>;
};


export type SubscriptionRootPublicDbtAutoalexLockdropSnapshotConfigStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<PublicDbtAutoalexLockdropSnapshotConfigStreamCursorInput>>;
  where?: InputMaybe<PublicDbtAutoalexLockdropSnapshotConfigBoolExp>;
};


export type SubscriptionRootPublicDbtAutoalexSnapshotConfigArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtAutoalexSnapshotConfigSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtAutoalexSnapshotConfigOrderBy>>;
  where?: InputMaybe<PublicDbtAutoalexSnapshotConfigBoolExp>;
};


export type SubscriptionRootPublicDbtAutoalexSnapshotConfigAggregateArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtAutoalexSnapshotConfigSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtAutoalexSnapshotConfigOrderBy>>;
  where?: InputMaybe<PublicDbtAutoalexSnapshotConfigBoolExp>;
};


export type SubscriptionRootPublicDbtAutoalexSnapshotConfigStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<PublicDbtAutoalexSnapshotConfigStreamCursorInput>>;
  where?: InputMaybe<PublicDbtAutoalexSnapshotConfigBoolExp>;
};


export type SubscriptionRootPublicDbtDimAutoalexApowerCycleRewardStatusArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimAutoalexApowerCycleRewardStatusSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimAutoalexApowerCycleRewardStatusOrderBy>>;
  where?: InputMaybe<PublicDbtDimAutoalexApowerCycleRewardStatusBoolExp>;
};


export type SubscriptionRootPublicDbtDimAutoalexApowerCycleRewardStatusAggregateArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimAutoalexApowerCycleRewardStatusSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimAutoalexApowerCycleRewardStatusOrderBy>>;
  where?: InputMaybe<PublicDbtDimAutoalexApowerCycleRewardStatusBoolExp>;
};


export type SubscriptionRootPublicDbtDimAutoalexApowerCycleRewardStatusStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<PublicDbtDimAutoalexApowerCycleRewardStatusStreamCursorInput>>;
  where?: InputMaybe<PublicDbtDimAutoalexApowerCycleRewardStatusBoolExp>;
};


export type SubscriptionRootPublicDbtDimBalanceAlexStakedLockdropOffetsArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimBalanceAlexStakedLockdropOffetsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimBalanceAlexStakedLockdropOffetsOrderBy>>;
  where?: InputMaybe<PublicDbtDimBalanceAlexStakedLockdropOffetsBoolExp>;
};


export type SubscriptionRootPublicDbtDimBalanceAlexStakedLockdropOffetsAggregateArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimBalanceAlexStakedLockdropOffetsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimBalanceAlexStakedLockdropOffetsOrderBy>>;
  where?: InputMaybe<PublicDbtDimBalanceAlexStakedLockdropOffetsBoolExp>;
};


export type SubscriptionRootPublicDbtDimBalanceAlexStakedLockdropOffetsStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<PublicDbtDimBalanceAlexStakedLockdropOffetsStreamCursorInput>>;
  where?: InputMaybe<PublicDbtDimBalanceAlexStakedLockdropOffetsBoolExp>;
};


export type SubscriptionRootPublicDbtDimBalanceAutoalexApowerDistributionArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimBalanceAutoalexApowerDistributionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimBalanceAutoalexApowerDistributionOrderBy>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexApowerDistributionBoolExp>;
};


export type SubscriptionRootPublicDbtDimBalanceAutoalexApowerDistributionAggregateArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimBalanceAutoalexApowerDistributionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimBalanceAutoalexApowerDistributionOrderBy>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexApowerDistributionBoolExp>;
};


export type SubscriptionRootPublicDbtDimBalanceAutoalexApowerDistributionStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<PublicDbtDimBalanceAutoalexApowerDistributionStreamCursorInput>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexApowerDistributionBoolExp>;
};


export type SubscriptionRootPublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewOrderBy>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewBoolExp>;
};


export type SubscriptionRootPublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewAggregateArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewOrderBy>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewBoolExp>;
};


export type SubscriptionRootPublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewStreamCursorInput>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexLockdrop2RankSnapshotViewBoolExp>;
};


export type SubscriptionRootPublicDbtDimBalanceAutoalexLockdrop2RankViewArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimBalanceAutoalexLockdrop2RankViewSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimBalanceAutoalexLockdrop2RankViewOrderBy>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexLockdrop2RankViewBoolExp>;
};


export type SubscriptionRootPublicDbtDimBalanceAutoalexLockdrop2RankViewAggregateArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimBalanceAutoalexLockdrop2RankViewSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimBalanceAutoalexLockdrop2RankViewOrderBy>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexLockdrop2RankViewBoolExp>;
};


export type SubscriptionRootPublicDbtDimBalanceAutoalexLockdrop2RankViewStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<PublicDbtDimBalanceAutoalexLockdrop2RankViewStreamCursorInput>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexLockdrop2RankViewBoolExp>;
};


export type SubscriptionRootPublicDbtDimBalanceAutoalexRankOnHeightViewArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankOnHeightViewSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankOnHeightViewOrderBy>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexRankOnHeightViewBoolExp>;
};


export type SubscriptionRootPublicDbtDimBalanceAutoalexRankOnHeightViewAggregateArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankOnHeightViewSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankOnHeightViewOrderBy>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexRankOnHeightViewBoolExp>;
};


export type SubscriptionRootPublicDbtDimBalanceAutoalexRankOnHeightViewStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<PublicDbtDimBalanceAutoalexRankOnHeightViewStreamCursorInput>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexRankOnHeightViewBoolExp>;
};


export type SubscriptionRootPublicDbtDimBalanceAutoalexRankSnapshotViewArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankSnapshotViewSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankSnapshotViewOrderBy>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexRankSnapshotViewBoolExp>;
};


export type SubscriptionRootPublicDbtDimBalanceAutoalexRankSnapshotViewAggregateArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankSnapshotViewSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankSnapshotViewOrderBy>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexRankSnapshotViewBoolExp>;
};


export type SubscriptionRootPublicDbtDimBalanceAutoalexRankSnapshotViewStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<PublicDbtDimBalanceAutoalexRankSnapshotViewStreamCursorInput>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexRankSnapshotViewBoolExp>;
};


export type SubscriptionRootPublicDbtDimBalanceAutoalexRankViewArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankViewSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankViewOrderBy>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexRankViewBoolExp>;
};


export type SubscriptionRootPublicDbtDimBalanceAutoalexRankViewAggregateArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankViewSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimBalanceAutoalexRankViewOrderBy>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexRankViewBoolExp>;
};


export type SubscriptionRootPublicDbtDimBalanceAutoalexRankViewStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<PublicDbtDimBalanceAutoalexRankViewStreamCursorInput>>;
  where?: InputMaybe<PublicDbtDimBalanceAutoalexRankViewBoolExp>;
};


export type SubscriptionRootPublicDbtDimIdosInfoArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimIdosInfoSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimIdosInfoOrderBy>>;
  where?: InputMaybe<PublicDbtDimIdosInfoBoolExp>;
};


export type SubscriptionRootPublicDbtDimIdosInfoAggregateArgs = {
  distinct_on?: InputMaybe<Array<PublicDbtDimIdosInfoSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PublicDbtDimIdosInfoOrderBy>>;
  where?: InputMaybe<PublicDbtDimIdosInfoBoolExp>;
};


export type SubscriptionRootPublicDbtDimIdosInfoStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<PublicDbtDimIdosInfoStreamCursorInput>>;
  where?: InputMaybe<PublicDbtDimIdosInfoBoolExp>;
};


export type SubscriptionRootSmartContractsArgs = {
  distinct_on?: InputMaybe<Array<SmartContractsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<SmartContractsOrderBy>>;
  where?: InputMaybe<SmartContractsBoolExp>;
};


export type SubscriptionRootSmartContractsAggregateArgs = {
  distinct_on?: InputMaybe<Array<SmartContractsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<SmartContractsOrderBy>>;
  where?: InputMaybe<SmartContractsBoolExp>;
};


export type SubscriptionRootSmartContractsByPkArgs = {
  id: Scalars['Int'];
};


export type SubscriptionRootSmartContractsStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<SmartContractsStreamCursorInput>>;
  where?: InputMaybe<SmartContractsBoolExp>;
};


export type SubscriptionRootStxEventsArgs = {
  distinct_on?: InputMaybe<Array<StxEventsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StxEventsOrderBy>>;
  where?: InputMaybe<StxEventsBoolExp>;
};


export type SubscriptionRootStxEventsAggregateArgs = {
  distinct_on?: InputMaybe<Array<StxEventsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StxEventsOrderBy>>;
  where?: InputMaybe<StxEventsBoolExp>;
};


export type SubscriptionRootStxEventsByPkArgs = {
  id: Scalars['Int'];
};


export type SubscriptionRootStxEventsStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<StxEventsStreamCursorInput>>;
  where?: InputMaybe<StxEventsBoolExp>;
};


export type SubscriptionRootTxsArgs = {
  distinct_on?: InputMaybe<Array<TxsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<TxsOrderBy>>;
  where?: InputMaybe<TxsBoolExp>;
};


export type SubscriptionRootTxsAggregateArgs = {
  distinct_on?: InputMaybe<Array<TxsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<TxsOrderBy>>;
  where?: InputMaybe<TxsBoolExp>;
};


export type SubscriptionRootTxsByPkArgs = {
  id: Scalars['Int'];
};


export type SubscriptionRootTxsStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<TxsStreamCursorInput>>;
  where?: InputMaybe<TxsBoolExp>;
};

/** Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'. */
export type TimestamptzComparisonExp = {
  _eq?: InputMaybe<Scalars['timestamptz']>;
  _gt?: InputMaybe<Scalars['timestamptz']>;
  _gte?: InputMaybe<Scalars['timestamptz']>;
  _in?: InputMaybe<Array<Scalars['timestamptz']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['timestamptz']>;
  _lte?: InputMaybe<Scalars['timestamptz']>;
  _neq?: InputMaybe<Scalars['timestamptz']>;
  _nin?: InputMaybe<Array<Scalars['timestamptz']>>;
};

/** columns and relationships of "txs" */
export type Txs = {
  __typename?: 'txs';
  anchor_mode: Scalars['smallint'];
  block_hash: Scalars['bytea'];
  block_height: Scalars['Int'];
  burn_block_time: Scalars['Int'];
  canonical: Scalars['Boolean'];
  coinbase_payload?: Maybe<Scalars['bytea']>;
  contract_call_contract_id?: Maybe<Scalars['String']>;
  contract_call_function_args?: Maybe<Scalars['bytea']>;
  contract_call_function_name?: Maybe<Scalars['String']>;
  event_count: Scalars['Int'];
  execution_cost_read_count: Scalars['bigint'];
  execution_cost_read_length: Scalars['bigint'];
  execution_cost_runtime: Scalars['bigint'];
  execution_cost_write_count: Scalars['bigint'];
  execution_cost_write_length: Scalars['bigint'];
  fee_rate: Scalars['bigint'];
  id: Scalars['Int'];
  index_block_hash: Scalars['bytea'];
  microblock_canonical: Scalars['Boolean'];
  microblock_hash: Scalars['bytea'];
  microblock_sequence: Scalars['Int'];
  nonce: Scalars['Int'];
  origin_hash_mode: Scalars['smallint'];
  parent_block_hash: Scalars['bytea'];
  parent_burn_block_time: Scalars['Int'];
  parent_index_block_hash: Scalars['bytea'];
  poison_microblock_header_1?: Maybe<Scalars['bytea']>;
  poison_microblock_header_2?: Maybe<Scalars['bytea']>;
  post_conditions: Scalars['bytea'];
  raw_result: Scalars['bytea'];
  raw_tx: Scalars['bytea'];
  sender_address: Scalars['String'];
  smart_contract_contract_id?: Maybe<Scalars['String']>;
  smart_contract_source_code?: Maybe<Scalars['String']>;
  sponsor_address?: Maybe<Scalars['String']>;
  sponsor_nonce?: Maybe<Scalars['Int']>;
  sponsored: Scalars['Boolean'];
  status: Scalars['smallint'];
  token_transfer_amount?: Maybe<Scalars['bigint']>;
  token_transfer_memo?: Maybe<Scalars['bytea']>;
  token_transfer_recipient_address?: Maybe<Scalars['String']>;
  tx_id: Scalars['bytea'];
  tx_index: Scalars['smallint'];
  type_id: Scalars['smallint'];
};

/** aggregated selection of "txs" */
export type TxsAggregate = {
  __typename?: 'txs_aggregate';
  aggregate?: Maybe<TxsAggregateFields>;
  nodes: Array<Txs>;
};

/** aggregate fields of "txs" */
export type TxsAggregateFields = {
  __typename?: 'txs_aggregate_fields';
  avg?: Maybe<TxsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<TxsMaxFields>;
  min?: Maybe<TxsMinFields>;
  stddev?: Maybe<TxsStddevFields>;
  stddev_pop?: Maybe<TxsStddevPopFields>;
  stddev_samp?: Maybe<TxsStddevSampFields>;
  sum?: Maybe<TxsSumFields>;
  var_pop?: Maybe<TxsVarPopFields>;
  var_samp?: Maybe<TxsVarSampFields>;
  variance?: Maybe<TxsVarianceFields>;
};


/** aggregate fields of "txs" */
export type TxsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TxsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type TxsAvgFields = {
  __typename?: 'txs_avg_fields';
  anchor_mode?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  event_count?: Maybe<Scalars['Float']>;
  execution_cost_read_count?: Maybe<Scalars['Float']>;
  execution_cost_read_length?: Maybe<Scalars['Float']>;
  execution_cost_runtime?: Maybe<Scalars['Float']>;
  execution_cost_write_count?: Maybe<Scalars['Float']>;
  execution_cost_write_length?: Maybe<Scalars['Float']>;
  fee_rate?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
  nonce?: Maybe<Scalars['Float']>;
  origin_hash_mode?: Maybe<Scalars['Float']>;
  parent_burn_block_time?: Maybe<Scalars['Float']>;
  sponsor_nonce?: Maybe<Scalars['Float']>;
  status?: Maybe<Scalars['Float']>;
  token_transfer_amount?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
  type_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "txs". All fields are combined with a logical 'AND'. */
export type TxsBoolExp = {
  _and?: InputMaybe<Array<TxsBoolExp>>;
  _not?: InputMaybe<TxsBoolExp>;
  _or?: InputMaybe<Array<TxsBoolExp>>;
  anchor_mode?: InputMaybe<SmallintComparisonExp>;
  block_hash?: InputMaybe<ByteaComparisonExp>;
  block_height?: InputMaybe<IntComparisonExp>;
  burn_block_time?: InputMaybe<IntComparisonExp>;
  canonical?: InputMaybe<BooleanComparisonExp>;
  coinbase_payload?: InputMaybe<ByteaComparisonExp>;
  contract_call_contract_id?: InputMaybe<StringComparisonExp>;
  contract_call_function_args?: InputMaybe<ByteaComparisonExp>;
  contract_call_function_name?: InputMaybe<StringComparisonExp>;
  event_count?: InputMaybe<IntComparisonExp>;
  execution_cost_read_count?: InputMaybe<BigintComparisonExp>;
  execution_cost_read_length?: InputMaybe<BigintComparisonExp>;
  execution_cost_runtime?: InputMaybe<BigintComparisonExp>;
  execution_cost_write_count?: InputMaybe<BigintComparisonExp>;
  execution_cost_write_length?: InputMaybe<BigintComparisonExp>;
  fee_rate?: InputMaybe<BigintComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  index_block_hash?: InputMaybe<ByteaComparisonExp>;
  microblock_canonical?: InputMaybe<BooleanComparisonExp>;
  microblock_hash?: InputMaybe<ByteaComparisonExp>;
  microblock_sequence?: InputMaybe<IntComparisonExp>;
  nonce?: InputMaybe<IntComparisonExp>;
  origin_hash_mode?: InputMaybe<SmallintComparisonExp>;
  parent_block_hash?: InputMaybe<ByteaComparisonExp>;
  parent_burn_block_time?: InputMaybe<IntComparisonExp>;
  parent_index_block_hash?: InputMaybe<ByteaComparisonExp>;
  poison_microblock_header_1?: InputMaybe<ByteaComparisonExp>;
  poison_microblock_header_2?: InputMaybe<ByteaComparisonExp>;
  post_conditions?: InputMaybe<ByteaComparisonExp>;
  raw_result?: InputMaybe<ByteaComparisonExp>;
  raw_tx?: InputMaybe<ByteaComparisonExp>;
  sender_address?: InputMaybe<StringComparisonExp>;
  smart_contract_contract_id?: InputMaybe<StringComparisonExp>;
  smart_contract_source_code?: InputMaybe<StringComparisonExp>;
  sponsor_address?: InputMaybe<StringComparisonExp>;
  sponsor_nonce?: InputMaybe<IntComparisonExp>;
  sponsored?: InputMaybe<BooleanComparisonExp>;
  status?: InputMaybe<SmallintComparisonExp>;
  token_transfer_amount?: InputMaybe<BigintComparisonExp>;
  token_transfer_memo?: InputMaybe<ByteaComparisonExp>;
  token_transfer_recipient_address?: InputMaybe<StringComparisonExp>;
  tx_id?: InputMaybe<ByteaComparisonExp>;
  tx_index?: InputMaybe<SmallintComparisonExp>;
  type_id?: InputMaybe<SmallintComparisonExp>;
};

/** unique or primary key constraints on table "txs" */
export enum TxsConstraint {
  /** unique or primary key constraint on columns "id" */
  TxsPkey = 'txs_pkey',
  /** unique or primary key constraint on columns "microblock_hash", "index_block_hash", "tx_id" */
  UniqueTxIdIndexBlockHashMicroblockHash = 'unique_tx_id_index_block_hash_microblock_hash'
}

/** input type for incrementing numeric columns in table "txs" */
export type TxsIncInput = {
  anchor_mode?: InputMaybe<Scalars['smallint']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  event_count?: InputMaybe<Scalars['Int']>;
  execution_cost_read_count?: InputMaybe<Scalars['bigint']>;
  execution_cost_read_length?: InputMaybe<Scalars['bigint']>;
  execution_cost_runtime?: InputMaybe<Scalars['bigint']>;
  execution_cost_write_count?: InputMaybe<Scalars['bigint']>;
  execution_cost_write_length?: InputMaybe<Scalars['bigint']>;
  fee_rate?: InputMaybe<Scalars['bigint']>;
  id?: InputMaybe<Scalars['Int']>;
  microblock_sequence?: InputMaybe<Scalars['Int']>;
  nonce?: InputMaybe<Scalars['Int']>;
  origin_hash_mode?: InputMaybe<Scalars['smallint']>;
  parent_burn_block_time?: InputMaybe<Scalars['Int']>;
  sponsor_nonce?: InputMaybe<Scalars['Int']>;
  status?: InputMaybe<Scalars['smallint']>;
  token_transfer_amount?: InputMaybe<Scalars['bigint']>;
  tx_index?: InputMaybe<Scalars['smallint']>;
  type_id?: InputMaybe<Scalars['smallint']>;
};

/** input type for inserting data into table "txs" */
export type TxsInsertInput = {
  anchor_mode?: InputMaybe<Scalars['smallint']>;
  block_hash?: InputMaybe<Scalars['bytea']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  canonical?: InputMaybe<Scalars['Boolean']>;
  coinbase_payload?: InputMaybe<Scalars['bytea']>;
  contract_call_contract_id?: InputMaybe<Scalars['String']>;
  contract_call_function_args?: InputMaybe<Scalars['bytea']>;
  contract_call_function_name?: InputMaybe<Scalars['String']>;
  event_count?: InputMaybe<Scalars['Int']>;
  execution_cost_read_count?: InputMaybe<Scalars['bigint']>;
  execution_cost_read_length?: InputMaybe<Scalars['bigint']>;
  execution_cost_runtime?: InputMaybe<Scalars['bigint']>;
  execution_cost_write_count?: InputMaybe<Scalars['bigint']>;
  execution_cost_write_length?: InputMaybe<Scalars['bigint']>;
  fee_rate?: InputMaybe<Scalars['bigint']>;
  id?: InputMaybe<Scalars['Int']>;
  index_block_hash?: InputMaybe<Scalars['bytea']>;
  microblock_canonical?: InputMaybe<Scalars['Boolean']>;
  microblock_hash?: InputMaybe<Scalars['bytea']>;
  microblock_sequence?: InputMaybe<Scalars['Int']>;
  nonce?: InputMaybe<Scalars['Int']>;
  origin_hash_mode?: InputMaybe<Scalars['smallint']>;
  parent_block_hash?: InputMaybe<Scalars['bytea']>;
  parent_burn_block_time?: InputMaybe<Scalars['Int']>;
  parent_index_block_hash?: InputMaybe<Scalars['bytea']>;
  poison_microblock_header_1?: InputMaybe<Scalars['bytea']>;
  poison_microblock_header_2?: InputMaybe<Scalars['bytea']>;
  post_conditions?: InputMaybe<Scalars['bytea']>;
  raw_result?: InputMaybe<Scalars['bytea']>;
  raw_tx?: InputMaybe<Scalars['bytea']>;
  sender_address?: InputMaybe<Scalars['String']>;
  smart_contract_contract_id?: InputMaybe<Scalars['String']>;
  smart_contract_source_code?: InputMaybe<Scalars['String']>;
  sponsor_address?: InputMaybe<Scalars['String']>;
  sponsor_nonce?: InputMaybe<Scalars['Int']>;
  sponsored?: InputMaybe<Scalars['Boolean']>;
  status?: InputMaybe<Scalars['smallint']>;
  token_transfer_amount?: InputMaybe<Scalars['bigint']>;
  token_transfer_memo?: InputMaybe<Scalars['bytea']>;
  token_transfer_recipient_address?: InputMaybe<Scalars['String']>;
  tx_id?: InputMaybe<Scalars['bytea']>;
  tx_index?: InputMaybe<Scalars['smallint']>;
  type_id?: InputMaybe<Scalars['smallint']>;
};

/** aggregate max on columns */
export type TxsMaxFields = {
  __typename?: 'txs_max_fields';
  anchor_mode?: Maybe<Scalars['smallint']>;
  block_height?: Maybe<Scalars['Int']>;
  burn_block_time?: Maybe<Scalars['Int']>;
  contract_call_contract_id?: Maybe<Scalars['String']>;
  contract_call_function_name?: Maybe<Scalars['String']>;
  event_count?: Maybe<Scalars['Int']>;
  execution_cost_read_count?: Maybe<Scalars['bigint']>;
  execution_cost_read_length?: Maybe<Scalars['bigint']>;
  execution_cost_runtime?: Maybe<Scalars['bigint']>;
  execution_cost_write_count?: Maybe<Scalars['bigint']>;
  execution_cost_write_length?: Maybe<Scalars['bigint']>;
  fee_rate?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['Int']>;
  microblock_sequence?: Maybe<Scalars['Int']>;
  nonce?: Maybe<Scalars['Int']>;
  origin_hash_mode?: Maybe<Scalars['smallint']>;
  parent_burn_block_time?: Maybe<Scalars['Int']>;
  sender_address?: Maybe<Scalars['String']>;
  smart_contract_contract_id?: Maybe<Scalars['String']>;
  smart_contract_source_code?: Maybe<Scalars['String']>;
  sponsor_address?: Maybe<Scalars['String']>;
  sponsor_nonce?: Maybe<Scalars['Int']>;
  status?: Maybe<Scalars['smallint']>;
  token_transfer_amount?: Maybe<Scalars['bigint']>;
  token_transfer_recipient_address?: Maybe<Scalars['String']>;
  tx_index?: Maybe<Scalars['smallint']>;
  type_id?: Maybe<Scalars['smallint']>;
};

/** aggregate min on columns */
export type TxsMinFields = {
  __typename?: 'txs_min_fields';
  anchor_mode?: Maybe<Scalars['smallint']>;
  block_height?: Maybe<Scalars['Int']>;
  burn_block_time?: Maybe<Scalars['Int']>;
  contract_call_contract_id?: Maybe<Scalars['String']>;
  contract_call_function_name?: Maybe<Scalars['String']>;
  event_count?: Maybe<Scalars['Int']>;
  execution_cost_read_count?: Maybe<Scalars['bigint']>;
  execution_cost_read_length?: Maybe<Scalars['bigint']>;
  execution_cost_runtime?: Maybe<Scalars['bigint']>;
  execution_cost_write_count?: Maybe<Scalars['bigint']>;
  execution_cost_write_length?: Maybe<Scalars['bigint']>;
  fee_rate?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['Int']>;
  microblock_sequence?: Maybe<Scalars['Int']>;
  nonce?: Maybe<Scalars['Int']>;
  origin_hash_mode?: Maybe<Scalars['smallint']>;
  parent_burn_block_time?: Maybe<Scalars['Int']>;
  sender_address?: Maybe<Scalars['String']>;
  smart_contract_contract_id?: Maybe<Scalars['String']>;
  smart_contract_source_code?: Maybe<Scalars['String']>;
  sponsor_address?: Maybe<Scalars['String']>;
  sponsor_nonce?: Maybe<Scalars['Int']>;
  status?: Maybe<Scalars['smallint']>;
  token_transfer_amount?: Maybe<Scalars['bigint']>;
  token_transfer_recipient_address?: Maybe<Scalars['String']>;
  tx_index?: Maybe<Scalars['smallint']>;
  type_id?: Maybe<Scalars['smallint']>;
};

/** response of any mutation on the table "txs" */
export type TxsMutationResponse = {
  __typename?: 'txs_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Txs>;
};

/** on_conflict condition type for table "txs" */
export type TxsOnConflict = {
  constraint: TxsConstraint;
  update_columns?: Array<TxsUpdateColumn>;
  where?: InputMaybe<TxsBoolExp>;
};

/** Ordering options when selecting data from "txs". */
export type TxsOrderBy = {
  anchor_mode?: InputMaybe<OrderBy>;
  block_hash?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  burn_block_time?: InputMaybe<OrderBy>;
  canonical?: InputMaybe<OrderBy>;
  coinbase_payload?: InputMaybe<OrderBy>;
  contract_call_contract_id?: InputMaybe<OrderBy>;
  contract_call_function_args?: InputMaybe<OrderBy>;
  contract_call_function_name?: InputMaybe<OrderBy>;
  event_count?: InputMaybe<OrderBy>;
  execution_cost_read_count?: InputMaybe<OrderBy>;
  execution_cost_read_length?: InputMaybe<OrderBy>;
  execution_cost_runtime?: InputMaybe<OrderBy>;
  execution_cost_write_count?: InputMaybe<OrderBy>;
  execution_cost_write_length?: InputMaybe<OrderBy>;
  fee_rate?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  index_block_hash?: InputMaybe<OrderBy>;
  microblock_canonical?: InputMaybe<OrderBy>;
  microblock_hash?: InputMaybe<OrderBy>;
  microblock_sequence?: InputMaybe<OrderBy>;
  nonce?: InputMaybe<OrderBy>;
  origin_hash_mode?: InputMaybe<OrderBy>;
  parent_block_hash?: InputMaybe<OrderBy>;
  parent_burn_block_time?: InputMaybe<OrderBy>;
  parent_index_block_hash?: InputMaybe<OrderBy>;
  poison_microblock_header_1?: InputMaybe<OrderBy>;
  poison_microblock_header_2?: InputMaybe<OrderBy>;
  post_conditions?: InputMaybe<OrderBy>;
  raw_result?: InputMaybe<OrderBy>;
  raw_tx?: InputMaybe<OrderBy>;
  sender_address?: InputMaybe<OrderBy>;
  smart_contract_contract_id?: InputMaybe<OrderBy>;
  smart_contract_source_code?: InputMaybe<OrderBy>;
  sponsor_address?: InputMaybe<OrderBy>;
  sponsor_nonce?: InputMaybe<OrderBy>;
  sponsored?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  token_transfer_amount?: InputMaybe<OrderBy>;
  token_transfer_memo?: InputMaybe<OrderBy>;
  token_transfer_recipient_address?: InputMaybe<OrderBy>;
  tx_id?: InputMaybe<OrderBy>;
  tx_index?: InputMaybe<OrderBy>;
  type_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: txs */
export type TxsPkColumnsInput = {
  id: Scalars['Int'];
};

/** select columns of table "txs" */
export enum TxsSelectColumn {
  /** column name */
  AnchorMode = 'anchor_mode',
  /** column name */
  BlockHash = 'block_hash',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  Canonical = 'canonical',
  /** column name */
  CoinbasePayload = 'coinbase_payload',
  /** column name */
  ContractCallContractId = 'contract_call_contract_id',
  /** column name */
  ContractCallFunctionArgs = 'contract_call_function_args',
  /** column name */
  ContractCallFunctionName = 'contract_call_function_name',
  /** column name */
  EventCount = 'event_count',
  /** column name */
  ExecutionCostReadCount = 'execution_cost_read_count',
  /** column name */
  ExecutionCostReadLength = 'execution_cost_read_length',
  /** column name */
  ExecutionCostRuntime = 'execution_cost_runtime',
  /** column name */
  ExecutionCostWriteCount = 'execution_cost_write_count',
  /** column name */
  ExecutionCostWriteLength = 'execution_cost_write_length',
  /** column name */
  FeeRate = 'fee_rate',
  /** column name */
  Id = 'id',
  /** column name */
  IndexBlockHash = 'index_block_hash',
  /** column name */
  MicroblockCanonical = 'microblock_canonical',
  /** column name */
  MicroblockHash = 'microblock_hash',
  /** column name */
  MicroblockSequence = 'microblock_sequence',
  /** column name */
  Nonce = 'nonce',
  /** column name */
  OriginHashMode = 'origin_hash_mode',
  /** column name */
  ParentBlockHash = 'parent_block_hash',
  /** column name */
  ParentBurnBlockTime = 'parent_burn_block_time',
  /** column name */
  ParentIndexBlockHash = 'parent_index_block_hash',
  /** column name */
  PoisonMicroblockHeader_1 = 'poison_microblock_header_1',
  /** column name */
  PoisonMicroblockHeader_2 = 'poison_microblock_header_2',
  /** column name */
  PostConditions = 'post_conditions',
  /** column name */
  RawResult = 'raw_result',
  /** column name */
  RawTx = 'raw_tx',
  /** column name */
  SenderAddress = 'sender_address',
  /** column name */
  SmartContractContractId = 'smart_contract_contract_id',
  /** column name */
  SmartContractSourceCode = 'smart_contract_source_code',
  /** column name */
  SponsorAddress = 'sponsor_address',
  /** column name */
  SponsorNonce = 'sponsor_nonce',
  /** column name */
  Sponsored = 'sponsored',
  /** column name */
  Status = 'status',
  /** column name */
  TokenTransferAmount = 'token_transfer_amount',
  /** column name */
  TokenTransferMemo = 'token_transfer_memo',
  /** column name */
  TokenTransferRecipientAddress = 'token_transfer_recipient_address',
  /** column name */
  TxId = 'tx_id',
  /** column name */
  TxIndex = 'tx_index',
  /** column name */
  TypeId = 'type_id'
}

/** input type for updating data in table "txs" */
export type TxsSetInput = {
  anchor_mode?: InputMaybe<Scalars['smallint']>;
  block_hash?: InputMaybe<Scalars['bytea']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  canonical?: InputMaybe<Scalars['Boolean']>;
  coinbase_payload?: InputMaybe<Scalars['bytea']>;
  contract_call_contract_id?: InputMaybe<Scalars['String']>;
  contract_call_function_args?: InputMaybe<Scalars['bytea']>;
  contract_call_function_name?: InputMaybe<Scalars['String']>;
  event_count?: InputMaybe<Scalars['Int']>;
  execution_cost_read_count?: InputMaybe<Scalars['bigint']>;
  execution_cost_read_length?: InputMaybe<Scalars['bigint']>;
  execution_cost_runtime?: InputMaybe<Scalars['bigint']>;
  execution_cost_write_count?: InputMaybe<Scalars['bigint']>;
  execution_cost_write_length?: InputMaybe<Scalars['bigint']>;
  fee_rate?: InputMaybe<Scalars['bigint']>;
  id?: InputMaybe<Scalars['Int']>;
  index_block_hash?: InputMaybe<Scalars['bytea']>;
  microblock_canonical?: InputMaybe<Scalars['Boolean']>;
  microblock_hash?: InputMaybe<Scalars['bytea']>;
  microblock_sequence?: InputMaybe<Scalars['Int']>;
  nonce?: InputMaybe<Scalars['Int']>;
  origin_hash_mode?: InputMaybe<Scalars['smallint']>;
  parent_block_hash?: InputMaybe<Scalars['bytea']>;
  parent_burn_block_time?: InputMaybe<Scalars['Int']>;
  parent_index_block_hash?: InputMaybe<Scalars['bytea']>;
  poison_microblock_header_1?: InputMaybe<Scalars['bytea']>;
  poison_microblock_header_2?: InputMaybe<Scalars['bytea']>;
  post_conditions?: InputMaybe<Scalars['bytea']>;
  raw_result?: InputMaybe<Scalars['bytea']>;
  raw_tx?: InputMaybe<Scalars['bytea']>;
  sender_address?: InputMaybe<Scalars['String']>;
  smart_contract_contract_id?: InputMaybe<Scalars['String']>;
  smart_contract_source_code?: InputMaybe<Scalars['String']>;
  sponsor_address?: InputMaybe<Scalars['String']>;
  sponsor_nonce?: InputMaybe<Scalars['Int']>;
  sponsored?: InputMaybe<Scalars['Boolean']>;
  status?: InputMaybe<Scalars['smallint']>;
  token_transfer_amount?: InputMaybe<Scalars['bigint']>;
  token_transfer_memo?: InputMaybe<Scalars['bytea']>;
  token_transfer_recipient_address?: InputMaybe<Scalars['String']>;
  tx_id?: InputMaybe<Scalars['bytea']>;
  tx_index?: InputMaybe<Scalars['smallint']>;
  type_id?: InputMaybe<Scalars['smallint']>;
};

/** aggregate stddev on columns */
export type TxsStddevFields = {
  __typename?: 'txs_stddev_fields';
  anchor_mode?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  event_count?: Maybe<Scalars['Float']>;
  execution_cost_read_count?: Maybe<Scalars['Float']>;
  execution_cost_read_length?: Maybe<Scalars['Float']>;
  execution_cost_runtime?: Maybe<Scalars['Float']>;
  execution_cost_write_count?: Maybe<Scalars['Float']>;
  execution_cost_write_length?: Maybe<Scalars['Float']>;
  fee_rate?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
  nonce?: Maybe<Scalars['Float']>;
  origin_hash_mode?: Maybe<Scalars['Float']>;
  parent_burn_block_time?: Maybe<Scalars['Float']>;
  sponsor_nonce?: Maybe<Scalars['Float']>;
  status?: Maybe<Scalars['Float']>;
  token_transfer_amount?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
  type_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type TxsStddevPopFields = {
  __typename?: 'txs_stddev_pop_fields';
  anchor_mode?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  event_count?: Maybe<Scalars['Float']>;
  execution_cost_read_count?: Maybe<Scalars['Float']>;
  execution_cost_read_length?: Maybe<Scalars['Float']>;
  execution_cost_runtime?: Maybe<Scalars['Float']>;
  execution_cost_write_count?: Maybe<Scalars['Float']>;
  execution_cost_write_length?: Maybe<Scalars['Float']>;
  fee_rate?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
  nonce?: Maybe<Scalars['Float']>;
  origin_hash_mode?: Maybe<Scalars['Float']>;
  parent_burn_block_time?: Maybe<Scalars['Float']>;
  sponsor_nonce?: Maybe<Scalars['Float']>;
  status?: Maybe<Scalars['Float']>;
  token_transfer_amount?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
  type_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type TxsStddevSampFields = {
  __typename?: 'txs_stddev_samp_fields';
  anchor_mode?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  event_count?: Maybe<Scalars['Float']>;
  execution_cost_read_count?: Maybe<Scalars['Float']>;
  execution_cost_read_length?: Maybe<Scalars['Float']>;
  execution_cost_runtime?: Maybe<Scalars['Float']>;
  execution_cost_write_count?: Maybe<Scalars['Float']>;
  execution_cost_write_length?: Maybe<Scalars['Float']>;
  fee_rate?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
  nonce?: Maybe<Scalars['Float']>;
  origin_hash_mode?: Maybe<Scalars['Float']>;
  parent_burn_block_time?: Maybe<Scalars['Float']>;
  sponsor_nonce?: Maybe<Scalars['Float']>;
  status?: Maybe<Scalars['Float']>;
  token_transfer_amount?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
  type_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "txs" */
export type TxsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TxsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TxsStreamCursorValueInput = {
  anchor_mode?: InputMaybe<Scalars['smallint']>;
  block_hash?: InputMaybe<Scalars['bytea']>;
  block_height?: InputMaybe<Scalars['Int']>;
  burn_block_time?: InputMaybe<Scalars['Int']>;
  canonical?: InputMaybe<Scalars['Boolean']>;
  coinbase_payload?: InputMaybe<Scalars['bytea']>;
  contract_call_contract_id?: InputMaybe<Scalars['String']>;
  contract_call_function_args?: InputMaybe<Scalars['bytea']>;
  contract_call_function_name?: InputMaybe<Scalars['String']>;
  event_count?: InputMaybe<Scalars['Int']>;
  execution_cost_read_count?: InputMaybe<Scalars['bigint']>;
  execution_cost_read_length?: InputMaybe<Scalars['bigint']>;
  execution_cost_runtime?: InputMaybe<Scalars['bigint']>;
  execution_cost_write_count?: InputMaybe<Scalars['bigint']>;
  execution_cost_write_length?: InputMaybe<Scalars['bigint']>;
  fee_rate?: InputMaybe<Scalars['bigint']>;
  id?: InputMaybe<Scalars['Int']>;
  index_block_hash?: InputMaybe<Scalars['bytea']>;
  microblock_canonical?: InputMaybe<Scalars['Boolean']>;
  microblock_hash?: InputMaybe<Scalars['bytea']>;
  microblock_sequence?: InputMaybe<Scalars['Int']>;
  nonce?: InputMaybe<Scalars['Int']>;
  origin_hash_mode?: InputMaybe<Scalars['smallint']>;
  parent_block_hash?: InputMaybe<Scalars['bytea']>;
  parent_burn_block_time?: InputMaybe<Scalars['Int']>;
  parent_index_block_hash?: InputMaybe<Scalars['bytea']>;
  poison_microblock_header_1?: InputMaybe<Scalars['bytea']>;
  poison_microblock_header_2?: InputMaybe<Scalars['bytea']>;
  post_conditions?: InputMaybe<Scalars['bytea']>;
  raw_result?: InputMaybe<Scalars['bytea']>;
  raw_tx?: InputMaybe<Scalars['bytea']>;
  sender_address?: InputMaybe<Scalars['String']>;
  smart_contract_contract_id?: InputMaybe<Scalars['String']>;
  smart_contract_source_code?: InputMaybe<Scalars['String']>;
  sponsor_address?: InputMaybe<Scalars['String']>;
  sponsor_nonce?: InputMaybe<Scalars['Int']>;
  sponsored?: InputMaybe<Scalars['Boolean']>;
  status?: InputMaybe<Scalars['smallint']>;
  token_transfer_amount?: InputMaybe<Scalars['bigint']>;
  token_transfer_memo?: InputMaybe<Scalars['bytea']>;
  token_transfer_recipient_address?: InputMaybe<Scalars['String']>;
  tx_id?: InputMaybe<Scalars['bytea']>;
  tx_index?: InputMaybe<Scalars['smallint']>;
  type_id?: InputMaybe<Scalars['smallint']>;
};

/** aggregate sum on columns */
export type TxsSumFields = {
  __typename?: 'txs_sum_fields';
  anchor_mode?: Maybe<Scalars['smallint']>;
  block_height?: Maybe<Scalars['Int']>;
  burn_block_time?: Maybe<Scalars['Int']>;
  event_count?: Maybe<Scalars['Int']>;
  execution_cost_read_count?: Maybe<Scalars['bigint']>;
  execution_cost_read_length?: Maybe<Scalars['bigint']>;
  execution_cost_runtime?: Maybe<Scalars['bigint']>;
  execution_cost_write_count?: Maybe<Scalars['bigint']>;
  execution_cost_write_length?: Maybe<Scalars['bigint']>;
  fee_rate?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['Int']>;
  microblock_sequence?: Maybe<Scalars['Int']>;
  nonce?: Maybe<Scalars['Int']>;
  origin_hash_mode?: Maybe<Scalars['smallint']>;
  parent_burn_block_time?: Maybe<Scalars['Int']>;
  sponsor_nonce?: Maybe<Scalars['Int']>;
  status?: Maybe<Scalars['smallint']>;
  token_transfer_amount?: Maybe<Scalars['bigint']>;
  tx_index?: Maybe<Scalars['smallint']>;
  type_id?: Maybe<Scalars['smallint']>;
};

/** update columns of table "txs" */
export enum TxsUpdateColumn {
  /** column name */
  AnchorMode = 'anchor_mode',
  /** column name */
  BlockHash = 'block_hash',
  /** column name */
  BlockHeight = 'block_height',
  /** column name */
  BurnBlockTime = 'burn_block_time',
  /** column name */
  Canonical = 'canonical',
  /** column name */
  CoinbasePayload = 'coinbase_payload',
  /** column name */
  ContractCallContractId = 'contract_call_contract_id',
  /** column name */
  ContractCallFunctionArgs = 'contract_call_function_args',
  /** column name */
  ContractCallFunctionName = 'contract_call_function_name',
  /** column name */
  EventCount = 'event_count',
  /** column name */
  ExecutionCostReadCount = 'execution_cost_read_count',
  /** column name */
  ExecutionCostReadLength = 'execution_cost_read_length',
  /** column name */
  ExecutionCostRuntime = 'execution_cost_runtime',
  /** column name */
  ExecutionCostWriteCount = 'execution_cost_write_count',
  /** column name */
  ExecutionCostWriteLength = 'execution_cost_write_length',
  /** column name */
  FeeRate = 'fee_rate',
  /** column name */
  Id = 'id',
  /** column name */
  IndexBlockHash = 'index_block_hash',
  /** column name */
  MicroblockCanonical = 'microblock_canonical',
  /** column name */
  MicroblockHash = 'microblock_hash',
  /** column name */
  MicroblockSequence = 'microblock_sequence',
  /** column name */
  Nonce = 'nonce',
  /** column name */
  OriginHashMode = 'origin_hash_mode',
  /** column name */
  ParentBlockHash = 'parent_block_hash',
  /** column name */
  ParentBurnBlockTime = 'parent_burn_block_time',
  /** column name */
  ParentIndexBlockHash = 'parent_index_block_hash',
  /** column name */
  PoisonMicroblockHeader_1 = 'poison_microblock_header_1',
  /** column name */
  PoisonMicroblockHeader_2 = 'poison_microblock_header_2',
  /** column name */
  PostConditions = 'post_conditions',
  /** column name */
  RawResult = 'raw_result',
  /** column name */
  RawTx = 'raw_tx',
  /** column name */
  SenderAddress = 'sender_address',
  /** column name */
  SmartContractContractId = 'smart_contract_contract_id',
  /** column name */
  SmartContractSourceCode = 'smart_contract_source_code',
  /** column name */
  SponsorAddress = 'sponsor_address',
  /** column name */
  SponsorNonce = 'sponsor_nonce',
  /** column name */
  Sponsored = 'sponsored',
  /** column name */
  Status = 'status',
  /** column name */
  TokenTransferAmount = 'token_transfer_amount',
  /** column name */
  TokenTransferMemo = 'token_transfer_memo',
  /** column name */
  TokenTransferRecipientAddress = 'token_transfer_recipient_address',
  /** column name */
  TxId = 'tx_id',
  /** column name */
  TxIndex = 'tx_index',
  /** column name */
  TypeId = 'type_id'
}

export type TxsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TxsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TxsSetInput>;
  where: TxsBoolExp;
};

/** aggregate var_pop on columns */
export type TxsVarPopFields = {
  __typename?: 'txs_var_pop_fields';
  anchor_mode?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  event_count?: Maybe<Scalars['Float']>;
  execution_cost_read_count?: Maybe<Scalars['Float']>;
  execution_cost_read_length?: Maybe<Scalars['Float']>;
  execution_cost_runtime?: Maybe<Scalars['Float']>;
  execution_cost_write_count?: Maybe<Scalars['Float']>;
  execution_cost_write_length?: Maybe<Scalars['Float']>;
  fee_rate?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
  nonce?: Maybe<Scalars['Float']>;
  origin_hash_mode?: Maybe<Scalars['Float']>;
  parent_burn_block_time?: Maybe<Scalars['Float']>;
  sponsor_nonce?: Maybe<Scalars['Float']>;
  status?: Maybe<Scalars['Float']>;
  token_transfer_amount?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
  type_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type TxsVarSampFields = {
  __typename?: 'txs_var_samp_fields';
  anchor_mode?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  event_count?: Maybe<Scalars['Float']>;
  execution_cost_read_count?: Maybe<Scalars['Float']>;
  execution_cost_read_length?: Maybe<Scalars['Float']>;
  execution_cost_runtime?: Maybe<Scalars['Float']>;
  execution_cost_write_count?: Maybe<Scalars['Float']>;
  execution_cost_write_length?: Maybe<Scalars['Float']>;
  fee_rate?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
  nonce?: Maybe<Scalars['Float']>;
  origin_hash_mode?: Maybe<Scalars['Float']>;
  parent_burn_block_time?: Maybe<Scalars['Float']>;
  sponsor_nonce?: Maybe<Scalars['Float']>;
  status?: Maybe<Scalars['Float']>;
  token_transfer_amount?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
  type_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type TxsVarianceFields = {
  __typename?: 'txs_variance_fields';
  anchor_mode?: Maybe<Scalars['Float']>;
  block_height?: Maybe<Scalars['Float']>;
  burn_block_time?: Maybe<Scalars['Float']>;
  event_count?: Maybe<Scalars['Float']>;
  execution_cost_read_count?: Maybe<Scalars['Float']>;
  execution_cost_read_length?: Maybe<Scalars['Float']>;
  execution_cost_runtime?: Maybe<Scalars['Float']>;
  execution_cost_write_count?: Maybe<Scalars['Float']>;
  execution_cost_write_length?: Maybe<Scalars['Float']>;
  fee_rate?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  microblock_sequence?: Maybe<Scalars['Float']>;
  nonce?: Maybe<Scalars['Float']>;
  origin_hash_mode?: Maybe<Scalars['Float']>;
  parent_burn_block_time?: Maybe<Scalars['Float']>;
  sponsor_nonce?: Maybe<Scalars['Float']>;
  status?: Maybe<Scalars['Float']>;
  token_transfer_amount?: Maybe<Scalars['Float']>;
  tx_index?: Maybe<Scalars['Float']>;
  type_id?: Maybe<Scalars['Float']>;
};

export type GetCoingeckoDataQueryVariables = Exact<{
  token: Scalars['String'];
}>;


export type GetCoingeckoDataQuery = { __typename?: 'query_root', laplace_coin_gecko: Array<{ __typename?: 'laplace_coin_gecko', token: string, avg_price_usd: any, coin_gecko_id: string, prices_market: any, timestamp: any }> };


export const GetCoingeckoDataDocument = gql`
    query get_coingecko_data($token: String!) {
  laplace_coin_gecko(where: {token: {_eq: $token}}) {
    token
    avg_price_usd
    coin_gecko_id
    prices_market
    timestamp
  }
}
    `;

export type SdkFunctionWrapper = <T>(action: (requestHeaders?:Record<string, string>) => Promise<T>, operationName: string, operationType?: string) => Promise<T>;


const defaultWrapper: SdkFunctionWrapper = (action, _operationName, _operationType) => action();

export function getSdk(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) {
  return {
    get_coingecko_data(variables: GetCoingeckoDataQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetCoingeckoDataQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetCoingeckoDataQuery>(GetCoingeckoDataDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'get_coingecko_data', 'query');
    }
  };
}
export type Sdk = ReturnType<typeof getSdk>;